
# Matrix

## Design Tic-Tac-Toe {#tic-tac-toe}

## Word Search {#word-search}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 79
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/word-search/
- **Tags**: `Matrix`, `Backtracking`
- **Techniques**: Backtracking \@ref(backtrack), Depth First Search \@ref(dfs)

### Description

Given a board of characters and a target word, check if the word can be constructed from sequentially adjacent cells (horizontal or vertical). Each cell can be used at most once.

### Examples

```
Input:
[["A","B","C","E"],
 ["S","F","C","S"],
 ["A","D","E","E"]], word = "ABCCED"
Output: true
```

### Constraints

- `1 <= board.length, board[0].length <= 6`
- `1 <= word.length <= 15`

### Solution - DFS Backtracking

#### Walkthrough

Try every cell as a starting point. Recursively match characters by exploring four directions, marking the current cell as visited to avoid reuse. If we reach the end of the word, return true; otherwise backtrack by restoring the cell.

#### Analysis

- **Time Complexity**: O(m * n * 4^L) where `L` is the word length
- **Space Complexity**: O(L) recursion stack

#### Algorithm

1. Loop over all cells `(i, j)`.
2. Call `dfs(i, j, index)` when the character matches `word[index]`.
3. Base case: `index == word.length()` → success.
4. On mismatch or out of bounds, return false.
5. Temporarily mark cell as visited, recurse to neighbors, then restore.

#### Java Code

```java
private static final char VISITED = '#';

public boolean exist(char[][] board, String word) {
    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[0].length; j++) {
            if (dfs(board, word, i, j, 0)) {
                return true;
            }
        }
    }
    return false;
}

private boolean dfs(char[][] board, String word, int row, int col, int index) {
    if (index == word.length()) {
        return true;
    }
    if (row < 0 || row >= board.length || col < 0 || col >= board[0].length) {
        return false;
    }
    if (board[row][col] != word.charAt(index)) {
        return false;
    }

    char saved = board[row][col];
    board[row][col] = VISITED;

    boolean found = dfs(board, word, row + 1, col, index + 1)
            || dfs(board, word, row - 1, col, index + 1)
            || dfs(board, word, row, col + 1, index + 1)
            || dfs(board, word, row, col - 1, index + 1);

    board[row][col] = saved;
    return found;
}
```
### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 348
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/design-tic-tac-toe/
- **Tags**: `Matrix`, `Prefix Sum`
- **Techniques**: Matrix Accumulators \@ref(matrix-traversal)

### Description

Design a Tic-Tac-Toe game on an `n x n` board. Implement `move(row, col, player)` that places the player's mark and returns `0` if no one wins, or the player's number if they win.

### Examples

```
Input:
["TicTacToe","move","move","move","move","move","move","move"]
[[3],[0,0,1],[0,2,2],[2,2,1],[1,1,2],[2,0,1],[1,0,2],[2,1,1]]
Output: [null,0,0,0,0,0,0,1]
```

### Constraints

- `n` between 1 and 100
- Calls to `move` do not place on occupied cells

### Solution - Running Counts

#### Walkthrough

Instead of scanning entire rows/columns after each move, keep running counts:

1. `rows[i]` stores the net score for row `i`, `cols[j]` for column `j`.
2. Add `+1` for player 1 or `-1` for player 2.
3. Maintain two diagonals.
4. If any absolute value reaches `n`, that player wins.

#### Analysis

- **Time Complexity**: O(1) per move
- **Space Complexity**: O(n)

#### Algorithm

1. Initialize arrays `rows`, `cols`, and two scalars for diagonals.
2. For each move, add `score = player == 1 ? 1 : -1` to the row/column.
3. Update diagonals when applicable.
4. Check if any absolute value equals `n`; return winner or `0`.

#### Java Code

```java
class TicTacToe {
    private final int[] rows;
    private final int[] cols;
    private int diag;
    private int antiDiag;

    public TicTacToe(int n) {
        rows = new int[n];
        cols = new int[n];
    }

    public int move(int row, int col, int player) {
        int score = player == 1 ? 1 : -1;
        rows[row] += score;
        cols[col] += score;

        if (row == col) {
            diag += score;
        }
        if (row + col == rows.length - 1) {
            antiDiag += score;
        }

        if (Math.abs(rows[row]) == rows.length
            || Math.abs(cols[col]) == rows.length
            || Math.abs(diag) == rows.length
            || Math.abs(antiDiag) == rows.length) {
            return player;
        }

        return 0;
    }
}
```


## Rotate Image {#rotate-image}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 48
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/rotate-image/
- **Tags**: `Matrix`, `In-place`
- **Techniques**: Matrix Manipulation \@ref(matrix-manipulation)

### Description

Rotate an `n x n` matrix by 90 degrees clockwise in place (without allocating another matrix).

### Examples

```
Input:
[1,2,3]
[4,5,6]
[7,8,9]

Output:
[7,4,1]
[8,5,2]
[9,6,3]
```

### Constraints

- `1 <= n <= 20`

### Solution - Transpose + Reverse

#### Walkthrough

The rotation can be decomposed into two steps:

1. Transpose the matrix along the main diagonal (swap `matrix[i][j]` with `matrix[j][i]` for `j < i`).
2. Reverse each row (swap columns symmetrically around the vertical midline).

This achieves the 90-degree rotation in-place.

#### Analysis

- **Time Complexity**: O(n²)
- **Space Complexity**: O(1)

#### Algorithm

1. For each `i`, `j < i`, swap `matrix[i][j]` with `matrix[j][i]`.
2. For each row, swap `matrix[row][left]` with `matrix[row][right]` while moving inward.

#### Java Code

```java
public void rotate(int[][] matrix) {
    int n = matrix.length;

    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int tmp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = tmp;
        }
    }

    for (int row = 0; row < n; row++) {
        int left = 0, right = n - 1;
        while (left < right) {
            int tmp = matrix[row][left];
            matrix[row][left] = matrix[row][right];
            matrix[row][right] = tmp;
            left++;
            right--;
        }
    }
}
```



## Spiral Matrix {#spiral-matrix}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 54
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/spiral-matrix/
- **Tags**: `Matrix`
- **Techniques**: Matrix Traversal \@ref(matrix-traversal)

### Description

Given an `m x n` matrix, return all elements in spiral order.

### Examples

```
Input:
[[1,2,3],
 [4,5,6],
 [7,8,9]]
Output: [1,2,3,6,9,8,7,4,5]
```

### Constraints

- `1 <= m, n <= 10`

### Solution - Boundary Simulation

#### Walkthrough

Maintain four boundaries (`top`, `bottom`, `left`, `right`). Traverse in the order: top row → right column → bottom row → left column, shrinking the corresponding boundary after each pass. Stop when pointers cross.

#### Analysis

- **Time Complexity**: O(m * n)
- **Space Complexity**: O(1) (excluding output)

#### Algorithm

1. Initialize `top = 0`, `bottom = m-1`, `left = 0`, `right = n-1`.
2. While `top <= bottom` and `left <= right`:
   - Traverse top row left→right, increment `top`.
   - Traverse right column top→bottom, decrement `right`.
   - If `top <= bottom`, traverse bottom row right→left, decrement `bottom`.
   - If `left <= right`, traverse left column bottom→top, increment `left`.

#### Java Code

```java
public List<Integer> spiralOrder(int[][] matrix) {
    List<Integer> result = new ArrayList<>();
    if (matrix.length == 0) {
        return result;
    }

    int top = 0;
    int bottom = matrix.length - 1;
    int left = 0;
    int right = matrix[0].length - 1;

    while (top <= bottom && left <= right) {
        for (int col = left; col <= right; col++) {
            result.add(matrix[top][col]);
        }
        top++;

        for (int row = top; row <= bottom; row++) {
            result.add(matrix[row][right]);
        }
        right--;

        if (top <= bottom) {
            for (int col = right; col >= left; col--) {
                result.add(matrix[bottom][col]);
            }
            bottom--;
        }

        if (left <= right) {
            for (int row = bottom; row >= top; row--) {
                result.add(matrix[row][left]);
            }
            left++;
        }
    }

    return result;
}
```
    int cols = matrix[0].length;

    // position of left, right, top and buttom border
    int left = 0;
    int right = cols - 1;
    int top = 0;
    int bottom = rows - 1;

    while( result.size() < (cols * rows) ) {
        //traverse a circle

        // avoid duplicated row
        if(top > bottom) {
            break;
        }

        //going rightward
        for(int i = left; i <= right; i++){
            result.add(matrix[top][i]);
        }
        top++;

        // avoid duplicated column
        if(left > right) {
            break;
        }

        //going downward
        for(int i = top; i <= bottom; i++){
            result.add(matrix[i][right]);
        }
        right--;

        // avoid duplicated row
        if(top > bottom) {
            break;
        }

        // going leftward
        for(int i = right; i >= left; i--){
            result.add(matrix[bottom][i]);
        }
        bottom--;

        // avoid duplicated column
        if(left > right) {
            break;
        }

        // going upward
        for(int i = bottom; i >= top; i--){
            result.add(matrix[i][left]);
        }
        left++;
    }

    return result;
}
```


## Search a 2D Matrix {#search-matrix}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 74
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/search-a-2d-matrix/
- **Tags**: `Matrix`, `Binary Search`
- **Techniques**: Binary Search \@ref(binary-search), Divide and Conquer \@ref(dnc)

### Description

Each row of the matrix is sorted, and the first element of each row is greater than the last element of the previous row. Determine if a target value exists in the matrix.

### Examples

```
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,50]], target = 3
Output: true
```

### Constraints

- `1 <= m, n <= 100`
- Matrix entries are integers

### Solution - Treat as 1D

#### Walkthrough

Because every row starts after the prior row ends, we can treat the matrix as a flattened sorted array of length `m * n`. Perform binary search using virtual indices; convert a mid index back to row/col by division and modulus.

#### Analysis

- **Time Complexity**: O(log(m * n))
- **Space Complexity**: O(1)

#### Algorithm

1. Let `low = 0`, `high = m * n - 1`.
2. While `low <= high`:
   1. `mid = (low + high) / 2`.
   2. Map to `row = mid / n`, `col = mid % n`.
   3. Compare `matrix[row][col]` with target and adjust bounds.
3. Return `false` if not found.

#### Java Code

```java
public boolean searchMatrix(int[][] matrix, int target) {
    if (matrix.length == 0 || matrix[0].length == 0) {
        return false;
    }

    int rows = matrix.length;
    int cols = matrix[0].length;
    int left = 0;
    int right = rows * cols - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        int r = mid / cols;
        int c = mid % cols;
        int value = matrix[r][c];

        if (value == target) {
            return true;
        } else if (value < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return false;
}
```


## Search a 2D Matrix II {#search-matrix-ii}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 240
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/search-a-2d-matrix-ii/
- **Tags**: `Matrix`
- **Techniques**: Matrix Traversal \@ref(matrix-traversal)

### Description

The matrix is sorted in ascending order both across rows and down columns. Determine whether a target value exists.

### Examples

```
Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
Output: true
```

### Constraints

- `1 <= m, n <= 300`

### Solution - Staircase Search

#### Walkthrough

Start in the top-right corner (or bottom-left). At each step:

- If the value is greater than target, move left (eliminate a column).
- If smaller, move down (eliminate a row).

Because of the sorted property, one direction always reduces the search space.

#### Analysis

- **Time Complexity**: O(m + n)
- **Space Complexity**: O(1)

#### Algorithm

1. Set `row = 0`, `col = n - 1`.
2. While `row < m` and `col >= 0`:
   - If `matrix[row][col] == target`, return true.
   - If greater, `col--`; otherwise `row++`.
3. Return false if not found.

#### Java Code

```java
public boolean searchMatrix(int[][] matrix, int target) {
    if (matrix.length == 0 || matrix[0].length == 0) {
        return false;
    }

    int row = 0;
    int col = matrix[0].length - 1;

    while (row < matrix.length && col >= 0) {
        int value = matrix[row][col];
        if (value == target) {
            return true;
        } else if (value > target) {
            col--;
        } else {
            row++;
        }
    }

    return false;
}
```


## Minimum Path Sum {#min-path-sum}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 64
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/minimum-path-sum/
- **Tags**: `Matrix`, `Dynamic Programming`
- **Techniques**: Dynamic Programming \@ref(dp)

### Description

Given a grid of non-negative numbers, move only right or down from the top-left cell to the bottom-right, minimizing the sum of values along the path.

### Examples

```
Input: [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
```

### Constraints

- `1 <= m, n <= 200`

### Solution - DP Table

#### Walkthrough

Set `dp[i][j]` to the minimum sum needed to reach `(i, j)`. Initialize the first row and column with cumulative sums. For each other cell, add the current value to the minimum of the top or left neighbor.

#### Analysis

- **Time Complexity**: O(m * n)
- **Space Complexity**: O(m * n) (can be optimized to O(n))

#### Algorithm

1. Initialize `dp[0][0] = grid[0][0]`.
2. Fill the first row/column cumulatively.
3. For `i > 0`, `j > 0`, set `dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])`.
4. Return `dp[m-1][n-1]`.

#### Java Code

```java
public int minPathSum(int[][] grid) {
    int rows = grid.length;
    int cols = grid[0].length;
    int[][] dp = new int[rows][cols];

    dp[0][0] = grid[0][0];
    for (int c = 1; c < cols; c++) {
        dp[0][c] = dp[0][c - 1] + grid[0][c];
    }
    for (int r = 1; r < rows; r++) {
        dp[r][0] = dp[r - 1][0] + grid[r][0];
    }

    for (int r = 1; r < rows; r++) {
        for (int c = 1; c < cols; c++) {
            dp[r][c] = grid[r][c] + Math.min(dp[r - 1][c], dp[r][c - 1]);
        }
    }

    return dp[rows - 1][cols - 1];
}
```


## Unique Paths {#unique-paths}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 62
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/unique-paths/
- **Tags**: `Matrix`, `Dynamic Programming`
- **Techniques**: Dynamic Programming \@ref(dp)

### Description

A robot can move only right or down on an `m x n` grid from the top-left to the bottom-right. Count the number of unique paths.

### Examples

```
Input: m = 3, n = 7
Output: 28
```

### Constraints

- `1 <= m, n <= 100`

### Solution - DP Grid

#### Walkthrough

Paths to `(i, j)` equal the sum of paths to `(i-1, j)` and `(i, j-1)` since those are the only ways to enter. Initialize the first row and column to 1 because there is only one way to reach those cells.

#### Analysis

- **Time Complexity**: O(m * n)
- **Space Complexity**: O(m * n) (or O(n) with rolling arrays)

#### Algorithm

1. Fill a DP matrix with `dp[0][*] = dp[*][0] = 1`.
2. For each cell from `(1,1)` to `(m-1,n-1)` compute `dp[i][j] = dp[i-1][j] + dp[i][j-1]`.
3. Return `dp[m-1][n-1]`.

#### Java Code

```java
public int uniquePaths(int m, int n) {
    int[][] dp = new int[m][n];
    for (int i = 0; i < m; i++) {
        dp[i][0] = 1;
    }
    for (int j = 0; j < n; j++) {
        dp[0][j] = 1;
    }
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}
```









## Number of Islands {#number-of-islands}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 200
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/number-of-islands/
- **Tags**: `Matrix`, `DFS`
- **Techniques**: Depth First Search \@ref(dfs)

### Description

Given a grid of `'1'` (land) and `'0'` (water), count the number of islands where islands are connected horizontally or vertically.

### Examples

```
Input:
11110
11010
11000
00000
Output: 1
```

### Constraints

- `1 <= rows, cols <= 300`

### Solution - Flood Fill

#### Walkthrough

Scan every cell. Upon encountering a `'1'`, increment the island count and perform DFS/BFS to mark the entire island as visited (turn to `'0'` or another marker). Continue scanning until all land is processed.

#### Analysis

- **Time Complexity**: O(rows * cols)
- **Space Complexity**: O(rows * cols) recursion in worst case

#### Algorithm

1. Initialize `count = 0`.
2. For each cell:
   - If it is `'1'`, run DFS that changes it and its connected neighbors to `'0'`, and increment `count`.
3. Return `count`.

#### Java Code

```java
public int numIslands(char[][] grid) {
    int rows = grid.length;
    int cols = grid[0].length;
    int islands = 0;

    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols; c++) {
            if (grid[r][c] == '1') {
                islands++;
                flood(grid, r, c);
            }
        }
    }

    return islands;
}

private void flood(char[][] grid, int r, int c) {
    if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] != '1') {
        return;
    }

    grid[r][c] = '0';
    flood(grid, r - 1, c);
    flood(grid, r + 1, c);
    flood(grid, r, c - 1);
    flood(grid, r, c + 1);
}
```
## Surrounded Regions {#surrounded-regions}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 130
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/surrounded-regions/
- **Tags**: `Matrix`, `DFS`
- **Techniques**: Depth First Search \@ref(dfs)

### Description

Given a board containing `'X'` and `'O'`, capture all regions surrounded by `'X'`. Only `'O'` cells fully enclosed (not connected to any border `'O'`) should be flipped to `'X'`.

### Examples

```
Input:
X X X X
X O O X
X X O X
X O X X
Output:
X X X X
X X X X
X X X X
X O X X
```

### Constraints

- `1 <= rows, cols <= 200`

### Solution - Mark Border Regions

#### Walkthrough

All `'O'` connected to the border must remain `'O'`. DFS from every border `'O'`, marking reachable cells with a placeholder (e.g., `'#'`). After marking, flip remaining `'O'` to `'X'`, and convert placeholders back to `'O'`.

#### Analysis

- **Time Complexity**: O(rows * cols)
- **Space Complexity**: O(rows * cols) recursion stack

#### Algorithm

1. Run DFS from border cells that are `'O'`, marking them as `'#'`.
2. Iterate the grid:
   - Flip `'O'` to `'X'` (enclosed region).
   - Flip `'#'` back to `'O'`.

#### Java Code

```java
public void solve(char[][] board) {
    if (board.length == 0 || board[0].length == 0) {
        return;
    }

    int rows = board.length;
    int cols = board[0].length;

    for (int r = 0; r < rows; r++) {
        dfs(board, r, 0);
        dfs(board, r, cols - 1);
    }
    for (int c = 0; c < cols; c++) {
        dfs(board, 0, c);
        dfs(board, rows - 1, c);
    }

    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols; c++) {
            if (board[r][c] == 'O') {
                board[r][c] = 'X';
            } else if (board[r][c] == '#') {
                board[r][c] = 'O';
            }
        }
    }
}

private void dfs(char[][] board, int r, int c) {
    if (r < 0 || r >= board.length || c < 0 || c >= board[0].length || board[r][c] != 'O') {
        return;
    }
    board[r][c] = '#';
    dfs(board, r - 1, c);
    dfs(board, r + 1, c);
    dfs(board, r, c - 1);
    dfs(board, r, c + 1);
}
```
## Best Meeting Point {#best-meeting-point}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 296
- **Difficulty**: Hard
- **URL**: https://leetcode.com/problems/best-meeting-point/
- **Tags**: `Matrix`, `Median`, `Sorting`
- **Techniques**: Sorting \@ref(sorting)

### Description

Given a 2D grid of 0s and 1s where each 1 represents a friend’s home, find the meeting point that minimizes the total Manhattan distance from all homes.

### Examples

```
Input: [[1,0,0,0,1],
        [0,0,0,0,0],
        [0,0,1,0,0]]
Output: 6
```

### Constraints

- `1 <= rows, cols <= 200`

### Solution - Median Trick

#### Walkthrough

The Manhattan distance sum is minimized by the median of row coordinates and column coordinates separately. Collect all row indices, all column indices, take medians, then sum absolute differences to these medians.

#### Analysis

- **Time Complexity**: O(m * n)
- **Space Complexity**: O(m + n)

#### Algorithm

1. Traverse the grid, collect row indices (`rows`) and column indices (`cols`) for all homes.
2. Sort lists (or rows inherently non-decreasing if traversed row-by-row).
3. Median row = `rows[rows.size/2]`, same for columns.
4. Sum absolute differences from medians.

#### Java Code

```java
public int minTotalDistance(int[][] grid) {
    List<Integer> rows = new ArrayList<>();
    List<Integer> cols = new ArrayList<>();

    for (int r = 0; r < grid.length; r++) {
        for (int c = 0; c < grid[0].length; c++) {
            if (grid[r][c] == 1) {
                rows.add(r);
            }
        }
    }

    for (int c = 0; c < grid[0].length; c++) {
        for (int r = 0; r < grid.length; r++) {
            if (grid[r][c] == 1) {
                cols.add(c);
            }
        }
    }

    int rowMedian = rows.get(rows.size() / 2);
    int colMedian = cols.get(cols.size() / 2);

    int distance = 0;
    for (int r : rows) {
        distance += Math.abs(r - rowMedian);
    }
    for (int c : cols) {
        distance += Math.abs(c - colMedian);
    }

    return distance;
}
```
