
# Matrix

## Design Tic-Tac-Toe {#tic-tac-toe}

## Word Search {#word-search}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 79
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/word-search/
- **Tags**: `Matrix`, `Backtracking`
- **Techniques**: Backtracking \@ref(backtrack), Depth First Search \@ref(dfs)

### Description

Given a board of characters and a target word, check if the word can be constructed from sequentially adjacent cells (horizontal or vertical). Each cell can be used at most once.

### Examples

```
Input:
[["A","B","C","E"],
 ["S","F","C","S"],
 ["A","D","E","E"]], word = "ABCCED"
Output: true
```

### Constraints

- `1 <= board.length, board[0].length <= 6`
- `1 <= word.length <= 15`

### Solution - DFS Backtracking

#### Walkthrough

Try every cell as a starting point. Recursively match characters by exploring four directions, marking the current cell as visited to avoid reuse. If we reach the end of the word, return true; otherwise backtrack by restoring the cell.

#### Analysis

- **Time Complexity**: O(m * n * 4^L) where `L` is the word length
- **Space Complexity**: O(L) recursion stack

#### Algorithm

1. Loop over all cells `(i, j)`.
2. Call `dfs(i, j, index)` when the character matches `word[index]`.
3. Base case: `index == word.length()` → success.
4. On mismatch or out of bounds, return false.
5. Temporarily mark cell as visited, recurse to neighbors, then restore.

#### Java Code

```java
private static final char VISITED = '#';

public boolean exist(char[][] board, String word) {
    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[0].length; j++) {
            if (dfs(board, word, i, j, 0)) {
                return true;
            }
        }
    }
    return false;
}

private boolean dfs(char[][] board, String word, int row, int col, int index) {
    if (index == word.length()) {
        return true;
    }
    if (row < 0 || row >= board.length || col < 0 || col >= board[0].length) {
        return false;
    }
    if (board[row][col] != word.charAt(index)) {
        return false;
    }

    char saved = board[row][col];
    board[row][col] = VISITED;

    boolean found = dfs(board, word, row + 1, col, index + 1)
            || dfs(board, word, row - 1, col, index + 1)
            || dfs(board, word, row, col + 1, index + 1)
            || dfs(board, word, row, col - 1, index + 1);

    board[row][col] = saved;
    return found;
}
```
### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 348
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/design-tic-tac-toe/
- **Tags**: `Matrix`, `Prefix Sum`
- **Techniques**: Matrix Accumulators \@ref(matrix-traversal)

### Description

Design a Tic-Tac-Toe game on an `n x n` board. Implement `move(row, col, player)` that places the player's mark and returns `0` if no one wins, or the player's number if they win.

### Examples

```
Input:
["TicTacToe","move","move","move","move","move","move","move"]
[[3],[0,0,1],[0,2,2],[2,2,1],[1,1,2],[2,0,1],[1,0,2],[2,1,1]]
Output: [null,0,0,0,0,0,0,1]
```

### Constraints

- `n` between 1 and 100
- Calls to `move` do not place on occupied cells

### Solution - Running Counts

#### Walkthrough

Instead of scanning entire rows/columns after each move, keep running counts:

1. `rows[i]` stores the net score for row `i`, `cols[j]` for column `j`.
2. Add `+1` for player 1 or `-1` for player 2.
3. Maintain two diagonals.
4. If any absolute value reaches `n`, that player wins.

#### Analysis

- **Time Complexity**: O(1) per move
- **Space Complexity**: O(n)

#### Algorithm

1. Initialize arrays `rows`, `cols`, and two scalars for diagonals.
2. For each move, add `score = player == 1 ? 1 : -1` to the row/column.
3. Update diagonals when applicable.
4. Check if any absolute value equals `n`; return winner or `0`.

#### Java Code

```java
class TicTacToe {
    private final int[] rows;
    private final int[] cols;
    private int diag;
    private int antiDiag;

    public TicTacToe(int n) {
        rows = new int[n];
        cols = new int[n];
    }

    public int move(int row, int col, int player) {
        int score = player == 1 ? 1 : -1;
        rows[row] += score;
        cols[col] += score;

        if (row == col) {
            diag += score;
        }
        if (row + col == rows.length - 1) {
            antiDiag += score;
        }

        if (Math.abs(rows[row]) == rows.length
            || Math.abs(cols[col]) == rows.length
            || Math.abs(diag) == rows.length
            || Math.abs(antiDiag) == rows.length) {
            return player;
        }

        return 0;
    }
}
```


## Rotate Image {#rotate-image}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 48
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/rotate-image/
- **Tags**: `Matrix`, `In-place`
- **Techniques**: Matrix Manipulation \@ref(matrix-manipulation)

### Description

Rotate an `n x n` matrix by 90 degrees clockwise in place (without allocating another matrix).

### Examples

```
Input:
[1,2,3]
[4,5,6]
[7,8,9]

Output:
[7,4,1]
[8,5,2]
[9,6,3]
```

### Constraints

- `1 <= n <= 20`

### Solution - Transpose + Reverse

#### Walkthrough

The rotation can be decomposed into two steps:

1. Transpose the matrix along the main diagonal (swap `matrix[i][j]` with `matrix[j][i]` for `j < i`).
2. Reverse each row (swap columns symmetrically around the vertical midline).

This achieves the 90-degree rotation in-place.

#### Analysis

- **Time Complexity**: O(n²)
- **Space Complexity**: O(1)

#### Algorithm

1. For each `i`, `j < i`, swap `matrix[i][j]` with `matrix[j][i]`.
2. For each row, swap `matrix[row][left]` with `matrix[row][right]` while moving inward.

#### Java Code

```java
public void rotate(int[][] matrix) {
    int n = matrix.length;

    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int tmp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = tmp;
        }
    }

    for (int row = 0; row < n; row++) {
        int left = 0, right = n - 1;
        while (left < right) {
            int tmp = matrix[row][left];
            matrix[row][left] = matrix[row][right];
            matrix[row][right] = tmp;
            left++;
            right--;
        }
    }
}
```



## Spiral Matrix {#spiral-matrix}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 54
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/spiral-matrix/
- **Tags**: `Matrix`
- **Techniques**: Matrix Traversal \@ref(matrix-traversal)

### Description

Given an `m x n` matrix, return all elements in spiral order.

### Examples

```
Input:
[[1,2,3],
 [4,5,6],
 [7,8,9]]
Output: [1,2,3,6,9,8,7,4,5]
```

### Constraints

- `1 <= m, n <= 10`

### Solution - Boundary Simulation

#### Walkthrough

Maintain four boundaries (`top`, `bottom`, `left`, `right`). Traverse in the order: top row → right column → bottom row → left column, shrinking the corresponding boundary after each pass. Stop when pointers cross.

#### Analysis

- **Time Complexity**: O(m * n)
- **Space Complexity**: O(1) (excluding output)

#### Algorithm

1. Initialize `top = 0`, `bottom = m-1`, `left = 0`, `right = n-1`.
2. While `top <= bottom` and `left <= right`:
   - Traverse top row left→right, increment `top`.
   - Traverse right column top→bottom, decrement `right`.
   - If `top <= bottom`, traverse bottom row right→left, decrement `bottom`.
   - If `left <= right`, traverse left column bottom→top, increment `left`.

#### Java Code

```java
public List<Integer> spiralOrder(int[][] matrix) {
    List<Integer> result = new ArrayList<>();
    if (matrix.length == 0) {
        return result;
    }

    int top = 0;
    int bottom = matrix.length - 1;
    int left = 0;
    int right = matrix[0].length - 1;

    while (top <= bottom && left <= right) {
        for (int col = left; col <= right; col++) {
            result.add(matrix[top][col]);
        }
        top++;

        for (int row = top; row <= bottom; row++) {
            result.add(matrix[row][right]);
        }
        right--;

        if (top <= bottom) {
            for (int col = right; col >= left; col--) {
                result.add(matrix[bottom][col]);
            }
            bottom--;
        }

        if (left <= right) {
            for (int row = bottom; row >= top; row--) {
                result.add(matrix[row][left]);
            }
            left++;
        }
    }

    return result;
}
```
    int cols = matrix[0].length;

    // position of left, right, top and buttom border
    int left = 0;
    int right = cols - 1;
    int top = 0;
    int bottom = rows - 1;

    while( result.size() < (cols * rows) ) {
        //traverse a circle

        // avoid duplicated row
        if(top > bottom) {
            break;
        }

        //going rightward
        for(int i = left; i <= right; i++){
            result.add(matrix[top][i]);
        }
        top++;

        // avoid duplicated column
        if(left > right) {
            break;
        }

        //going downward
        for(int i = top; i <= bottom; i++){
            result.add(matrix[i][right]);
        }
        right--;

        // avoid duplicated row
        if(top > bottom) {
            break;
        }

        // going leftward
        for(int i = right; i >= left; i--){
            result.add(matrix[bottom][i]);
        }
        bottom--;

        // avoid duplicated column
        if(left > right) {
            break;
        }

        // going upward
        for(int i = bottom; i >= top; i--){
            result.add(matrix[i][left]);
        }
        left++;
    }

    return result;
}
```


## Search a 2D Matrix {#search-matrix}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 74
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/search-a-2d-matrix/
- **Tags**: `Matrix`, `Binary Search`
- **Techniques**: Binary Search \@ref(binary-search), Divide and Conquer \@ref(dnc)

### Description

Each row of the matrix is sorted, and the first element of each row is greater than the last element of the previous row. Determine if a target value exists in the matrix.

### Examples

```
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,50]], target = 3
Output: true
```

### Constraints

- `1 <= m, n <= 100`
- Matrix entries are integers

### Solution - Treat as 1D

#### Walkthrough

Because every row starts after the prior row ends, we can treat the matrix as a flattened sorted array of length `m * n`. Perform binary search using virtual indices; convert a mid index back to row/col by division and modulus.

#### Analysis

- **Time Complexity**: O(log(m * n))
- **Space Complexity**: O(1)

#### Algorithm

1. Let `low = 0`, `high = m * n - 1`.
2. While `low <= high`:
   1. `mid = (low + high) / 2`.
   2. Map to `row = mid / n`, `col = mid % n`.
   3. Compare `matrix[row][col]` with target and adjust bounds.
3. Return `false` if not found.

#### Java Code

```java
public boolean searchMatrix(int[][] matrix, int target) {
    if (matrix.length == 0 || matrix[0].length == 0) {
        return false;
    }

    int rows = matrix.length;
    int cols = matrix[0].length;
    int left = 0;
    int right = rows * cols - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        int r = mid / cols;
        int c = mid % cols;
        int value = matrix[r][c];

        if (value == target) {
            return true;
        } else if (value < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return false;
}
```


## Search a 2D Matrix II {#search-matrix-ii}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 240
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/search-a-2d-matrix-ii/
- **Tags**: `Matrix`
- **Techniques**: Matrix Traversal \@ref(matrix-traversal)

### Description

The matrix is sorted in ascending order both across rows and down columns. Determine whether a target value exists.

### Examples

```
Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
Output: true
```

### Constraints

- `1 <= m, n <= 300`

### Solution - Staircase Search

#### Walkthrough

Start in the top-right corner (or bottom-left). At each step:

- If the value is greater than target, move left (eliminate a column).
- If smaller, move down (eliminate a row).

Because of the sorted property, one direction always reduces the search space.

#### Analysis

- **Time Complexity**: O(m + n)
- **Space Complexity**: O(1)

#### Algorithm

1. Set `row = 0`, `col = n - 1`.
2. While `row < m` and `col >= 0`:
   - If `matrix[row][col] == target`, return true.
   - If greater, `col--`; otherwise `row++`.
3. Return false if not found.

#### Java Code

```java
public boolean searchMatrix(int[][] matrix, int target) {
    if (matrix.length == 0 || matrix[0].length == 0) {
        return false;
    }

    int row = 0;
    int col = matrix[0].length - 1;

    while (row < matrix.length && col >= 0) {
        int value = matrix[row][col];
        if (value == target) {
            return true;
        } else if (value > target) {
            col--;
        } else {
            row++;
        }
    }

    return false;
}
```


## Minimum Path Sum {#min-path-sum}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 64
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/minimum-path-sum/
- **Tags**: `Matrix`, `Dynamic Programming`
- **Techniques**: Dynamic Programming \@ref(dp)

### Description

Given a grid of non-negative numbers, move only right or down from the top-left cell to the bottom-right, minimizing the sum of values along the path.

### Examples

```
Input: [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
```

### Constraints

- `1 <= m, n <= 200`

### Solution - DP Table

#### Walkthrough

Set `dp[i][j]` to the minimum sum needed to reach `(i, j)`. Initialize the first row and column with cumulative sums. For each other cell, add the current value to the minimum of the top or left neighbor.

#### Analysis

- **Time Complexity**: O(m * n)
- **Space Complexity**: O(m * n) (can be optimized to O(n))

#### Algorithm

1. Initialize `dp[0][0] = grid[0][0]`.
2. Fill the first row/column cumulatively.
3. For `i > 0`, `j > 0`, set `dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])`.
4. Return `dp[m-1][n-1]`.

#### Java Code

```java
public int minPathSum(int[][] grid) {
    int rows = grid.length;
    int cols = grid[0].length;
    int[][] dp = new int[rows][cols];

    dp[0][0] = grid[0][0];
    for (int c = 1; c < cols; c++) {
        dp[0][c] = dp[0][c - 1] + grid[0][c];
    }
    for (int r = 1; r < rows; r++) {
        dp[r][0] = dp[r - 1][0] + grid[r][0];
    }

    for (int r = 1; r < rows; r++) {
        for (int c = 1; c < cols; c++) {
            dp[r][c] = grid[r][c] + Math.min(dp[r - 1][c], dp[r][c - 1]);
        }
    }

    return dp[rows - 1][cols - 1];
}
```


## Unique Paths {#unique-paths}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 62
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/unique-paths/
- **Tags**: `Matrix`, `Dynamic Programming`
- **Techniques**: Dynamic Programming \@ref(dp)

### Description

A robot can move only right or down on an `m x n` grid from the top-left to the bottom-right. Count the number of unique paths.

### Examples

```
Input: m = 3, n = 7
Output: 28
```

### Constraints

- `1 <= m, n <= 100`

### Solution - DP Grid

#### Walkthrough

Paths to `(i, j)` equal the sum of paths to `(i-1, j)` and `(i, j-1)` since those are the only ways to enter. Initialize the first row and column to 1 because there is only one way to reach those cells.

#### Analysis

- **Time Complexity**: O(m * n)
- **Space Complexity**: O(m * n) (or O(n) with rolling arrays)

#### Algorithm

1. Fill a DP matrix with `dp[0][*] = dp[*][0] = 1`.
2. For each cell from `(1,1)` to `(m-1,n-1)` compute `dp[i][j] = dp[i-1][j] + dp[i][j-1]`.
3. Return `dp[m-1][n-1]`.

#### Java Code

```java
public int uniquePaths(int m, int n) {
    int[][] dp = new int[m][n];
    for (int i = 0; i < m; i++) {
        dp[i][0] = 1;
    }
    for (int j = 0; j < n; j++) {
        dp[0][j] = 1;
    }
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}
```









## Number of Islands {#number-of-islands}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 200
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/number-of-islands/
- **Tags**: `Matrix`, `DFS`
- **Techniques**: Depth First Search \@ref(dfs)

### Description

Given a grid of `'1'` (land) and `'0'` (water), count the number of islands where islands are connected horizontally or vertically.

### Examples

```
Input:
11110
11010
11000
00000
Output: 1
```

### Constraints

- `1 <= rows, cols <= 300`

### Solution - Flood Fill

#### Walkthrough

Scan every cell. Upon encountering a `'1'`, increment the island count and perform DFS/BFS to mark the entire island as visited (turn to `'0'` or another marker). Continue scanning until all land is processed.

#### Analysis

- **Time Complexity**: O(rows * cols)
- **Space Complexity**: O(rows * cols) recursion in worst case

#### Algorithm

1. Initialize `count = 0`.
2. For each cell:
   - If it is `'1'`, run DFS that changes it and its connected neighbors to `'0'`, and increment `count`.
3. Return `count`.

#### Java Code

```java
public int numIslands(char[][] grid) {
    int rows = grid.length;
    int cols = grid[0].length;
    int islands = 0;

    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols; c++) {
            if (grid[r][c] == '1') {
                islands++;
                flood(grid, r, c);
            }
        }
    }

    return islands;
}

private void flood(char[][] grid, int r, int c) {
    if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] != '1') {
        return;
    }

    grid[r][c] = '0';
    flood(grid, r - 1, c);
    flood(grid, r + 1, c);
    flood(grid, r, c - 1);
    flood(grid, r, c + 1);
}
```
## Surrounded Regions {#surrounded-regions}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 130
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/surrounded-regions/
- **Tags**: `Matrix`, `DFS`
- **Techniques**: Depth First Search \@ref(dfs)

### Description

Given a board containing `'X'` and `'O'`, capture all regions surrounded by `'X'`. Only `'O'` cells fully enclosed (not connected to any border `'O'`) should be flipped to `'X'`.

### Examples

```
Input:
X X X X
X O O X
X X O X
X O X X
Output:
X X X X
X X X X
X X X X
X O X X
```

### Constraints

- `1 <= rows, cols <= 200`

### Solution - Mark Border Regions

#### Walkthrough

All `'O'` connected to the border must remain `'O'`. DFS from every border `'O'`, marking reachable cells with a placeholder (e.g., `'#'`). After marking, flip remaining `'O'` to `'X'`, and convert placeholders back to `'O'`.

#### Analysis

- **Time Complexity**: O(rows * cols)
- **Space Complexity**: O(rows * cols) recursion stack

#### Algorithm

1. Run DFS from border cells that are `'O'`, marking them as `'#'`.
2. Iterate the grid:
   - Flip `'O'` to `'X'` (enclosed region).
   - Flip `'#'` back to `'O'`.

#### Java Code

```java
public void solve(char[][] board) {
    if (board.length == 0 || board[0].length == 0) {
        return;
    }

    int rows = board.length;
    int cols = board[0].length;

    for (int r = 0; r < rows; r++) {
        dfs(board, r, 0);
        dfs(board, r, cols - 1);
    }
    for (int c = 0; c < cols; c++) {
        dfs(board, 0, c);
        dfs(board, rows - 1, c);
    }

    for (int r = 0; r < rows; r++) {
        for (int c = 0; c < cols; c++) {
            if (board[r][c] == 'O') {
                board[r][c] = 'X';
            } else if (board[r][c] == '#') {
                board[r][c] = 'O';
            }
        }
    }
}

private void dfs(char[][] board, int r, int c) {
    if (r < 0 || r >= board.length || c < 0 || c >= board[0].length || board[r][c] != 'O') {
        return;
    }
    board[r][c] = '#';
    dfs(board, r - 1, c);
    dfs(board, r + 1, c);
    dfs(board, r, c - 1);
    dfs(board, r, c + 1);
}
```
## Maximal Square {#maximal-square}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 221
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/maximal-square/
- **Tags**: `Matrix`, `Dynamic Programming`
- **Techniques**: Dynamic Programming \@ref(dp)

### Description

Given an `m x n` binary matrix filled with `0`'s and `1`'s, find the largest square containing only `1`'s and return its area.

### Examples

**Example 1:**

```
Input: matrix = [["1","0","1","0","0"],
                 ["1","0","1","1","1"],
                 ["1","1","1","1","1"],
                 ["1","0","0","1","0"]]
Output: 4
Explanation: The largest square has side length 2, so area = 2 * 2 = 4
```

**Example 2:**

```
Input: matrix = [["0","1"],
                 ["1","0"]]
Output: 1
```

**Example 3:**

```
Input: matrix = [["0"]]
Output: 0
```

### Constraints

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 300`
- `matrix[i][j]` is `'0'` or `'1'`

### Solution - Dynamic Programming

#### Walkthrough

The key insight is that for any cell `(r, c)` containing `'1'`, the maximum square with that cell as the bottom-right corner depends on the minimum of three neighboring squares:

1. The square ending at `(r-1, c)` (cell above)
2. The square ending at `(r, c-1)` (cell to the left)
3. The square ending at `(r-1, c-1)` (diagonal cell)

If all three neighbors can form squares of side length `k`, then the current cell can form a square of side length `k+1`. This is because:
- The top neighbor ensures we have `k` rows of `1`'s above
- The left neighbor ensures we have `k` columns of `1`'s to the left
- The diagonal neighbor ensures the `k x k` square is filled with `1`'s

We use a DP table where `dp[r][c]` represents the side length of the largest square whose bottom-right corner is at `(r, c)`.

**Example Walkthrough:**

For the matrix:
```
["1","0","1","0","0"]
["1","0","1","1","1"]
["1","1","1","1","1"]
["1","0","0","1","0"]
```

The DP table builds as:
```
[1, 0, 1, 0, 0]
[1, 0, 1, 1, 1]
[1, 1, 1, 2, 2]  ← dp[2][3] = min(1,1,1) + 1 = 2
[1, 0, 0, 1, 0]
```

The maximum side length is 2, so the area is 2 × 2 = 4.

#### Analysis

- **Time Complexity**: O(m × n) - Single pass through the matrix
- **Space Complexity**: O(m × n) - DP table storage (can be optimized to O(n) using rolling arrays)

#### Algorithm

\@ref(dp)

1. Initialize a DP table `dp[rows][cols]` and `max_side = 0`
2. For each cell `(r, c)`:
   - If `matrix[r][c] == '1'`:
     - If it's in the first row or first column, `dp[r][c] = 1` (can only form 1×1 square)
     - Otherwise, `dp[r][c] = min(dp[r-1][c], dp[r][c-1], dp[r-1][c-1]) + 1`
     - Update `max_side` with the maximum side length seen
   - If `matrix[r][c] == '0'`, set `dp[r][c] = 0`
3. Return `max_side × max_side` (area = side²)

#### Java Code

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        int[][] dp = new int[rows][cols];
        int max_side = 0;

        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < cols; c++) {
                // Only process cells containing '1'
                if (matrix[r][c] == '1') {
                    // Base case: first row or first column
                    // Can only form a 1x1 square
                    if (r == 0 || c == 0) {
                        dp[r][c] = 1;
                    } else {
                        // DP transition: current square size is limited by
                        // the minimum of the three neighbors + 1
                        int min = Math.min(dp[r - 1][c], dp[r][c - 1]);
                        min = Math.min(min, dp[r - 1][c - 1]);
                        dp[r][c] = min + 1;
                    }

                    // Track the maximum side length encountered
                    max_side = Math.max(max_side, dp[r][c]);
                } else {
                    // Cell contains '0', cannot form a square
                    dp[r][c] = 0;
                }
            }
        }

        // Return area (side length squared)
        return max_side * max_side;
    }
}
```

## Count Square Submatrices with All Ones {#count-square-submatrices}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 1277
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/count-square-submatrices-with-all-ones/
- **Tags**: `Matrix`, `Dynamic Programming`
- **Techniques**: Dynamic Programming \@ref(dp)

### Description

Given a `m x n` matrix of ones and zeros, return how many **square** submatrices have all ones.

### Examples

**Example 1:**

```
Input: matrix =
[
  [0,1,1,1],
  [1,1,1,1],
  [0,1,1,1]
]
Output: 15
Explanation:
There are 10 squares of side 1.
There are 4 squares of side 2.
There is 1 square of side 3.
Total number of squares = 10 + 4 + 1 = 15.
```

**Example 2:**

```
Input: matrix =
[
  [1,0,1],
  [1,1,0],
  [1,1,0]
]
Output: 7
Explanation:
There are 6 squares of side 1.
There is 1 square of side 2.
Total number of squares = 6 + 1 = 7.
```

### Constraints

- `1 <= arr.length <= 300`
- `1 <= arr[0].length <= 300`
- `0 <= arr[i][j] <= 1`

### Solution - Dynamic Programming (In-Place)

#### Walkthrough

This problem is closely related to **Maximal Square (LeetCode 221)**, but instead of finding the largest square, we need to **count all squares**. The key insight is:

**For each cell `(r, c)` containing `1`, `dp[r][c]` represents the side length of the largest square with `(r, c)` as the bottom-right corner. This value also tells us HOW MANY squares end at this position.**

For example:
- If `dp[r][c] = 3`, it means there are **3 squares** ending at `(r, c)`:
  - One 1×1 square
  - One 2×2 square
  - One 3×3 square

The DP recurrence is the same as Maximal Square:
```
dp[r][c] = min(dp[r-1][c], dp[r][c-1], dp[r-1][c-1]) + 1
```

The total count is the **sum of all `dp[r][c]` values**.

#### Visual Example

For the input matrix:
```
[0, 1, 1, 1]
[1, 1, 1, 1]
[0, 1, 1, 1]
```

**Processing order (row by row, left to right):**

```
Step 1: (0,0)=0, skip
Step 2: (0,1)=1, result=1, matrix: [0, 1, 1, 1]
                                     [1, 1, 1, 1]
                                     [0, 1, 1, 1]

Step 3: (0,2)=1, result=2, matrix: [0, 1, 1, 1]
                                     [1, 1, 1, 1]
                                     [0, 1, 1, 1]

Step 4: (0,3)=1, result=3, matrix: [0, 1, 1, 1]
                                     [1, 1, 1, 1]
                                     [0, 1, 1, 1]

Step 5: (1,0)=1, result=4, matrix: [0, 1, 1, 1]
                                     [1, 1, 1, 1]
                                     [0, 1, 1, 1]

Step 6: (1,1)=1, result=5, matrix: [0, 1, 1, 1]
                    min(1,1,0)+1=1  [1, 1, 1, 1]
                    no change       [0, 1, 1, 1]

Step 7: (1,2)=1, result=6, matrix: [0, 1, 1, 1]
                    min(1,1,1)+1=2  [1, 1, 2, 1]
                    result += 1 = 7 [0, 1, 1, 1]

Step 8: (1,3)=1, result=8, matrix: [0, 1, 1, 1]
                    min(1,2,1)+1=2  [1, 1, 2, 2]
                    result += 1 = 9 [0, 1, 1, 1]

Step 9: (2,0)=0, skip

Step 10: (2,1)=1, result=10, matrix: [0, 1, 1, 1]
                                      [1, 1, 2, 2]
                                      [0, 1, 1, 1]

Step 11: (2,2)=1, result=11, matrix: [0, 1, 1, 1]
                     min(2,1,1)+1=2   [1, 1, 2, 2]
                     result += 1 = 12 [0, 1, 2, 1]

Step 12: (2,3)=1, result=13, matrix: [0, 1, 1, 1]
                     min(2,2,2)+1=3   [1, 1, 2, 2]
                     result += 2 = 15 [0, 1, 2, 3]
```

**Final result: 15**

#### Key Insight

The elegant part of this solution is that **the DP value at each cell directly tells us the count of squares ending at that position**. This is why we can simply sum all DP values to get the total count.

#### Analysis

- **Time Complexity**: O(m × n) - Single pass through the matrix
- **Space Complexity**: O(1) - Modifies matrix in-place (or O(m × n) if using separate DP table)

#### Algorithm

\@ref(dp)

1. Initialize `result = 0` to track total count
2. For each cell `(r, c)`:
   - If `matrix[r][c] == 1`:
     - Add `1` to result (every `1` forms at least a 1×1 square)
     - If not in first row or column:
       - Calculate `matrix[r][c] = min(top, left, diagonal) + 1`
       - Add `matrix[r][c] - 1` to result (additional squares of size 2×2, 3×3, etc.)
3. Return `result`

#### Java Code

```java
class Solution {
    public int countSquares(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        int result = 0;

        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < cols; c++) {
                // Only process cells containing 1
                if (matrix[r][c] == 1) {
                    // Each 1 can form at least a 1x1 square
                    result++;

                    // For cells not in first row/column, apply DP transition
                    if (r != 0 && c != 0) {
                        // DP transition: current square size is limited by
                        // the minimum of the three neighbors + 1
                        int min = Math.min(matrix[r - 1][c], matrix[r][c - 1]);
                        min = Math.min(min, matrix[r - 1][c - 1]);
                        matrix[r][c] = min + 1;

                        // Add additional squares (2x2, 3x3, ..., NxN)
                        // If matrix[r][c] = 3, we already counted the 1x1,
                        // so add 2 more for the 2x2 and 3x3 squares
                        result += matrix[r][c] - 1;
                    }
                }
            }
        }

        return result;
    }
}
```

## Best Meeting Point {#best-meeting-point}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 296
- **Difficulty**: Hard
- **URL**: https://leetcode.com/problems/best-meeting-point/
- **Tags**: `Matrix`, `Median`, `Sorting`
- **Techniques**: Sorting \@ref(sorting)

### Description

Given a 2D grid of 0s and 1s where each 1 represents a friend’s home, find the meeting point that minimizes the total Manhattan distance from all homes.

### Examples

```
Input: [[1,0,0,0,1],
        [0,0,0,0,0],
        [0,0,1,0,0]]
Output: 6
```

### Constraints

- `1 <= rows, cols <= 200`

### Solution - Median Trick

#### Walkthrough

The Manhattan distance sum is minimized by the median of row coordinates and column coordinates separately. Collect all row indices, all column indices, take medians, then sum absolute differences to these medians.

#### Analysis

- **Time Complexity**: O(m * n)
- **Space Complexity**: O(m + n)

#### Algorithm

1. Traverse the grid, collect row indices (`rows`) and column indices (`cols`) for all homes.
2. Sort lists (or rows inherently non-decreasing if traversed row-by-row).
3. Median row = `rows[rows.size/2]`, same for columns.
4. Sum absolute differences from medians.

#### Java Code

```java
public int minTotalDistance(int[][] grid) {
    List<Integer> rows = new ArrayList<>();
    List<Integer> cols = new ArrayList<>();

    for (int r = 0; r < grid.length; r++) {
        for (int c = 0; c < grid[0].length; c++) {
            if (grid[r][c] == 1) {
                rows.add(r);
            }
        }
    }

    for (int c = 0; c < grid[0].length; c++) {
        for (int r = 0; r < grid.length; r++) {
            if (grid[r][c] == 1) {
                cols.add(c);
            }
        }
    }

    int rowMedian = rows.get(rows.size() / 2);
    int colMedian = cols.get(cols.size() / 2);

    int distance = 0;
    for (int r : rows) {
        distance += Math.abs(r - rowMedian);
    }
    for (int c : cols) {
        distance += Math.abs(c - colMedian);
    }

    return distance;
}
```
