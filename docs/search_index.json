[
["index.html", "Technical Interview Chapter 1 Introduction", " Technical Interview Michael Fong 2022-07-28 Chapter 1 Introduction "],
["problem-template.html", "1.1 Problem Template", " 1.1 Problem Template 1.1.1 Description 1.1.2 Example 1.1.3 Solution 1.1.3.1 Walkthrough 1.1.3.2 Analysis 1.1.3.3 Algorithm 1.1.3.4 Java Code "],
["glossary-of-algorithm.html", "1.2 Glossary of Algorithm", " 1.2 Glossary of Algorithm 1.2.1 Depth First Traversal : An algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node and explores as far as possible along each branch recursively. 1.2.2 Breadth First Traversal} : An algorithm for traversing or searching tree or graph data structures. It starts at the tree root, and explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level. 1.2.3 Topological Sorting : Topological Sorting 1.2.4 Minimax : (sometimes MinMax) is an algorithm for minimizing the possible loss for a worst case (maximum loss) scenario. 1.2.5 Recursion : a method of solving a problem where the solution depends on solutions to smaller instances of the same problem 1.2.6 Backtrack : a method trying to construct a solution to a computational problem incrementally, one small piece at a time. Whenever the algorithm needs to decide between multiple alternatives to the next component of the solution, it recursively evaluates alternative and then chooses the best one. 1.2.7 Dynamic Programming : a method to to simplify a complicated problem by breaking it down into simpler sub-problems in a recursive manner. You have a main problem (the root of your tree of subproblems), and subproblems (subtrees). The subproblems typically repeat and overlap. Common approach is implemented recursively or iteratively table-filling. 1.2.8 Memoization : an optimization technique used to speed up programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. The implementation can be of form recursive call (or some iterative equivalent) 1.2.9 Tabulation : is an approach where you solve a dynamic programming problem by first filling up a table, and then compute the solution to the original problem based on the results in this table. 1.2.10 Divide and Conquer : an algorithm to recursively breaking down a problem into two or more sub-problems of the same or related type, until these become simple enough to be solved directly. The solutions to the sub-problems are then combined to give a solution to the original problem. 1.2.11 Binary Search Tree : a binary tree where nodes are ordered, where the keys in the left subtree are less then the key in its parent node, and the keys in the right subtree are greater the key in its parent node. 1.2.12 Merge sort : a Divide and Conquer algorithm. It divides input array in two halves, calls itself for the two halves and then merges the two sorted halves. 1.2.13 Bubble sort : a sorting algorithm that compares adjacent pairs and swaps them if necessary, causing the items to “bubble” up toward their proper position. 1.2.14 Quick Sort : a Divide and Conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot. 1.2.15 Minimum Heap : a complete binary tree in which the value in each internal node is smaller than or equal to the values in the children of that node. Thus, the root node is the smallest element in the tree. "],
["arrays.html", "Chapter 2 Arrays", " Chapter 2 Arrays If we are enumerating the cartesian products over two arrays of n elements. A = [A_1, A_2, ..., A_n] B = [B_1, B_2, ..., B_n] A1 X A2 = [(A_1, B_1), (A_1, B_2), ..., (A_n, B_n)] The time complexity is O(n^2). for(int i = 0; i &lt; A.length; i++) { for(int j = 0; j &lt; B.length; j++) { // process each (A_i, B_j) } } If we only need to enumerate part of the combination over two arrays while traversing both arrays simultaneously. A = [A_1, A_2, ..., A_n] B = [B_1, B_2, ..., B_n] A1 X A2 = [(A_1, B_1), (A_2, B_1), (A_2, B_2), ..., (A_n, B_n)] we could possibly reduce the complexity to O(n) for(int i = 0, j = 0; i &lt; A.length; j &lt; B.length;) { int a = A[i]; int b = B[j]; if(a &lt; b) { i++; } else if(a &gt; b) { j++; } }\n"],
["two-sums-i-leetcode-1-easy.html", "2.1 Two Sums I / LeetCode 1 / Easy", " 2.1 Two Sums I / LeetCode 1 / Easy 2.1.1 Description Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 2.1.2 Examples Given nums = [2, 7, 11, 15], target = 9. Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 2.1.3 Solution - with HashTable 2.1.3.1 Walkthrough Use a HashMap to store each element and its associated index, that is \\(&lt;\\)nums[i], i\\(&gt;\\). Then check if diff = (target - nums[i]) and return the pair of indices if existed. 2.1.3.2 Analysis Each insertion and get operation from hashmap takes O(1) and there are n elements. The total time complexity costs O(n) and Auxiliary Space takes \\(O(n)\\) 2.1.3.3 Algorithm 2.1.3.3.1 Java Code - with HashTable public int[] twoSum(int[] nums, int target) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); //iterate through the indices for(int i = 0; i &lt; nums.length; i++) { int diff = target - nums[i]; Integer diffIdx = map.get(diff); if(map.containsKey(diff) &amp;&amp; i != diffIdx) { //map contains diff value and its associated index return new int[]{diffIdx, i}; } else { //store the value and index for later use map.put(nums[i], i); } } return null; } 2.1.3.3.2 Java Code - with HashTable 2 Similar as previous answer, but instead store the diff value in hash map. public int[] twoSum(int[] nums, int target) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); //iterate through the indices for(int i = 0; i &lt; nums.length; i++) { int num = nums[i]; Integer diffIdx = map.get(num); if(map.containsKey(num) &amp;&amp; i != diffIdx) { //map contains diff value and its associated index return new int[]{diffIdx, i}; } else { //store the value and index for later use int diff = target - nums[i]; map.put(diff, i); } } return null; } "],
["two-sum-ii-input-array-is-sorted-leetcode-167-medium.html", "2.2 Two Sum II - Input Array Is Sorted / LeetCode 167 / Medium", " 2.2 Two Sum II - Input Array Is Sorted / LeetCode 167 / Medium 2.2.1 Description Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &lt;= index1 &lt; index2 &lt;= numbers.length. Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space. 2.2.2 Examples Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2]. 2.2.3 Solution - Searching Target Sum from Sorted Array 2.2.3.1 Walkthrough This solution is valid only on array. Have two indices pointed to left most and right most position of array. Start comparing the sum against the target. If sum meets, return the indices; otherwise, move indices inward. 2.2.3.2 Analysis Time complexity is O(n) since every element is visited, and Auxiliary Space is O(1) 2.2.3.3 Algorithm 2.2.3.3.1 Java Code - Searching Target Sum from Sorted Array public int[] twoSum(int[] nums, int target) { int left = 0, right = nums.length - 1; while(left &lt; right) { int sum = nums[left] + nums[right]; if(sum == target) { return new int[]{left+1, right+1}; } if(target &gt; sum) { //increase value by shifting rightward left++; } else { //decrease value by shifting leftward right--; } } return null; } "],
["two-sum-ii-return-true-false.html", "2.3 Two Sum II - Return True / False", " 2.3 Two Sum II - Return True / False 2.3.1 Description You are given an array of n integers and a number k. Determine whether there is a pair of elements in the array that sums to exactly k. 2.3.2 Example For example, given the array [1, 3, 7] and k = 8, the answer is “yes,” but given k = 6 the answer is “no.” 2.3.3 Solution 2.3.3.1 Walkthrough Have a HashSet to iterate through the array while compute the difference (target - a[i]). Check if the diff exist. Return true if exists; false otherwise. HashSet essentially uses less space than HashTable. 2.3.3.2 Analysis Each insertion and get operation from hashmap takes O(1) and there are n elements. The total time complexity costs O(n) and Auxiliary Space takes O(n) 2.3.3.3 Algorithm 2.3.3.3.1 Java Code public boolean sumsToTarget(int[] arr, int target) { Set&lt;Integer&gt; values = new HashSet&lt;Integer&gt;(); for (int i = 0; i &lt; arr.length; i++) { int diff = target - arr[i]; //if hash set contains the difference if (values.contains(diff)) { return true; } else { values.add(arr[i]); } } return false; } "],
["two-sum-iv-input-is-a-bst-leetcode-653-easy.html", "2.4 Two Sum IV - Input is a BST / LeetCode 653 / Easy", " 2.4 Two Sum IV - Input is a BST / LeetCode 653 / Easy 2.4.1 Description Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target. 2.4.2 Example Figure 2.1: Some caption. Target = 9, Output = True. 2.4.3 Solution 2.4.3.1 Walkthrough Use a HashSet to store value of current node, that is (node.val). Then check if answer = (target - node.val) and return true if existed; otherwise, recursively call the same function for its left and right children. 2.4.3.2 Analysis Time complexity is O(n) since every node is visited. Auxiliary Space is O(1) 2.4.3.3 Algorithm recursion 1.2.5 2.4.3.3.1 Java Code public boolean findTarget(TreeNode root, int target) { Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); return findTarget(root, target, set); } public boolean findTarget(TreeNode node, int target, Set&lt;Integer&gt; set) { if(node == null) { return false; } else if(set.contains(target - node.val)) { return true; } else { //recursively calling set.add(node.val); return findTarget(node.right, target, set) || findTarget(node.left, target, set); } } "],
["twosum-v.html", "2.5 TwoSum V / /", " 2.5 TwoSum V / / 2.5.1 Description Given a sorted array S of n integers, are there elements a, b in S such that a + b = target? Find all unique pairs in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. 2.5.2 Example For example, given array S = [-2, -1, -1, 0, 1, 2], target = 0 A solution set is: [ [-1, 1], [-2, 2]] 2.5.3 Solution 2.5.3.1 Walkthrough While searching for the other two elements from both ends, with indices left incrementally and right decrmentally, find the sum = nums[left] + nums[right] == target. Since the array is sorted, we need to avoid duplicated entry by moving forward the index while searching. 2.5.3.2 Analysis There are one loops, the time complexity is \\(O(n)\\), and Auxiliary Space is \\(O(n)\\) since one member of any pair is uniquely determined by the other member. If the numbers are not distinct, the Auxiliary Space as large as \\(O(\\binom{n}{2}) = O(\\frac{n!}{2!\\cdot (n-2)!}) = O(\\frac{n\\cdot (n-1)}{2}) = O(n^2)\\) 2.5.3.3 Algorithm 2.5.3.3.1 Java Code public List&lt;List&lt;Integer&gt;&gt; twoSum(int[] num, int target) { List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); int left = 0, right = num.length - 1; while (left &lt; right) { int sum = num[left] + num[right]; if (sum == target) { result.add(Arrays.asList(num[left], num[right])); //avoid duplicated entry by moving forward the index while (left &lt; right &amp;&amp; num[left] == num[left + 1]) { left++; } while (left &lt; right &amp;&amp; num[right] == num[right - 1]) { right--; } left++; right--; } else if (sum &lt; target) { left++; } else { // sum &gt; target right--; } } return result; } "],
["sum-leet-code-15-medium.html", "2.6 3Sum / Leet Code 15 / Medium", " 2.6 3Sum / Leet Code 15 / Medium 2.6.1 Description Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. 2.6.2 Example For example, given array S = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2]] 2.6.3 Solution 2.6.3.1 Walkthrough Looping the array with index i, while searching for the other two elements from both ends, with indices left incrementally and right decrmentally, find the sum = nums[i] + nums[left] + nums[right] == 0. Since the array is sorted, we need to avoid duplicated entry by moving forward the index while searching. 2.6.3.2 Analysis There are two nested loops, the time complexity is \\(O(n^2)\\), and Auxiliary Space is is \\(O(n^2)\\) since one member of any triplet is uniquely determined by the other two members. If the numbers are not distinct, the Auxiliary Space as large as \\(O(\\binom{n}{3}) = O(\\frac{n!}{3!\\cdot (n-3)!}) = O(\\frac{n\\cdot (n-1)\\cdot(n-2)}{3}) = O(n^3)\\) 2.6.3.3 Algorithm 2.6.3.3.1 Java Code public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] num) { Arrays.sort(num); //sort List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); //last possible pair is [i=len - 3, left=len - 2, right=len - 1] for (int i = 0; i &lt; num.length - 2; i++) { // Since the array is sorted, we need to avoid duplicated entry by moving forward the index if (i == 0 || (i &gt; 0 &amp;&amp; num[i] != num[i-1])) { int left = i + 1, right = num.length-1; while (left &lt; right) { int sum = num[i] + num[left] + num[right]; if (sum == 0) { result.add(Arrays.asList(num[i], num[left], num[right])); //avoid duplicated entry by moving forward the index while (left &lt; right &amp;&amp; num[left] == num[left + 1]) { left++; } while (left &lt; right &amp;&amp; num[right] == num[right - 1]) { right--; } left++; right--; } else if (sum &lt; 0) { left++; } else { // sum &gt; 0 right--; } } } } return result; } "],
["sum-closest-leetcode-16-medium.html", "2.7 3 Sum Closest / LeetCode 16 / Medium", " 2.7 3 Sum Closest / LeetCode 16 / Medium 2.7.1 Description Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. 2.7.2 Example For example, given array S = -1 2 1 -4, and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 2.7.3 Solution 2.7.3.1 Walkthrough Looping the array with index i, while searching for the other two elements from both ends, with indices left incrementally and right decrmentally, find the sum = nums[i] + nums[left] + nums[right]. Return sum if existed; otherwise, keep for the closest tuple of (nums[i], nums[left], nums[right]) against target using Math.abs(). 2.7.3.2 Analysis There are two nested loops, the time complexity is \\(O(n^2)\\), and Auxiliary Space is O(1) since it is returning the closest answer. 2.7.3.3 Algorithm 2.7.3.3.1 Java Code public int threeSumClosest(int[] nums, int target) { Arrays.sort(num); //sort int minDelta = Integer.MAX_VALUE, result = 0; //last possible pair is [i=len - 3, left=len - 2, right=len - 1] for (int i = 0; i &lt; num.length - 2; i++) { int left = i + 1, right = num.length - 1; while (left &lt; right) { int sum = num[i] + num[left] + num[right]; if (sum == target) { //find exact match return sum; } else if (sum &lt; target) { left++; } else { // sum &gt; target right--; } int delta = Math.abs(sum - target); if(delta &lt; minDelta) { minDelta = delta; result = sum; } } } return result; } "],
["sum-leet-code-18-medium.html", "2.8 4Sum / Leet Code 18 / Medium", " 2.8 4Sum / Leet Code 18 / Medium 2.8.1 Description Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. The solution set must not contain duplicate quadruplets. 2.8.2 Example Given array nums = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 2.8.3 Solution 2.8.3.1 Walkthrough The solution is similar to 3Sum to find the sum = nums[i] + nums[j] + nums[left] + nums[right] == target. The only difference is there is an extra loop as well as we need to avoid duplicated entry by moving forward the index during search. 2.8.3.2 Analysis Overall, there are three nested loops, the time complexity is \\(O(n^3)\\), and Auxiliary Space is \\(O(n^3)\\) since one member of any quotriplet is uniquely determined by the other three member. If the numbers are not distinct, the Auxiliary Space as large as is \\(O(\\binom{n}{4}) = O(n^4)\\) 2.8.3.3 Algorithm 2.8.3.4 Java Code public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] num, int target) { Arrays.sort(num); //sort List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); //last possible pair is [j=len - 4, i=len-3, left=len - 2, right=len - 1] for (int j = 0; i &lt; num.length - 3; i++) { // Since the array is sorted, we need to avoid duplicated entry by moving forward the index if (j == 0 || (j &gt; 0 &amp;&amp; num[j] != num[j - 1])) { for (int i = j + 1; i &lt; num.length - 2; i++) { // Since the array is sorted, we need to avoid duplicated entry by moving forward the index if (i == j + 1 || (i &gt; 0 &amp;&amp; num[i] != num[i - 1])) { int left = i + 1, right = num.length-1; while (left &lt; right) { int sum = num[i] + num[j] + num[left] + num[right]; if (sum == target) { res.add(Arrays.asList(num[i], num[j], num[left], num[right])); //avoid duplicated entry by moving forward the index while (left &lt; right &amp;&amp; num[left] == num[left + 1]) { left++; } while (left &lt; right &amp;&amp; num[right] == num[right - 1]) { right--; } left++; right--; } else if (sum &lt; target) { left++; } else { // sum &gt; 0 right--; } } } } } } return res; } "],
["sum-ii.html", "2.9 4Sum II", " 2.9 4Sum II 2.9.1 Description Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero. To make problem a bit easier, all A, B, C, D have same length of N where \\(0 &lt;= N &lt;= 500\\). All integers are in the range of \\(-2^{28}\\) to \\(2^{28} - 1\\) and the result is guaranteed to be at most \\(2^{31} - 1\\). 2.9.2 Example Input: A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2] Output: 2 Explanation: The two tuples are: 1. (0, 0, 0, 1) \\(-&gt;\\) A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) \\(-&gt;\\) A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 2.9.3 Solution 2.9.3.1 Walkthrough *Rewrite the equation as A[i] + B[j] = -(C[k] + D[l]). Create a Map&lt;Integer, Integer&gt; where ‘key’ is A[i] + B[j] and ‘value’ is the number of pairs with this sum. For each -(C[k] + D[l]), see if this desired sum is in our map. If so, add the map’s ‘value’ to our total count. 2.9.3.2 Analysis There are two nested loops, the time complexity is \\(O(n^2)\\), and Auxiliary Space for Map is O(n) 2.9.3.3 Algorithm 2.9.3.4 Java Code public int fourSumCount(int[] A, int[] B, int[] C, int[] D) { int n = A.length; if(n == 0) { return 0; } int[] sumOfAandB = new int[n * n]; int result = 0; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; n; j++){ sumOfAandB[i*n + j] = A[i] + B[j]; //record # of pairs for this sum of [A, B] int count = map.getOrDefault(sumOfAandB[i*n + j], 0) + 1; map.put(sumOfAandB[i*n + j], count); } } //A + B = - (C + D) for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; n; j++){ int sumOfCandD = - (C[i] + D[j]); if(map.containsKey(sumOfCandD)){ result += map.get(sumOfCandD); } } } return result; } "],
["max-gain-firecode-level-2.html", "2.10 Max Gain / Firecode / Level 2", " 2.10 Max Gain / Firecode / Level 2 2.10.1 Description Given an array of integers, write a method - maxGain - that returns the maximum gain. Maximum Gain is defined as the maximum difference between 2 elements in a list such that the larger element appears after the smaller element. If no gain is possible, return 0. 2.10.2 Example [0,50,10,100,30] returns 100 [100,40,20,10] returns 0 [0,100,0,100,0,100] returns 100 2.10.3 Solution 2.10.3.1 Walkthrough By definition, , we could do this in one pass by finding the minimum element and the maximum gain (so far) by Math.max(min, a[i] - min) 2.10.3.2 Analysis The time complexity is O(n) since every element is visited in the loop. 2.10.3.3 Algorithm 2.10.3.4 Java Code public static int maxGain(int[] a) { int min = Integer.MAX_VALUE, gain = 0; for(int i = 0; i &lt; a.length; i++) { min = Math.min(min, a[i]); gain = Math.max(gain, a[i] - min); } return gain; } "],
["pascals-triangle-leet-code-118-easy.html", "2.11 Pascal’s Triangle / Leet Code 118 / Easy}", " 2.11 Pascal’s Triangle / Leet Code 118 / Easy} 2.11.1 Description Given a non-negative integer numRows, generate the first numRows of Pascal’s triangle. In Pascal’s triangle, each number is the sum of the two numbers directly above it. 2.11.2 Example 2.11.3 Solution 2.11.3.1 Walkthrough For level 1 and level 2, add number 1. For level 3 or above if it is the first or last element, insert 1, otherwise, insert the sum of last two elements in the level above : [i-1][j] + [i-1][j-1]. 2.11.3.2 Analysis There are two nested loops, the time complexity is \\(O(n^2)\\)$, and Auxiliary Space is \\(O(n^2)\\). 2.11.3.3 Algorithm 2.11.3.4 Java Code public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) { List&lt;List&lt;Integer&gt;&gt; triangle = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; numRows; i++) { List&lt;Integer&gt; level = new ArrayList&lt;&gt;(); for(int j = 0; j &lt; (i+1); j++) { if(i == 0 || i == 1) { // for level 1 or level 2 level.add(1); } else { // for level 3 or above if(j == 0 || j == i) { level.add(1); } else { int op1 = triangle.get(i-1).get(j-1); int op2 = triangle.get(i-1).get(j); level.add(op1 + op2); } } } triangle.add(level); } return triangle; } "],
["search-in-rotated-sorted-array-leet-code-33-medium.html", "2.12 Search in Rotated Sorted Array / Leet Code 33 / Medium", " 2.12 Search in Rotated Sorted Array / Leet Code 33 / Medium 2.12.1 Description Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of O(log n). 2.12.2 Example Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4 Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1 2.12.3 Solution 2.12.3.1 Walkthrough The key point is to search the element in a divide-and-conquer manner. We need to repeated compare the mid element of index = (left + right) / 2 with target and keep shrinking the boundaries from left and right two ends according to the conditions. Return the mid index if found; otherwise, return -1. 2.12.3.2 Analysis The time complexity is O(log n) since we only pick one from half of target elements each time. 2.12.3.3 Algorithm dnc 1.2.10 2.12.3.4 Java Code public int search(int[] nums, int target) { int left = 0, right = nums.length - 1; while(left &lt;= right) { int mid = (right - left) / 2 + left; if(nums[mid] == target) { //Found index return mid; } else if(nums[mid] &gt;= nums[left]) { //left half of array if(target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) { //&lt;-- moving leftward right = mid -1; } else { //--&gt; moving rightward left = mid + 1; } } else { //nums[mid] &lt; nums[right //right half of array if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) { //--&gt; moving rightward left = mid + 1; } else { //&lt;-- moving leftward right = mid - 1; } } } return -1; } "],
["median-of-two-sorted-arrays-leet-code-4-hard.html", "2.13 Median of Two Sorted Arrays / Leet Code 4 / Hard", " 2.13 Median of Two Sorted Arrays / Leet Code 4 / Hard 2.13.1 Description There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. 2.13.2 Example nums1 = [1, 3], nums2 = [2], The median is 2.0 nums1 = [1, 2], nums2 = [3, 4], The median is (2 + 3)/2 = 2.5 2.13.3 Solution 2.13.3.1 Walkthrough Recursively find \\(K^{th}\\) element in two sorted array by comparing and discarding the \\(\\frac{k}{2}\\) smaller elements. 2.13.3.2 Analysis For each round of recursive, it is eliminating \\(\\frac{k}{2}\\) element, so total time complexity is \\(O(log(k)) = O(log(m + n))\\). Auxiliary Space is O(1). 2.13.3.3 Algorithm recursion 1.2.5 2.13.3.4 Java Code public double findMedianSortedArrays(int[] nums1, int[] nums2) { int len1 = nums1.length; int len2 = nums2.length; int total = len1 + len2; if ((total &amp; 1) != 0) { // odd number length return findKth(nums1, 0, len1 - 1, nums2, 0, len2 - 1, total / 2 + 1); } else { // even number length return (findKth(nums1, 0, len1 - 1, nums2, 0, len2 - 1, total / 2) + findKth(nums1, 0, len1 - 1, nums2, 0, len2 - 1, total / 2 + 1)) * 0.5; } } private int findKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k){ int len1 = end1 - start1 + 1; int len2 = end2 - start2 + 1; /* * swap parameters for nums1 with nums2 */ if (len1 &gt; len2) { return findKth(nums2, start2, end2, nums1, start1, end1, k); } if (len1 == 0) { return nums2[start2 + k - 1]; } if (k == 1) { //return the smaller element of nums1[] and nums2[] return Math.min(nums1[start1], nums2[start2]); } //Calculate number of elements to discard for next recursive int endToDiscard1 = start1 + Math.min(len1, k / 2) - 1; int endToDiscard2 = start2 + Math.min(len2, k / 2) - 1; if (nums1[endToDiscard1] &gt; nums2[endToDiscard2]) { //if nums2[] are smaller, discard, and start from following position recursively int newK = k - (endToDiscard2 - start2 + 1); return findKth(nums1, start1, end1, nums2, endToDiscard2 + 1, end2, newK); } else { //if nums1[] are smaller, discard, and start from following position recursively int newK = k - (endToDiscard1 - start1 + 1); return findKth(nums1, endToDiscard1 + 1, end1, nums2, start2, end2, newK); } } "],
["retrieve-list-of-elements-appeared-at-kth-time-and-in-insertion-order.html", "2.14 Retrieve List of Elements Appeared at \\(k^{th}\\) Time and in Insertion Order / /}", " 2.14 Retrieve List of Elements Appeared at \\(k^{th}\\) Time and in Insertion Order / /} 2.14.1 Description Given an unsorted, possibly duplicated elments of array, return the list of element which appeared at kth time where k \\(&gt;=\\) 1. The returned elements need to be stable as they were in insertion order. 2.14.2 Example \\([1_1, 2_1, 3_1, 4_1, 2_2, 1_2, 1_3, 3_2], k = 1. =&gt; [1_1, 2_1, 3_1, 4_1]\\) \\([1_1, 2_1, 3_1, 4_1, 2_2, 1_2, 1_3, 3_2], k = 2. =&gt; [2_2, 1_2, 3_2]\\) \\([1_1, 2_1, 3_1, 4_1, 2_2, 1_2, 1_3, 3_2], k = 3. =&gt; [1_3]\\) 2.14.3 Solution 2.14.3.1 Walkthrough Have a map to record the integer and occurrence. Only save to the list when latest occurrence equals to k, so that we could maintain insertion order. 2.14.3.2 Analysis Time complexity is O(n) since every element is visited, and Auxiliary Space is O(n). 2.14.3.3 Algorithm 2.14.3.4 Java Code List&lt;Integer&gt; insertToKthElement(int[] array, int k) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if(array == null || array.length == 0) { return result; } Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int num : array) { int count = map.getOrDefault(num, 0); map.put(num, ++count); //latest occurrences equal to k if( count == k) { result.add(num); } } return result; } "],
["permutations-leetcode-46-medium.html", "2.15 Permutations / LeetCode 46 / Medium", " 2.15 Permutations / LeetCode 46 / Medium 2.15.1 Description Given a collection of distinct integers, return all possible permutations. 2.15.2 Example Input: [1,2,3] Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 2.15.3 Solution - Backtrack with Memoization 2.15.3.1 Walkthrough One way to enumerate all permuations is to recursively add elements into list (avoid adding duplicates) and removing the last element form the last. In order to save time to process the same element, we further save flag for each element to denote that if the element has been visited or not. 2.15.3.2 Analysis Time complexity with memoization to skip some subproblems is \\((n + n\\cdot (n - 1) + n\\cdot (n - 1)\\cdot (n - 2) + ... + n\\cdot (n - 1)\\cdot (n - 2)\\cdot ...\\cdot 1) \\cdot n \\Rightarrow O(n!)\\) 2.15.3.3 Algorithm backtrack 1.2.6, memoization 1.2.8 2.15.3.4 Java Code - Backtrack with Memoization List&lt;List&lt;Integer&gt;&gt; result= new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) { boolean[] visited = new boolean[nums.length]; Arrays.sort(nums); backtrack(new ArrayList&lt;&gt;(), nums, visited); return result; } private void backtrack(List&lt;Integer&gt; list, int [] nums, boolean[] visited){ if(list.size() == nums.length){ //copy elements from the current list result.add(new ArrayList&lt;&gt;(list)); return; } for(int i = 0; i &lt; nums.length; i++){ Integer element = nums[i]; if(visited[i]) { continue; } //add a new element list.add(element); visited[i] = true; backtrack(list, nums, visited); //backtrack the last element list.remove(list.size()-1); visited[i] = false; } } "],
["permutations-ii-leetcode-47-medium.html", "2.16 Permutations II / LeetCode 47 / Medium", " 2.16 Permutations II / LeetCode 47 / Medium 2.16.1 Description Given a collection of numbers that might contain duplicates, return all possible unique permutations. 2.16.2 Example Input: [1,1,2] Output: [ [1,1,2], [1,2,1], [2,1,1] ] 2.16.3 Solution - Backtrack with Memoization 2.16.3.1 Walkthrough While we enumerate all possible enumerate with recursive nature, we need to maintain a visited flag for each element to ensure that same element (or same value) would not be processed again. Thus, we could define the following skipping conditions: The current[i] element has been visited. The current[i] element is the same (value) as the previously[i-1] visited element. 2.16.3.2 Analysis Time complexity \\(O(n!)\\) with memoization to skip some subproblems. 2.16.3.3 Algorithm backtrack 1.2.6, memoization 1.2.8 2.16.3.4 Java Code - Backtrack with Memoization List&lt;List&lt;Integer&gt;&gt; result= new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { boolean visited[] = new boolean[nums.length]; //Sort the array Arrays.sort(nums); backtrack(new ArrayList&lt;&gt;(), nums, visited); return result; } private void backtrack(List&lt;Integer&gt; list, int [] nums, boolean[] visited){ if(list.size() == nums.length){ //copy elements from the current list result.add(new ArrayList&lt;&gt;(list)); return; } for(int i = 0; i &lt; nums.length; i++){ if(visited[i] == true || (i &gt; 0 &amp;&amp; visited[i-1] == false &amp;&amp; nums[i] == nums[i-1])) { /* * Skip the permutation if any of the condition satisifies: * 1) The current[i] element has been visited. * 2) The current[i] element is the same (value) as the previously[i-1] visited element. */ continue; } Integer element = nums[i]; //add a new element list.add(element); visited[i] = true; backtrack(list, nums, visited); //backtrack the last element list.remove(list.size()-1); visited[i] = false; } } "],
["subsets-leetcode-78-medium.html", "2.17 Subsets / LeetCode 78 / Medium", " 2.17 Subsets / LeetCode 78 / Medium 2.17.1 Description Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. 2.17.2 Example Input: nums = [1,2,3], Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 2.17.3 Solution 2.17.3.1 Walkthrough The enumeration tree is as the following: Figure 2.2: Some caption. Enumerate all possible result by adding a new element that is greater than current element while traversing the array. Remember to backtrack. 2.17.3.2 Analysis Time complexity between \\(O(2^{n})\\) as there are at most \\(2^n\\) subsets. 2.17.3.3 Algorithm backtrack 1.2.6, recursion 1.2.5 2.17.3.4 Java Code List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { if (nums.length == 0) { return result; } Arrays.sort(nums); backtrack(nums, 0, new ArrayList&lt;&gt;()); return result; } private void backtrack(int[] nums, int index, List&lt;Integer&gt; list) { //copy elements from the current list result.add(new ArrayList&lt;&gt;(list)); for(int i = index; i &lt; nums.length; i++) { list.add(nums[i]); backtrack(nums, i + 1, list); //remove last element to backtrack list.remove(list.size() - 1); } } "],
["subsets-ii-leetcode-90-medium.html", "2.18 Subsets II / LeetCode 90 / Medium", " 2.18 Subsets II / LeetCode 90 / Medium 2.18.1 Description Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. 2.18.2 Example Input: nums = [1,2,2], Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] 2.18.3 Solution 2.18.3.1 Walkthrough The enumeration tree is as the following: Figure 2.3: Some caption. Enumerate all possible result by adding a new element that is greater than current element while traversing the array. Skip if two consecutive elements are the same. Remember to backtrack. 2.18.3.2 Analysis Time complexity between \\(O(2^{n})\\) as there are at most \\(2^n\\) subsets. 2.18.3.3 Algorithm backtrack 1.2.6, recursion 1.2.5 2.18.3.4 Java Code List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) { if (nums.length == 0) { return result; } Arrays.sort(nums); backtrack(nums, 0, new ArrayList&lt;&gt;()); return result; } private void backtrack(int[] nums, int index, List&lt;Integer&gt; list) { //copy elements from the current list result.add(new ArrayList&lt;&gt;(list)); for(int i = index; i &lt; nums.length; i++) { if(i != index &amp;&amp; nums[i] == nums[i - 1]) { continue; } list.add(nums[i]); backtrack(nums, i + 1, list); //remove last element to backtrack list.remove(list.size() - 1); } } "],
["sort-array-by-parity-leetcode-906-easy.html", "2.19 Sort Array By Parity / LeetCode 906 / Easy", " 2.19 Sort Array By Parity / LeetCode 906 / Easy 2.19.1 Description Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A. You may return any answer array that satisfies this condition. 2.19.2 Example Input: [3,1,2,4]. Output: [2,4,3,1]. The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. 2.19.3 Solution 2.19.3.1 Walkthrough Have two indices, left and right. Shrink both indices (left, right) where they satisfy the condition. Swap those who do not and shrink both indices again. 2.19.3.2 Analysis Complexity is \\(O(n)\\) since each element is visited once. 2.19.3.3 Algorithm 2.19.3.4 Java Code public int[] sortArrayByParity(int[] A) { if(A == null || A.length == 0) { return null; } int l = 0, r = A.length - 1; while(l &lt; r) { while (A[l]%2 == 0 &amp;&amp; l &lt; r) { //do nothing, incremnt left index l++; } while (A[r]%2 == 1 &amp;&amp; l &lt; r) { //do nothing, decrement right index r--; } if( l &lt; r ) { //odd #, swap int temp = A[l]; A[l] = A[r]; A[r] = temp; l++; r--; } } return A; } "],
["merge-intervals-leetcode-56-medium.html", "2.20 Merge Intervals / LeetCode 56 / Medium", " 2.20 Merge Intervals / LeetCode 56 / Medium 2.20.1 Description Given a collection of intervals, merge all overlapping intervals. 2.20.2 Example Input: [[1,3],[2,6],[8,10],[15,18]]. Output: [[1,6],[8,10],[15,18]]. Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Input: [[1,4],[4,5]]. Output: [[1,5]]. Explanation: Intervals [1,4] and [4,5] are considered overlapping. 2.20.3 Solution 2.20.3.1 Walkthrough Sort the list of intervals first. Use a stack to track the lastly pushed interval. If the current interval does not overlap with the top interval, push current interval to stack. If there is an overlap, we merge the current and previous interval. 2.20.3.2 Analysis Complexity is : \\(O(n \\cdot log n)\\) since we sort the array first. 2.20.3.3 Algorithm 2.20.3.4 Java Code static class Interval { int start; int end; public Interval(int l, int r) { start = l; end = r; } } public int[][] merge(int[][] intervals) { List&lt;Interval&gt; input = new ArrayList&lt;&gt;(); for(int[] interval : intervals) { input.add(new Interval(interval[0], interval[1])); } if(intervals.length == 0) { return new int[0][0]; } List&lt;Interval&gt; output = merge(input); int[][] result = new int[output.size()][2]; for(int i = 0; i &lt; output.size(); i++) { result[i][0] = output.get(i).start; result[i][1] = output.get(i).end; } return result; } private class IntervalComparator implements Comparator&lt;Interval&gt; { @Override public int compare(Interval a, Interval b) { return a.start - b.start; } } public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) { //sort the list Collections.sort(intervals, new IntervalComparator()); Stack&lt;Interval&gt; merged = new Stack&lt;Interval&gt;(); merged.push(intervals.get(0)); for (int i = 1; i &lt; intervals.size(); i++) { Interval interval = intervals.get(i); Interval top = merged.peek(); // if interval does not overlap with the previous, simply append it. if (top.end &lt; interval.start) { merged.push(interval); } // if there is an overlap, we merge the current with the last interval // by comparing their end boundaries else { top.end = Math.max(top.end, interval.end); } } return merged; } "],
["non-overlapping-intervals-leetcode-435-medium.html", "2.21 Non-overlapping Intervals / LeetCode 435 / Medium", " 2.21 Non-overlapping Intervals / LeetCode 435 / Medium 2.21.1 Description Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. 2.21.2 Example Input: [[1,2],[2,3],[3,4],[1,3]]. Output: 1 Explanation: [1,3] can be removed and the rest of intervals are non-overlapping. Input: [[1,2],[1,2],[1,2]]. Output: 2 . Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping. 2.21.3 Solution 2.21.3.1 Walkthrough First, sort the array and count non-overlapping interval - not overlapped with previous end. Finally, number of overlapping intervals would be n - count. 2.21.3.2 Analysis Complexity is \\(O(n \\cdot log n)\\) because of sorting ahead. 2.21.3.3 Algorithm 2.21.3.4 Java Code public int eraseOverlapIntervals(int[][] intervals) { if(intervals == null || intervals.length == 0) { return 0; } Arrays.sort(intervals, new Comparator&lt;int[]&gt;() { @Override public int compare(int[] i1, int[] i2) { if (i1[1] != i2[1]){ //compare end time return i1[1] - i2[1]; }else { //compare start time return i1[0] - i2[0]; } } }); //end for latest non-overlapped interval int end = intervals[0][1]; int n = intervals.length; int count = 1; for (int i = 1; i &lt; n; i++) { if (intervals[i][0] &gt;= end) { //for any non-overlapped interval, update end &amp; count end = intervals[i][1]; count++; } } return n - count; } "],
["interval-list-intersections-leetcode-986-medium.html", "2.22 Interval List Intersections / LeetCode 986 / Medium", " 2.22 Interval List Intersections / LeetCode 986 / Medium 2.22.1 Description Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists. 2.22.2 Example Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]] Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]] Reminder: The inputs and the desired output are lists of Interval objects, and not arrays or lists. 2.22.3 Solution 2.22.3.1 Walkthrough Traverse the two lists of intervals. Merge two intervals if there is an intersection. Move the index of A if \\(A[i]\\).end \\(&lt; B[i]\\).end since the interval is the smaller out of comparison. 2.22.3.2 Analysis The runtime complexity is \\(O(n * m)\\) 2.22.3.3 Algorithm 2.22.3.4 Java Code LeetCode 986 / Medium private static class Interval { public int start; public int end; public Interval(int s, int e) { this.start = s; this.end = e; } public static int[][] toArray(List&lt;Interval&gt; list) { int[][] result = new int[list.size()][2]; for(int i = 0; i &lt; list.size(); i++) { Interval interval = list.get(i); result[i] = new int[] {interval.start, interval.end}; } return result; } public static List&lt;Interval&gt; toList(int[][] array) { List&lt;Interval&gt; result = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; array.length; i++) { Interval interval = new Interval(array[i][0], array[i][1]); result.add(interval); } return result; } } public int[][] intervalIntersection(int[][] A, int[][] B) { List&lt;Interval&gt; intervalsA = Interval.toList(A); List&lt;Interval&gt; intervalsB = Interval.toList(B); List&lt;Interval&gt; result = new ArrayList&lt;&gt;(); int i = 0, j = 0; while( i &lt; intervalsA.size() &amp;&amp; j &lt; intervalsB.size()) { int highStart = Math.max(intervalsA.get(i).start, intervalsB.get(j).start); int lowEnd = Math.min(intervalsA.get(i).end, intervalsB.get(j).end); //there is an intersection if( highStart &lt;= lowEnd) { result.add( new Interval(highStart, lowEnd)); } if( intervalsA.get(i).end &lt; intervalsB.get(j).end) { //move index of A[] i++; } else { //move index of B[] j++; } } return Interval.toArray(result); } "],
["insert-interval-leetcode-57-hard.html", "2.23 Insert Interval / LeetCode 57 / Hard", " 2.23 Insert Interval / LeetCode 57 / Hard 2.23.1 Description Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. 2.23.2 Example Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]. Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. 2.23.3 Solution 2.23.3.1 Walkthrough Leverage the merge() method to find out which intervals can be merged with new Inserted interval. 2.23.3.2 Analysis Time complexity is \\(O(n \\cdot log(n))\\) because of sorting ahead. 2.23.3.3 Algorithm 2.23.3.4 Java Code private static class Interval { public int start; public int end; public Interval(int s, int e) { this.start = s; this.end = e; } public static int[][] toArray(List&lt;Interval&gt; list) { int[][] result = new int[list.size()][2]; for(int i = 0; i &lt; list.size(); i++) { Interval interval = list.get(i); result[i] = new int[] {interval.start, interval.end}; } return result; } public static List&lt;Interval&gt; toList(int[][] array) { List&lt;Interval&gt; result = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; array.length; i++) { Interval interval = new Interval(array[i][0], array[i][1]); result.add(interval); } return result; } } public int[][] insert(int[][] existed, int[] target) { List&lt;Interval&gt; intervals = Interval.toList(existed); Interval newInterval = new Interval(target[0], target[1]); intervals.add(newInterval); List&lt;Interval&gt; merged = merge(intervals); return Interval.toArray(merged); } private class IntervalComparator implements Comparator&lt;Interval&gt; { @Override public int compare(Interval a, Interval b) { return a.start &lt; b.start ? -1 : a.start == b.start ? 0 : 1; } } public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) { //sort the list Collections.sort(intervals, new IntervalComparator()); LinkedList&lt;Interval&gt; merged = new LinkedList&lt;Interval&gt;(); for (Interval interval : intervals) { if (merged.isEmpty() || merged.getLast().end &lt; interval.start) { // if the list of merged intervals is empty or if the current // interval does not overlap with the previous, simply append it. merged.add(interval); } else { // otherwise, there is overlap, so we merge the current and previous // intervals. merged.getLast().end = Math.max(merged.getLast().end, interval.end); } } return merged; } "],
["find-common-characters-leetcode-1002-easy.html", "2.24 Find Common Characters / LeetCode 1002 / Easy", " 2.24 Find Common Characters / LeetCode 1002 / Easy 2.24.1 Description Given an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates). For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer. You may return the answer in any order. 2.24.2 Example Input: [“bella”,“label”,“roller”]. Output: [“e”,“l”,“l”] Input: [“cool”,“lock”,“cook”]. Output: [“c”,“o”] 2.24.3 Solution 2.24.3.1 Walkthrough First retrieve the alphabet distribution for the first word. For each of following word, maintain the min number of duplicated alphabets. Lastly, take the alphabet which has more than 1 occurrences. 2.24.3.2 Analysis Time complexity is O(n) where n is the number of words. 2.24.3.3 Algorithm 2.24.3.4 Java Code public List&lt;String&gt; commonChars(String[] A) { int[] minFreq = new int[26]; //init frequency map with the first string for(int i = 0; i &lt; A[0].length(); i++) { char c = A[0].charAt(i); int index = c - &#39;a&#39;; int counter = minFreq[index]; minFreq[index] = ++counter; } //Do the actions for the following words for(int i = 1; i &lt; A.length; i++) { String str = A[i]; int[] tempFreq = new int[26]; //1. Store the frequency of alphabets for(int j = 0; j &lt; str.length(); j++) { char c = str.charAt(j); int index = c - &#39;a&#39;; int counter = tempFreq[index]; tempFreq[index] = ++counter; } //2. Iterate thru 2 arrays and get the min number of (duplicated) alphabets // non-duplicated returns 0 for(int j = 0; j &lt; 26; j++) { minFreq[j] = Math.min(minFreq[j], tempFreq[j]); } } int numOfWords = A.length; List&lt;String&gt; result = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; 26; i++) { int minCounter = minFreq[i]; //Take the min number of duplicated alphabets (1 min) for(int j = 0; j &lt; minCounter; j++) { char alphabet = (char) (&#39;a&#39; + i); result.add(String.valueOf(alphabet)); } } return result; } "],
["top-k-frequently-appeared-elements-leet-code-347-medium.html", "2.25 Top K Frequently Appeared Elements / Leet Code 347 / Medium", " 2.25 Top K Frequently Appeared Elements / Leet Code 347 / Medium 2.25.1 Description Given a non-empty array of integers, return the k most frequent elements. You may assume k is always valid, $ 1 &lt;= k &lt;= $ number of unique elements. Your algorithm’s time complexity must be better than O(\\(n log n\\)), where n is the array’s size. 2.25.2 Example Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] 2.25.3 Solution 2.25.3.1 Walkthrough We first gather the frequency of integer by count with a HashMap We sort the frequency map by comparing by value() in descending order and sort them in \\(List&lt;Entry&lt;Number, Frequency&gt;&gt;\\). We could traverse the top K entries from the list in a loop. 2.25.3.2 Analysis Since we sort the frequency map, thus the time complexity is \\(O(n \\cdot log n)\\), and Auxiliary Space is \\(O(n)\\) to store several maps and list. 2.25.3.3 Algorithm 2.25.3.4 Java Code public List&lt;Integer&gt; topKFrequent(int[] nums, int k) { Map&lt;Integer, Integer&gt; freq = new HashMap&lt;&gt;(); for (int num : nums) { int count = freq.getOrDefault(num, 0); freq.put(num, ++count); } //Sort Map.Entry by comparing by value() in descending order List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; sortedList = new ArrayList&lt;&gt;(freq.entrySet()); sortedList.sort(Map.Entry.comparingByValue(Comparator.reverseOrder())); List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int topN = 0; for (Map.Entry&lt;Integer, Integer&gt; entry : sortedList) { //Top K elements retrieved if(topN == k) { break; } result.add(entry.getKey()); topN++; } return result; } "],
["count-iterations-towards-filling-1s-in-an-array.html", "2.26 Count iterations towards filling 1’s in an array / / }", " 2.26 Count iterations towards filling 1’s in an array / / } 2.26.1 Description Given an array of 0s and 1s, in how many iterations the whole array can be filled with 1s if in a single iteration immediate neighbors of 1s can be filled. If we cannot fill array with 1s, then print “-1” 2.26.2 Example Input : arr[] = {1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1} Output : 1 Input : arr[] = {0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1} Output : 2 2.26.3 Solution 2.26.3.1 Walkthrough For each sub-block of the array, consider the following 3 scenarios Case 1: There are no 1’s. In this case, array cannot be filled with 1’s. Thus, return -1; Locate the first 1 and evalute the following Case 2: [1, 0, 0, …., 0, 1] Another 1 follows and makes it a block of 0s with 1s on both ends. Number of iteration needed to flip the 0s become \\(num_zeo / 2\\) if number is even otherwise \\((num_zero + 1) / 2\\) Case 3: [1, 0, 0, …, 0] Another 1 cannot be found and makes it a single 1 at the end. Number of iteration needed equals to the number of 0s. Case 3: [0, 0, 0, …, 1] Count the number of 0s until the first 1 is met. Finally, we need to get the maximum iteration for each subproblems. 2.26.3.2 Analysis Time Complexity : O(n) since every element is visited once. 2.26.3.3 Algorithm 2.26.3.4 Java Code int countIterations(int arr[]) { boolean oneFound = false; int maxIteration = 0; int n = arr.length; int i = 0; // Start traversing the array while ( i &lt; n ) { if (arr[i] == 1) { oneFound = true; } // Traverse and skip 1s until a 0 is met while (i &lt; n &amp;&amp; arr[i]==1) { i++; } // Count initial contiguous 0s until a 1 is met int inialCountZero = 0; while ( i &lt; n &amp;&amp; arr[i]==0) { inialCountZero++; i++; } // Condition for Case 1 if (oneFound == false &amp;&amp; i == n) { return -1; } // Condition to check if Case 2 satisfies: int countIteration; if (i &lt; n &amp;&amp; oneFound == true) { // If inialCountZero is even if ((inialCountZero &amp; 1) == 0) { countIteration = inialCountZero / 2; } else { //odd countIteration = (inialCountZero + 1) / 2; } inialCountZero = 0; } else { // Case 3 countIteration = inialCountZero; inialCountZero = 0; } maxIteration = Math.max(maxIteration, countIteration); //totalIteration += countIteration } return maxIteration; } "],
["maximum-subarray-leet-code-53-easy.html", "2.27 Maximum Subarray / Leet Code 53 / Easy", " 2.27 Maximum Subarray / Leet Code 53 / Easy 2.27.1 Description Find the contiguous subarray within an array (containing at least one number) which has the largest sum. 2.27.2 Example For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6. 2.27.3 Solution 2.27.3.1 Walkthrough While traversing the array dp[i], add the current element dp[i] with the previous element dp[i] if and only if previous element \\(dp[i-1] &gt; 0\\). In the meantime, compute the max value out of current element dp[i]. 2.27.3.2 Analysis Time complexity is O(n) as every element is visited once. 2.27.3.3 Algorithm dp 1.2.7 2.27.3.4 Java Code public int maxSubArray(int[] nums) { if(nums.length == 0) { return 0; } int[] dp = new int[nums.length]; int max = Integer.MIN_VALUE; //init dp[] for(int i = 0; i &lt; nums.length; i++) { dp[i] = nums[i]; } for(int i = 0; i &lt; nums.length; i++) { //keep summing up with positive integer until a max is found if(i &gt; 0 &amp;&amp; dp[i-1] &gt; 0) { dp[i] += dp[i - 1]; } max = Math.max(dp[i], max); } return max; } "],
["maximum-product-subarray-leet-code-152-medium.html", "2.28 Maximum Product Subarray / Leet Code 152 / Medium", " 2.28 Maximum Product Subarray / Leet Code 152 / Medium 2.28.1 Description Find the contiguous subarray within an array (containing at least one number) which has the largest product. 2.28.2 Example For example, given the array [2,3,-2,4], the contiguous subarray [2,3] has the largest product = 6. 2.28.3 Solution 2.28.3.1 Walkthrough Need to keep track the not only maximum but also minimum product since there could be negative number in array. 2.28.3.2 Analysis Time complexity is O(n) as every element is visited once. 2.28.3.3 Algorithm dp 1.2.7 2.28.3.4 Java Code public int maxProduct(int[] nums) { if(nums.length == 0) { return 0; } int maxProduct = nums[0]; int maxPrev = nums[0], minPrev = nums[0]; int maxCurrent, minCurrent; for(int i = 1; i &lt; nums.length; i++) { maxCurrent = Math.max(Math.max(maxPrev * nums[i], minPrev * nums[i]), nums[i]); minCurrent = Math.min(Math.min(maxPrev * nums[i], minPrev * nums[i]), nums[i]); //refresh max maxProduct = Math.max(maxProduct, maxCurrent); //refresh values maxPrev = maxCurrent; minPrev = minCurrent; } return maxProduct; } "],
["longest-valid-parentheses-leet-code-32-hard.html", "2.29 Longest Valid Parentheses / Leet Code 32 / Hard", " 2.29 Longest Valid Parentheses / Leet Code 32 / Hard 2.29.1 Description Given a string containing just the characters ’(’ and ’)’, find the length of the longest valid (well-formed) parentheses substring. 2.29.2 Example For ”(()”, the longest valid parentheses substring is ”()”, which has length = 2. Another example is ”)()())”, where the longest valid parentheses substring is ”()()”, which has length = 4. 2.29.3 Solution 2.29.3.1 Walkthrough Find the indices of unmatched paranthesis, then locate the adjacent indices with largest difference which would be the longest valid paranthesis. 2.29.3.2 Analysis Time complexity is O(n) where n is the number of alphabets. 2.29.3.3 Algorithm dp 1.2.7 2.29.3.4 Java Code public int longestValidParentheses(String s) { //Stack contains the indices of chars which cannot be matched. Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(int i = 0; i &lt; s.length(); i++) { char c = s.charAt(i); if(c == &#39;(&#39;) { stack.push(i); } else if(c == &#39;)&#39;) { if(stack.isEmpty()) { stack.push(i); } else { int lastIndex = stack.peek(); if(s.charAt(lastIndex) == &#39;(&#39;) { //pop out the valid pairs stack.pop(); } else { //XXX: )))))( stack.push(i); } } } } int longestLength = 0; if(stack.isEmpty()) { //string contains a well-formed paranthesis longestLength = s.length(); } else { /* * Any discontinual adjacent indices represents a valid parenthesis. * Therefore, locate the adjacent indices with largest difference ==&gt; the longest valid parenthesis * * Example: * Input: (()()((()(( * Indices in stack: * 10&lt;-9&lt;-6&lt;-5&lt;-0 * * Longest valid parenthesis: 5 - 0 - 1 = 4 */ int stopIndex = s.length(), startIndex = 0; while(!stack.isEmpty()) { startIndex = stack.pop(); longestLength = Math.max(longestLength, stopIndex - startIndex - 1); stopIndex = startIndex; } longestLength = Math.max(longestLength, stopIndex); } return longestLength; } "],
["longest-increasing-subsequence-leet-code-300-medium.html", "2.30 Longest Increasing Subsequence / Leet Code 300 / Medium", " 2.30 Longest Increasing Subsequence / Leet Code 300 / Medium 2.30.1 Description Given an unsorted array of integers, find the length of longest increasing subsequence. 2.30.2 Example For example, Given [10, 9, 2, 5, 3, 7, 101, 18], The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. 2.30.3 Solution- Brute Force 2.30.3.1 Walkthrough Create an array of length of nums to store length of subsequences. Create a nested loop where two indices, stopIdx from 0 to length -1 and from startIdx from 0 to stopIdx - 1. First check if it is a increasing subsequence if (nums[stopIdx] &lt; nums[startIdx]). Increment the current length of subsequence for at startIdx - dp[startIdx] + 1. However, it is possible that dp[stopIdx] is larger than dp[startIdx] + 1 for previously traversed subsequence. Thus, we need to take the maximum out of both cases. Finally, we evaluate the final length out of dp[] array. 2.30.3.2 Analysis There are two loops, thus, the time complexity is \\(O(n^2)\\) 2.30.3.3 Algorithm dp 1.2.7 2.30.3.4 Java Code - Brute Force public int lengthOfLIS(int[] nums) { int dp[] = new int[nums.length]; if(nums.length == 0) { return 0; } //init Arrays.fill(dp, 1); for(int stopIdx = 0; stopIdx &lt; nums.length; stopIdx++) { for(int startIdx = 0; startIdx &lt; stopIdx; startIdx++) { //Valid Increasing Subsequence if(nums[startIdx] &lt; nums[stopIdx]) { dp[stopIdx] = Math.max(dp[startIdx] + 1, dp[stopIdx]); } } } int maxLength = 0; for(int i = 0; i &lt; dp.length; i++) { maxLength = Math.max(maxLength, dp[i]); } return maxLength; } 2.30.4 Solution - Binary Search 2.30.4.1 Walkthrough 2.30.4.2 Analysis For each element, we search for the index using binary search which cost \\(O(log(n))\\). The overall time complexity is \\(O(n \\cdot log(n))\\) 2.30.4.3 Algorithm 2.30.4.4 Java Code - Binary Search public int lengthOfLIS(int[] nums) { int len = 1; for (int i = 0; i &lt; nums.length; i++) { int k = Arrays.binarySearch(nums, 0, len, nums[i]); if (k &lt; 0) { k = -(k + 1); if (k == len) { len++; } nums[k] = nums[i]; } } return len; } "],
["paint-house-leet-code-256-easy.html", "2.31 Paint House / Leet Code 256 / Easy", " 2.31 Paint House / Leet Code 256 / Easy 2.31.1 Description There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on… Find the minimum cost to paint all houses. 2.31.2 Example 2.31.3 Solution 2.31.3.1 Walkthrough We need to find the cost of one house of having one color with minimum cost with another color. Last but not least, these values need to minimized. 2.31.3.2 Analysis Time complexity is O(n) as every house is visited once. 2.31.3.3 Algorithm dp 1.2.7 2.31.3.4 Java Code public int minCost(int[][] costs) { int[] house = new int[3]; int h0 = 0, h1 = 0, h2 = 0; for (int i = 0; i &lt; costs.length; i++) { /* * house[0] = cost of current house of of r/g/b plus minimum cost of the other two houses */ house[0] = costs[i][0] + Math.min(h1, h2); house[1] = costs[i][1] + Math.min(h0, h2); house[2] = costs[i][2] + Math.min(h0, h1); h0 = house[0]; h1 = house[1]; h2 = house[2]; } return Math.min(Math.min(h0, h1), h2); } "],
["climbing-stairs-leet-code-70-easy.html", "2.32 Climbing Stairs / Leet Code 70 / Easy", " 2.32 Climbing Stairs / Leet Code 70 / Easy 2.32.1 Description You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. 2.32.2 Example Input: 2 , Output: 2 Explanation: There are two ways to climb to the top. 1 step + 1 step 2 steps \\end{itemize} Input: 3, Output: 3 Explanation: There are three ways to climb to the top. 1 step + 1 step + 1 step 1 step + 2 steps 2 steps + 1 step \\end{itemize} 2.32.3 Solution 2.32.3.1 Walkthrough i = 3, total = 1 + 2 = 3 i = 4, total = 3 + 2 = 5 i = 5, total = 5 + 3 = 8 i = 13, total = 8 + 5 = 13 \\end{itemize} 2.32.3.2 Analysis Time complexity is O(n) as each step is computed. 2.32.3.3 Algorithm dp 1.2.7 2.32.3.4 Java Code public int climbStairs(int n) { if(n == 0) { return 0; } if (n == 1) { return 1; } if (n == 2) { return 2; } int n_minus_2 = 2; int n_minus_1 = 1; int total = 0; for(int i = 3; i &lt;= n; i++) { total = n_minus_1 + n_minus_2; n_minus_1 = n_minus_2; n_minus_2 = total; } return total; } "],
["find-the-maximum-number-of-repetitions-firecode-level-3.html", "2.33 Find the Maximum Number of Repetitions / Firecode / Level 3", " 2.33 Find the Maximum Number of Repetitions / Firecode / Level 3 2.33.1 Description Given an Array of integers, write a method that will return the integer with the maximum number of repetitions. Your code is expected to run with O(n) time complexity and O(1) Auxiliary Space. The elements in the array are between 0 to size(array) - 1 and the array will not be empty. 2.33.2 Example \\(f(\\{3,1,2,2,3,4,4,4\\}) = 4\\) 2.33.3 Solution 2.33.3.1 Walkthrough The key is to utilize the characteristic of the elements in the array being between 0 to size(array) - 1. We should increment a[a[i]] by k for each element. Retrieve the maximum element and return the index of the element. k is an increment factor as long as it is bigger than size of array. 2.33.3.2 Analysis Time complexity is O(n) as every element is visited once. 2.33.3.3 Algorithm dp 1.2.7 2.33.3.4 Java Code public static int getMaxRepetition(int[] a) { //k to be the increment factor, larger &gt;= size(a) to be significant int k = 100; // Iterate though input array, for every element // arr[i], increment a[a[i]] by k for (int i = 0; i&lt; a.length; i++) { a[(a[i] \\% k)] += k; } // Find index of the maximum repeating element int max = a[0], maxIdx = 0; for (int i = 1; i &lt; a.length; i++) { if (a[i] &gt; max) { max = a[i]; maxIdx = i; } } // Return index of the maximum element return maxIdx; } "],
["house-robber-leet-code-198-easy.html", "2.34 House Robber / Leet Code 198 / Easy", " 2.34 House Robber / Leet Code 198 / Easy 2.34.1 Description You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 2.34.2 Example Input: [1,2,3,1], Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Input: [2,7,9,3,1], Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. 2.34.3 Solution 2.34.3.1 Walkthrough Create an array of same length of nums. While looping through the array, compute the max profit of: * Rob this house plus every two houses before : nums[i] + dp[i-2] * Rob prev house: dp[i-1] \\end{itemize} Finally, return the final outcome, which is the dp[n-1] 2.34.3.2 Analysis Time complexity is O(n) as every element is visited once. 2.34.3.3 Algorithm dp 1.2.7 2.34.3.4 Java Code public int rob(int[] nums) { int n = nums.length; if(n == 0) { return 0; } int[] dp = new int[n]; int max = 0; for(int i = 0; i &lt; n; i++) { dp[i] = Math.max(nums[i] + (i &gt;= 2 ? dp[i-2] : 0), (i &gt;= 1 ? dp[i-1]: 0)); } return dp[n-1]; } "],
["best-time-to-buy-and-sell-stock-leet-code-121-easy.html", "2.35 Best Time to Buy and Sell Stock / Leet Code 121 / Easy", " 2.35 Best Time to Buy and Sell Stock / Leet Code 121 / Easy 2.35.1 Description Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one 2.35.2 Example Input: [7,1,5,3,6,4], Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. 2.35.3 Solution 2.35.3.1 Walkthrough While computing (sell price - buy price), we need to keep track the maximum profit as well as the minimum minimum buying price. 2.35.3.2 Analysis Time complexity is O(n) as every element is visited once. 2.35.3.3 Algorithm dp 1.2.7 2.35.3.4 Java Code public int maxProfit(int[] prices) { int maxProfit = 0, minPrice = Integer.MAX_VALUE; for(int price : prices) { // profit = selling price - buying price int profit = price - minPrice; maxProfit = Math.max(profit, maxProfit); minPrice = Math.min(minPrice, price); } return maxProfit; } "],
["best-time-to-buy-and-sell-stock-ii-leet-code-122-easy.html", "2.36 Best Time to Buy and Sell Stock II / Leet Code 122 / Easy", " 2.36 Best Time to Buy and Sell Stock II / Leet Code 122 / Easy 2.36.1 Description Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). 2.36.2 Example Input: [7,1,5,3,6,4], Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. 2.36.3 Solution 2.36.3.1 Walkthrough if current (selling )price greater than previous (buying )price, profit += (selling price - buying price). 2.36.3.2 Analysis Time complexity is O(n) as every element is visited once. 2.36.3.3 Algorithm dp 1.2.7 2.36.3.4 Java Code public int maxProfit(int[] prices) { int profit = 0; for(int i = 1; i &lt; prices.length; i++) { if(prices[i] &gt; prices[i - 1]) { profit += prices[i] - prices[i - 1]; } } return profit; } "],
["best-time-to-buy-and-sell-stock-with-cooldown-leet-code-309-medium.html", "2.37 Best Time to Buy and Sell Stock with Cooldown / Leet Code 309 / Medium", " 2.37 Best Time to Buy and Sell Stock with Cooldown / Leet Code 309 / Medium 2.37.1 Description Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day) 2.37.2 Example Input: [1,2,3,0,2], Output: 3 Explanation: transactions = [buy, sell, cooldown, buy, sell] 2.37.3 Solution 2.37.3.1 Walkthrough 2.37.3.2 Analysis Time complexity is O(n) as every element is visited once. 2.37.3.3 Algorithm dp 1.2.7 2.37.3.4 Java Code public int maxProfit(int[] prices) { int profit = 0, prevProfit = 0, diff = Integer.MIN_VALUE, prevDiff = 0, maxProfit = 0; for (int price : prices) { prevDiff = diff; //diff = MAX (price[i - 1] - price[i], diff) diff = Math.max(prevProfit - price, prevDiff); prevProfit = profit; //profit = MAX(prevDiff + price[i], prevProfit) profit = Math.max(prevDiff + price, prevProfit); maxProfit = Math.max(maxProfit, profit); } return maxProfit; } "],
["minimum-swaps-to-make-sequences-increasing-leetcode-801-medium.html", "2.38 Minimum Swaps To Make Sequences Increasing / LeetCode 801 / Medium", " 2.38 Minimum Swaps To Make Sequences Increasing / LeetCode 801 / Medium 2.38.1 Description We have two integer sequences A and B of the same non-zero length. We are allowed to swap elements A[i] and B[i]. Note that both elements are in the same index position in their respective sequences. At the end of some number of swaps, A and B are both strictly increasing. (A sequence is strictly increasing if and only if A[0] &lt; A[1] &lt; A[2] &lt; … &lt; A[A.length - 1].) Given A and B, return the minimum number of swaps to make both sequences strictly increasing. It is guaranteed that the given input always makes it possible. 2.38.2 Example Input: A = [1,3,5,4], B = [1,2,3,7] Output: 1 Explanation: Swap A[3] and B[3]. Then the sequences are: A = [1, 3, 5, 7] and B = [1, 2, 3, 4] which are both strictly increasing. 2.38.3 Solution 2.38.3.1 Walkthrough Have 2 variables to keep track states as the following: * the minimum swaps to maintain sequence increasing if we swap at i * the minimum swaps to maintain sequence increasing if we DO NOT swap at i \\end{itemize} Since it is guaranteed that there is valid answer, then we could have the following scenario * Scenaior 1: Need to swap at [i] iff [i-1] swapped ```java // | i - 1 | i | Note // A | 3 | 4 | // B | 1 | 2 | // noSwap | x | x | [i-1] NOT swapped, [i] NOT swapped // withSwap| y | y + 1 | [i-1] swapped, [i] swapped. ``` * Scenario 2: Need to swap at [i] iff [i-1] NOT swapped ```java // | i - 1 | i | Note // A | 3 | 2 | // B | 1 | 4 | // noSwap | x | y | [i-1] swapped =&gt; [i] NOT swapped // withSwap| y | x + 1 | [i-1] NOT swapped =&gt; [i] swapped ``` * Scenario 3 : either swap or no swap \\end{itemize} 2.38.3.2 Analysis Time complexity is O(n) as every element is visited once. 2.38.3.3 Algorithm 2.38.3.4 Java Code public int minSwap(int[] A, int[] B) { //For the ith element in A and B //withSwap means the minimum swaps to maintain IS if we swap at [i] //noSwap means the minimum swaps to maintain IS if we DO NOT swap at [i] //for [0] element, init noSwap = 1 and withSwap = 0 int withSwap = 1, noSwap = 0; // System.out.println(&quot;i: &quot; + &quot;Y&quot; + &quot; | &quot; + &quot;N&quot;); //assume A.length = B.length int length = A.length; for(int i = 1; i &lt; length; i++) { if(A[i - 1] &gt;= B[i] || B[i - 1] &gt;= A[i]) { //Scenaior 1: Need to swap at [i] iff [i-1] swapped // | i - 1 | i | Note // A | 3 | 4 | // B | 1 | 2 | // noSwap | x | x | [i-1] NOT swapped, [i] NOT swapped // withSwap| y | y + 1 | [i-1] swapped, [i] swapped. //no-swap counter should remain withSwap++; } else if(A[i - 1] &gt;= A[i] || B[i - 1] &gt;= B[i]) { //Implicitly A[i - 1] &lt; B[i] &amp;&amp; B[i - 1] &lt; A[i] //Scenario 2: Need to swap at [i] iff [i-1] NOT swapped // | i - 1 | i | Note // A | 3 | 2 | // B | 1 | 4 | // noSwap | x | y | [i-1] swapped =&gt; [i] NOT swapped // withSwap| y | x + 1 | [i-1] NOT swapped =&gt; [i] swapped int temp = withSwap; withSwap = noSwap + 1; noSwap = temp; } else { //Scenario 3 : either swap or no swap int min = Math.min(withSwap, noSwap); withSwap = min + 1; noSwap = min; } // System.out.println(i + &quot;: &quot; + withSwap + &quot; | &quot; + noSwap); } return Math.min(noSwap, withSwap); } "],
["retrieve-an-optimal-computation-from-an-array.html", "2.39 Retrieve an Optimal Computation from an Array / /", " 2.39 Retrieve an Optimal Computation from an Array / / 2.39.1 Description Each piece has a positive integer (weight) that indicates how tasty it is. Since taste is subjective, there is also an expectancy factor. A piece will taste better if you eat it later: if the taste is m on the first day, it will be k * m on day number k. Your task is to design an efficient algorithm that computes an optimal chocolate eating strategy and tells you how much pleasure to expect. 2.39.2 Example [1, 2, 3], multiplier = 1 Result = \\(1 * 1 + 2 * 2 + 3 * 3 + 4 * 4= 30\\) 2.39.3 Solution - Recursion 2.39.3.1 Walkthrough In the recursive startegy: In the base case, where array contains only one element, the function returns the correct value. When array contains more than 1 element, we have to start with either array[0] or array[n-1]. The code computes for each of these cases with recursion, and returns the maximum. Figure 2.4: Some caption. 2.39.3.2 Analysis The time complexity is exponential, since there are some overlapping subproblems shown in the recursion tree. \\(O(2^{log(n)})\\) 2.39.3.3 Algorithm recursion 1.2.5 2.39.3.4 Java Code - Recursion int solution(int[] array) { return rec(array, 1); } int rec(int[] array, int multiplier) { int len = array.length; if(len == 1) { return array[0] * multiplier; } int left = array[0] * multiplier + rec(Arrays.copyOfRange(array, 1, len), multiplier + 1); int right = array[len - 1] * multiplier + rec(Arrays.copyOfRange(array, 0, len - 1), multiplier + 1); return Math.max(left, right); } 2.39.4 Solution - Recursion with Memoization 2.39.4.1 Walkthrough We can derive \\(multiplier = 1 + n - (j - i), 0 &lt;= i &lt; j &lt;= n,\\) The sum of product array[i:j] is either computed directly (the base case), or it can be computed in constant time from the already known sum of array[i+1:j] and array[i:j-1]. 2.39.4.2 Analysis If we use dynamic programming and memorize all of these subresults, we will get an algorithm with \\(O(n^2)\\) time complexity. 2.39.4.3 Algorithm recursion 1.2.5, memoization 1.2.8 2.39.4.4 Java Code - Recursion with Memoization int solution(int[] array) { int len = array.length; int[][] dp = new int[len + 1][len + 1]; return memoization(array, 0, len, dp); } // 0 &lt;= start &lt; stop &lt;= n // start inclusive, stop exclusive int memoization(int[] array, int start, int stop, int[][] dp) { int multiplier = 1 + array.length - (stop - start); if(dp[start][stop] &gt; 0) { //visited subproblem return dp[start][stop]; } if(stop - start == 1) { return array[start] * multiplier; } int left = multiplier * array[start] + memoization(array, start + 1, stop, dp); int right = multiplier * array[stop - 1] + memoization(array, start, stop - 1, dp); int result = Math.max(left, right); dp[start][stop] = result; return result; } 2.39.5 Solution - Dynamic Programming with Tabulation 2.39.5.1 Walkthrough We can derive \\(multiplier = 1 + n - (j - i), 0 &lt;= i &lt; j &lt;= n,\\) As an alternative, we can use tabulation and start by filling up the memo table. Note that the order of computation matters: to compute the value memo[i][j], the values of memo[i+1][j] and memo[i][j-1] must first be known. Here is the final view of table from the example: 0 4 11 20 30 0 0 8 18 29 0 0 0 12 25 0 0 0 0 16 0 0 0 0 0 2.39.5.2 Analysis 2.39.5.3 Algorithm dp 1.2.7, tabulation 1.2.9 2.39.5.4 Java Code - Dynamic Programming with Tabulation int solution(int[] array) { int len = array.length; int[][] dp = new int[len + 1][len + 1]; return tabulation(array, dp, len); } int tabulation(int[] array, int[][] dp, int len) { for(int i = 0; i &lt; len; i++) { dp[i][i + 1] = len * array[i]; } for (int i = len - 1; i &gt;= 0; i--) { for(int j = i + 2; j &lt;= len; j++) { int multiplier = 1 + len - (j - i); int left = multiplier * array[i] + dp[i + 1][j]; int right = multiplier * array[j - 1] + dp[i][j - 1]; int result = Math.max(left, right); dp[i][j] = result; } } return dp[0][len]; } "],
["shortest-word-distance.html", "2.40 Shortest Word Distance / /", " 2.40 Shortest Word Distance / / 2.40.1 Description Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list. 2.40.2 Example words = [“practice”, “makes”, “perfect”, “coding”, “makes”] word1 = “coding”, word2=“practice” result is 3 word1 = “makes”, word2=“coding” result is 1 2.40.3 Solution 2.40.3.1 Walkthrough Record the indices for each word. Retrieve the minimum distance between two group of indices. 2.40.3.2 Analysis Each word in the list is visited once, and each index in both list is visited once. Thus time complexity is O(n), where the Auxiliary Space is O(n) for storing indices. 2.40.3.3 Algorithm 2.40.3.4 Java Code public int shortestDistance(String[] words, String word1, String word2) { // list of indices for word1 and word2 in the array respectively. List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; words.length; i++) { if(words[i].equals(word1)) { list1.add(i); } else if(words[i].equals(word2)) { list2.add(i); } } int min = words.length; for(int i = 0, j = 0; i &lt; list1.size() &amp;&amp; j &lt; list2.size();) { int index1 = list1.get(i); int index2 = list2.get(i); min = Math.min(min, Math.abs(index1 - index2)); if(index1 &lt; index2) { i++; } else if(index1 &gt; index2) { j++; } else { // comparing the same indices return 0; } } return min; } "],
["matrix.html", "Chapter 3 Matrix\n", " Chapter 3 Matrix\n"],
["design-a-tic-tac-toe-leetcode-348-medium.html", "3.1 Design a Tic-tac-toe / LeetCode 348 / Medium", " 3.1 Design a Tic-tac-toe / LeetCode 348 / Medium 3.1.1 Description Design a Tic-tac-toe game that is played between two players on a n x n grid. 3.1.2 Example 3.1.3 Solution 3.1.3.1 Walkthrough Check if the player win for the same row, column, forward and back diagonals. 3.1.3.2 Analysis All entries in matrix will be visited, that is, O(rows * cols) 3.1.3.3 Algorithm 3.1.3.4 Java Code int[][] matrix; public int move(int row, int col, int player) { matrix[row][col]=player; //check row boolean win = true; for(int i = 0; i &lt; matrix.length; i++){ if(matrix[row][i] != player){ win = false; break; } } if(win) return player; //check column win = true; for(int i = 0; i &lt; matrix.length; i++){ if(matrix[i][col] != player){ win = false; break; } } if(win) return player; //check back diagonal win = true; for(int i = 0; i &lt; matrix.length; i++){ if(matrix[i][i] != player){ win = false; break; } } if(win) return player; //check forward diagonal win = true; for(int i = 0; i &lt; matrix.length; i++){ if(matrix[i][matrix.length-i-1] != player){ win = false; break; } } if(win) return player; return 0; } "],
["rotate-image-leet-code-48-medium.html", "3.2 Rotate Image / Leet Code 48 / Medium", " 3.2 Rotate Image / Leet Code 48 / Medium 3.2.1 Description You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. 3.2.2 Example Given input matrix, and rotate the input matrix in-place. [1,2,3], [7,4,1], [4,5,6], ==&gt; [8,5,2], [7,8,9] [9,6,3] 3.2.3 Solution 3.2.3.1 Walkthrough Take this matrix as example, [1,2,3], [4,5,6], [7,8,9] first swap the symmetric elements via top-left to bottom-right diagnal, [1,4,7], [2,5,8], [3,6,9] and swap columns via centeral vertical line. [7,|4|,1], [8,|5|,2], [9,|6|,3] 3.2.3.2 Analysis Time complexity is \\(O(n^2)\\) as there are two loops 3.2.3.3 Algorithm 3.2.3.4 Java Code public void rotate(int[][] matrix) { //Swap symmetric element via diagnal for (int i = 0; i &lt; matrix.length; i++) { for (int j = 0; j &lt; i; j++) { int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; } } //Swap columns via centeral vertical line for (int i = 0, j = matrix.length - 1; i &lt; matrix.length / 2; i++, j--) { for (int k = 0; k &lt; matrix.length; k++) { int temp = matrix[k][i]; matrix[k][i] = matrix[k][j]; matrix[k][j] = temp; } } } "],
["spiral-matrix-leetcode-54-medium.html", "3.3 Spiral Matrix / LeetCode 54 / Medium", " 3.3 Spiral Matrix / LeetCode 54 / Medium 3.3.1 Description Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. 3.3.2 Example Input: 1, 2, 3 , 4, 5, 6 , 7, 8, 9 Output: [1,2,3,6,9,8,7,4,5] Input: 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12 Output: [1,2,3,4,8,12,11,10,9,5,6,7] ### Solution #### Walkthrough While walking through the circles, track current left, right, top, and bottom positions. (r) 0 1 2 (c) 0 - - - 1 | &gt; | 2 - - | * Going rightward * Going downward * Going leftward * Going upward Be sure to check for duplicated column or row before going for each direction. 3.3.2.1 Analysis Time complexity is O(rows * cols), since all elements are visited once 3.3.2.2 Algorithm 3.3.2.3 Java Code public List spiralOrder(int[][] matrix) { List result = new ArrayList&lt;&gt;(); if(matrix.length == 0) { return result; } int rows = matrix.length; int cols = matrix[0].length; // position of left, right, top and buttom border int left = 0; int right = cols - 1; int top = 0; int bottom = rows - 1; while( result.size() &lt; (cols * rows) ) { //traverse a circle // avoid duplicated row if(top &gt; bottom) { break; } //going rightward for(int i = left; i &lt;= right; i++){ result.add(matrix[top][i]); } top++; // avoid duplicated column if(left &gt; right) { break; } //going downward for(int i = top; i &lt;= bottom; i++){ result.add(matrix[i][right]); } right--; // avoid duplicated row if(top &gt; bottom) { break; } // going leftward for(int i = right; i &gt;= left; i--){ result.add(matrix[bottom][i]); } bottom--; // avoid duplicated column if(left &gt; right) { break; } // going upward for(int i = bottom; i &gt;= top; i--){ result.add(matrix[i][left]); } left++; } return result; } "],
["search-a-2d-matrix-leetcode-74-medium.html", "3.4 Search a 2D Matrix / LeetCode 74 / Medium", " 3.4 Search a 2D Matrix / LeetCode 74 / Medium 3.4.1 Description Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: * Integers in each row are sorted from left to right. * The first integer of each row is greater than the last integer of the previous row. 3.4.2 Example Input: [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] target = 3 Output: true Input: [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] target = 13 Output: false 3.4.3 Solution 3.4.3.1 Walkthrough We can treat the 2D matrix as the one large array, and search the element using binary search. We only need to compute middle of row or column for each divide-and-conquer turn. 3.4.3.2 Analysis The overall time complexity is O(log(rows * cols)) 3.4.3.3 Algorithm recursion 1.2.10 3.4.3.4 Java Code public boolean searchMatrix(int[][] matrix, int target) { if(matrix == null || matrix.length == 0 || matrix[0].length == 0) { return false; } int rows = matrix.length; int cols = matrix[0].length; int start = 0; int end = rows * cols - 1; while(start &lt;= end) { int mid = (end - start) / 2 + start; int midRow = mid / cols; int midCol = mid % cols; if(matrix[midRow][midCol] == target) { return true; } else if(matrix[midRow][midCol] &lt; target) { start = mid + 1; } else { //matrix[midRow][midCol] &gt; target end = mid - 1; } } return false; } "],
["search-a-2d-matrix-ii-leetcode-240-medium.html", "3.5 Search a 2D Matrix II / LeetCode 240 / Medium", " 3.5 Search a 2D Matrix II / LeetCode 240 / Medium 3.5.1 Description Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: * Integers in each row are sorted in ascending from left to right. * Integers in each column are sorted in ascending from top to bottom. 3.5.2 Example [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] ```, 5 returns true ### Solution #### Walkthrough Traverse the matrix by * locate row when target is smaller than m[r][c] * locate col when target is larger than m[r][c] #### Analysis A portion of cell is visited, O(m + n) - instead of every cell (m * n) #### Algorithm #### Java Code ```java public boolean searchMatrix(int[][] matrix, int target) { if(matrix == null || matrix.length == 0) { return false; } int rows = matrix.length-1; int cols = matrix[0].length-1; int r = rows; int c = 0; while(r &gt;= 0 &amp;&amp; c &lt;= cols){ if(target &lt; matrix[r][c]) { r--; } else if(target &gt; matrix[r][c]) { c++; } else { return true; } } return false; } "],
["minimum-path-sum-leetcode-64-medium.html", "3.6 Minimum Path Sum / LeetCode 64 / Medium", " 3.6 Minimum Path Sum / LeetCode 64 / Medium 3.6.1 Description Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. You can only move either down or right at any point in time. ### Example Input: [1],[3],[1], 1, 5, [1], 4, 2, [1] Output: 7, because the path \\(1 -&gt; 3 -&gt; 1 -&gt; 1 -&gt; 1\\) minimizes the sum. 3.6.2 Solution - Recursive 3.6.2.1 Walkthrough Time Complexity is exponential. Figure 3.1: Some caption. See the above recursion tree, there are many nodes which apear more than once. Final cost matrix: [1], [4], [5] 2, 7, [6] 6, 8, [7] 3.6.2.2 Analysis There will be \\(2^{h + 1} - 1 = 2^{log(m*n) + 1} - 1\\) subproblems, including the overlapping subproblems, which means the same subproblem has been computed again and gain. Thus, the time complexity is \\(O(2^{log(m * n)})\\) 3.6.2.3 Algorithm recursion 1.2.5 3.6.2.4 Java Code - Recursive public int minPathSum(int[][] grid) { if(grid == null || grid.length==0) { return 0; } return rec(0,0,grid); } public int rec(int i, int j, int[][] grid){ int rows = grid.length; int cols = grid[0].length; if(i == (rows - 1) &amp;&amp; j == (cols - 1)){ //at bottom right return grid[i][j]; } else if(i &lt; (rows - 1) &amp;&amp; j == (cols - 1)) { //at last column, moving downward return grid[i][j] + dfs(i+1, j, grid); } else if(i == (rows - 1) &amp;&amp; j &lt; (cols - 1)) { //at last row, moving rightward return grid[i][j] + dfs(i, j+1, grid); } else { //other place, get min of downward and rightward int r1 = grid[i][j] + rec(i+1, j, grid); int r2 = grid[i][j] + rec(i, j+1, grid); return Math.min(r1,r2); } } 3.6.3 Solution - Dynamic Programming 3.6.3.1 Walkthrough * create a cost matrix of the same size * init cost[0][0] to be grid[0][0] * init first row and first column, previous cell cost plus current cell cost * For each other cell, determine the minimum cost of previous top or left cell plus current cell cost. 3.6.3.2 Analysis Complexity: O(n * m) since each cell is visited once 3.6.3.3 Algorithm dp 1.2.7 3.6.3.4 Java Code - Dynamic Programming public int minPathSum(int[][] grid) { if(grid == null || grid.length == 0) { return 0; } int rows = grid.length; int cols = grid[0].length; int[][] dp = new int[rows][cols]; dp[0][0] = grid[0][0]; // initialize first row for(int c = 1; c &lt; cols; c++){ dp[0][c] = dp[0][c - 1] + grid[0][c]; } // initialize first column for(int r = 1; r &lt; rows; r++){ dp[r][0] = dp[r - 1][0] + grid[r][0]; } // fill up the dp table for(int i = 1; i &lt; rows; i++){ for(int j = 1; j &lt; cols; j++){ int minNeighbor = Math.min(dp[i - 1][j], dp[i][j - 1]); dp[i][j] = minNeighbor + grid[i][j]; } } return dp[rows - 1][cols - 1]; } "],
["unique-paths-leetcode-62-medium.html", "3.7 Unique Paths / LeetCode 62 / Medium", " 3.7 Unique Paths / LeetCode 62 / Medium 3.7.1 Description A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid. How many possible unique paths are there? 3.7.2 Example Given a matrix of size 2 * 3: [],[],[] [],[],[] There are 3 unique path: * (0,0) - (1,0) - (1,1) - (1,2) * (0,0) - (0,1) - (1,1) - (1,2) * (0,0) - (0,1) - (0,2) - (1,2) 3.7.3 Solution - Recursion 3.7.3.1 Walkthrough Figure 3.2: Some caption. 3.7.3.2 Analysis Naive recursive strategy results in overlapping subproblems. The time complexity is \\(O(2^{log (m * n)})\\) 3.7.3.3 Algorithm recursion 1.2.5 3.7.3.4 Java Code - Recursion public int uniquePaths(int m, int n) { return rec(0, 0, m, n); } int rec(int i, int j, int rows, int cols){ if(i == (rows - 1) &amp;&amp; j == (cols - 1)){ //at bottom right return 1; } else if(i &lt; (rows - 1) &amp;&amp; j == (cols - 1)) { //at last column, moving downward return rec(i+1, j, rows, cols); } else if(i == (rows - 1) &amp;&amp; j &lt; (cols - 1)) { //at last row, moving rightward return rec(i, j+1, rows, cols); } else { //other place, get min of downward and rightward return rec(i+1, j, rows, cols) + rec(i, j+1, rows, cols); } } 3.7.4 Solution - Dynamic Programming 3.7.4.1 Walkthrough Number of unique path to current cell equals to the sum of paths to the previous cells. For example, the matrix representing # of path to reach current cell. The weight at (1,2) equals to sum of (0,2) and (1,1) 1 1 1 1 2 3 3.7.4.2 Analysis Time complexity is O(n * m) since each cell is visited once. A cache of size O(n * m ) is used to store visited cell value. 3.7.4.3 Algorithm dp 1.2.7 3.7.4.4 Java Code - Dynamic Programming public int uniquePaths(int m, int n) { if(m == 0 || n == 0) { return 0; } if(m == 1 || n == 1) { return 1; } int[][] dp = new int[m][n]; //init first column for(int i = 0; i &lt; m; i++){ dp[i][0] = 1; } //init first row for(int j = 0; j &lt; n; j++){ dp[0][j] = 1; } //fill up the rest of table for(int i = 1; i &lt; m; i++){ for(int j = 1; j &lt; n; j++){ dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m-1][n-1]; } "],
["word-search-leetcode-79-medium.html", "3.8 Word Search / LeetCode 79 / Medium", " 3.8 Word Search / LeetCode 79 / Medium 3.8.1 Description Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. 3.8.2 Example board = [ [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;], [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;], [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;] ] Given word = “ABCCED”, return true. Given word = “SEE”, return true. Given word = “ABCB”, return false. 3.8.3 Solution - DFS 3.8.3.1 Walkthrough Enumerate all possible starting position from the 2D array by using two nested loops. While traversing the character in the taget string, perform a search recursively on neighboring cells [(i, j + 1), (i, j - 1), (i + 1, j), (i - 1, j)]. If there is a hit in any four neighboring cells, return true; otherwise, return false. 3.8.3.2 Analysis The enumeration cost is exponential, as there are multiple overlapping subproblems. Thus, the time complexity is \\(O(2^{log(n)})\\) 3.8.3.3 Algorithm backtrack 1.2.6, dfs 1.2.1 3.8.3.4 Java Code - DFS private static final char VISITED_CHARACTER = &#39;*&#39;; public boolean exist(char[][] board, String word) { int numOfRows = board.length; int numOfCols = board[0].length; //Enumerate the all possible starting position from char[][] for (int i = 0; i &lt; numOfRows; i++) { for (int j = 0; j &lt; numOfCols; j++) { if (backtrack(board, i, j, word, 0)) { return true; } } } return false; } private boolean backtrack(char[][] board, int row, int col, String word, int index) { int numOfRows = board.length; int numOfCols = board[0].length; //every other character has matched if (index == word.length()) { return true; } //exceed the boundary if (row &lt; 0 || row &gt;= numOfRows || col &lt; 0 || col &gt;= numOfCols) { return false; } //if current char is not equal if (board[row][col] != word.charAt(index)) { return false; } // &#39;nullify&#39; current position board[row][col] ^= VISITED_CHARACTER; //result of next move from four directions. boolean result = backtrack(board, row + 1, col, word, index + 1) || backtrack(board, row - 1, col, word, index + 1) || backtrack(board, row, col + 1, word, index + 1) || backtrack(board, row, col - 1, word, index + 1); //nullify back board[row][col] ^= VISITED_CHARACTER; return result; } "],
["number-of-islands-leetcode-200-medium.html", "3.9 Number of Islands / LeetCode 200 / Medium", " 3.9 Number of Islands / LeetCode 200 / Medium 3.9.1 Description Given a 2d grid map of ’1’s (land) and ’0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. 3.9.2 Example 11110 11010 11000 00000 = 1 11000 11000 00100 00011 = 3 3.9.3 Solution - DFS 3.9.3.1 Walkthrough Traverse all cell and once we find a land tile, fill the adjacent land recursively. Count each land tile we have encountered. 3.9.3.2 Analysis Everyone cell in matrix is visited. Thus, is O(rows * cols) 3.9.3.3 Algorithm dfs 1.2.1 3.9.3.4 Java Code - DFS public int numIslands(char[][] grid) { if(grid==null || grid.length==0||grid[0].length==0) return 0; int rows = grid.length; int cols = grid[0].length; int count = 0; for(int i = 0; i &lt; rows; i++){ for(int j = 0; j &lt; cols; j++){ if(grid[i][j] == &#39;1&#39;){ count++; fill(grid, i, j); } } } return count; } public void fill(char[][] grid, int i, int j){ int rows = grid.length; int cols = grid[0].length; if(i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || grid[i][j] != &#39;1&#39;) return; grid[i][j] = &#39;X&#39;; // recursively fill the adjacent land fill(grid, i - 1, j); fill(grid, i + 1, j); fill(grid, i, j - 1); fill(grid, i, j + 1); } "],
["surrounded-regions-leetcode-130-medium.html", "3.10 Surrounded Regions / LeetCode 130 / Medium", " 3.10 Surrounded Regions / LeetCode 130 / Medium Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’. A region is captured by flipping all ’O’s into ’X’s in that surrounded region. Surrounded regions shouldn’t be on the border, which means that any ‘O’ on the border of the board are not flipped to ‘X’. Any ‘O’ that is not on the border and it is not connected to an ‘O’ on the border will be flipped to ‘X’. Two cells are connected if they are adjacent cells connected horizontally or vertically. 3.10.1 Description 3.10.2 Example X X X X X O O X X X O X X O X X to X X X X X X X X X X X X X O X X 3.10.3 Solution - DFS 3.10.3.1 Walkthrough First preserve the border tile (or tile connected to a border ultimately) with ‘#’. X X X X X O O X X X O X X # X X Traverse all cell by changing the inland tile (‘O’) to ‘X’ and reset ‘#’ back to ‘O’. X X X X X X X X X X X X X O X X 3.10.3.2 Analysis All cell is visited a few times, thus, O(rows * cols). #### Algorithm dfs 1.2.1 3.10.3.3 Java Code - DFS public void solve(char[][] board) { if(board == null || board.length==0) return; int rows = board.length; int cols = board[0].length; //preserve O&#39;s on left &amp; right boarder for(int i = 0;i &lt; rows;i++){ if(board[i][0] == &#39;O&#39;){ preserve(board, i, 0); } if(board[i][cols - 1] == &#39;O&#39;){ preserve(board, i, n - 1); } } //preserve O&#39;s on top &amp; bottom boarder for(int j = 0; j &lt; cols; j++){ if(board[0][j] == &#39;O&#39;){ preserve(board, 0, j); } if(board[rows - 1][j] == &#39;O&#39;){ preserve(board, m - 1, j); } } //process the board for(int i = 0;i &lt; rows;i++) { for(int j = 0; j &lt; cols; j++) { if(board[i][j] == &#39;O&#39;) { board[i][j] = &#39;X&#39;; } else if(board[i][j] == &#39;#&#39;) { // change the preserved border tile back to &#39;O&#39; board[i][j] = &#39;O&#39;; } } } } public void preserve(char[][] board, int i, int j){ int rows = board.length; int cols = board[0].length; if(i &lt; 0 || i &gt;= rows || j &lt; 0 || j &gt;= cols || board[i][j] != &#39;O&#39;) return; board[i][j] = &#39;#&#39;; // recursively fill the adjacent land preserve(board, i - 1, j); preserve(board, i + 1, j); preserve(board, i, j - 1); preserve(board, i, j + 1); } "],
["best-meeting-point-leetcode-296-hard.html", "3.11 Best Meeting Point / LeetCode 296 / Hard", " 3.11 Best Meeting Point / LeetCode 296 / Hard 3.11.1 Description A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance(p1, p2) = \\(|p2.x - p1.x| + |p2.y - p1.y|\\) 3.11.2 Example For example, given three people living at (0,0), (0,4), and (2,2): 1 - 0 - [0] - 0 - 1 | | | | | 0 - 0 - 0 - 0 - 0 | | | | | 0 - 0 - 1 - 0 - 0 The point (0,2) is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6. 3.11.3 Solution 3.11.3.1 Walkthrough The median points for row and col should be the optimal meeting point. We could compute the distance by substracting the coordinate of people by the median X and Y. 3.11.3.2 Analysis Each cell in matrix will be visited at least once. Thus, O(rows * cols). 3.11.3.3 Algorithm 3.11.3.4 Java Code public int minTotalDistance(int[][] grid) { int rows = grid.length; int cols = grid[0].length; List&lt;Integer&gt; cols = new ArrayList&lt;Integer&gt;(); List&lt;Integer&gt; rows = new ArrayList&lt;Integer&gt;(); for(int i = 0; i &lt; rows; i++){ for(int j = 0; cols &lt; n; j++){ if(grid[i][j] == 1){ cols.add(j); rows.add(i); } } } int dist = 0; int medianRow = rows.get(rows.size() / 2); for(Integer r: rows){ dist += Math.abs(r - medianRow); } //sort col position so that we could get median col properly Collections.sort(cols); int medianCol = cols.get(cols.size() / 2); for(Integer c: cols){ dist += Math.abs(c - medianCol); } return dist; } "],
["tree.html", "Chapter 4 Tree", " Chapter 4 Tree 4.0.1 Breadth First Traversal The algorithm starts at the tree root, and explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level. 4.0.1.1 Algorithm bfs 1.2.2 4.0.1.2 Typical Implementation - Java public boolean breadthFirstTraversal(TreeNode root) { Queue&lt;TreeNode&gt; queue = new LinkedList(); while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } return false; } 4.0.1.3 Complexity Analysis Time Complexity: Breadth-first search visits every vertex once and checks every edge in the graph once. Therefore, the runtime complexity is \\(O(|V| + |E|)\\). In simplicity, O(n) since \\(|V| = n\\) Auxiliary Space: In Breadth First traversal, visited node in different level is stored in a queue one by one. Extra Space required is O(w) where w is maximum width of a level in binary tree. 4.0.2 Depth First Traversal The algorithm starts at the root node and explores as far as possible along each branch. 4.0.2.1 Algorithm dfs 1.2.1 4.0.2.2 Type of Depth First Traversal Depth First InOrder Traversal Depth First PreOrder Traversal Depth First PostOrder Traversal 4.0.2.3 Complexity Analysis Time Complexity: Depth-first search visits every vertex once and checks every edge in the graph once. Therefore, the runtime complexity is \\(O(|V| + |E|)\\). In simplicity, O(n) since \\(|V| = n\\) Auxiliary Space: In Depth First Traversals, stack (or function call stack) stores all ancestors of a node. Extra Space required is O(h) where h is maximum height of binary tree. 4.0.3 Selection Strategy Extra Space can be one factor Depth First Traversals are typically recursive and recursive code requires function call overheads. The most important points is, BFS starts visiting nodes from root while DFS starts visiting nodes from leaves. So if our problem is to search something that is more likely to closer to root, we would prefer BFS. And if the target node is close to a leaf, we would prefer DFS Maximum Width of a Binary Tree at depth (or height) h can be 2h where h starts from 0. So the maximum number of nodes can be at the last level. And worst case occurs when Binary Tree is a perfect Binary Tree with numbers of node It is evident from above points that extra space required for Level order traversal is likely to be more when tree is more balanced and extra space for Depth First Traversal is likely to be more when tree is less balanced. 4.0.4 Binary Search Tree Figure 4.1: Some caption. A BST is a binary tree where nodes are ordered in the following way: each node contains one key (also known as data) the keys in the left subtree are less then the key in its parent node the keys in the right subtree are greater the key in its parent node duplicate keys are not allowed. 4.0.4.1 Algorithm bst 1.2.11 4.0.4.2 Complexity Analysis The particular kind of binary tree is optimized in a way that only a PARTIAL nodes along a path will be visited during search, the general time complexity is reduced to O(h) where h = log(n). Since a binary search tree with n nodes has a minimum of O(log(n)) levels, it takes at least O(log(n)) comparisons to find a particular node. However, in the edge cases where tree is in a list form, the worst time complexity is O(n) "],
["balanced-binary-tree-leet-code-110-easy.html", "4.1 Balanced Binary Tree / Leet Code 110 / Easy", " 4.1 Balanced Binary Tree / Leet Code 110 / Easy 4.1.1 Description Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 4.1.2 Example Figure 4.2: Some caption. Return true. Figure 4.3: Some caption. Return false. 4.1.3 Solution 4.1.3.1 Walkthrough Remember current height and recursively compute the height for the left and right subtree. In addition, evaluate if the absolute value of height of two subtrees is greater than 1. If yes, return false; true, otherwise. 4.1.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.1.3.3 Algorithm dfs 1.2.1 4.1.3.4 Java Code public boolean isBalanced(TreeNode root) { if (root == null) { return true; } // left height | right height &gt; 1 if (getHeight(root) == -1) { return false; } return true; } public int getHeight(TreeNode root) { if (root == null) { return 0; } int lHeight = getHeight(root.left); int rHeight = getHeight(root.right); if (lHeight == -1 || rHeight == -1) { return -1; } if (Math.abs(left - right) &gt; 1) { return -1; } return Math.max(left, right) + 1; } "],
["invert-binary-tree-leet-code-226-easy.html", "4.2 Invert Binary Tree / Leet Code 226 Easy", " 4.2 Invert Binary Tree / Leet Code 226 Easy 4.2.1 Description Invert a binary tree 4.2.2 Example Figure 4.4: Some caption. inverts Figure 4.5: Some caption. 4.2.3 Solution - DFS 4.2.3.1 Walkthrough Swap the left and right subtree with recursive strategy. 4.2.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.2.3.3 Algorithm dfs 1.2.1 4.2.3.4 Java Code - DFS public TreeNode invertTree(TreeNode root) { if (root == null) { return null; } //swap left and right subtrees TreeNode origRight = root.right; root.right = invertTree(root.left); root.left = invertTree(origRight); return root; } 4.2.4 Solution - BFS 4.2.4.1 Walkthrough Swap the left and right subtree with iterative (BFS) strategy 4.2.4.2 Analysis Time complexity is O(n) as every node is visited once. 4.2.4.3 Algorithm bfs 1.2.2 4.2.4.4 Java Code - BFS public TreeNode invertTree(TreeNode root) { if (root == null) { return null; } Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while(!queue.isEmpty()) { TreeNode node = queue.poll(); //swap left and right subtrees TreeNode origRight = node.right; node.right = node.left; node.left = origRight; if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } return root; } "],
["symmetric-tree-leet-code-101-easy.html", "4.3 Symmetric Tree / Leet Code 101 / Easy", " 4.3 Symmetric Tree / Leet Code 101 / Easy 4.3.1 Description Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). 4.3.2 Example Figure 4.6: Some caption. is symmetric. Figure 4.7: Some caption. is NOT symmetric. 4.3.3 Solution 4.3.3.1 Walkthrough If they are symmetric, compare its value and recursively call its grand children node in symmetric manner: left.left vs right.right left.right vs right.left 4.3.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.3.3.3 Algorithm dfs 1.2.1 4.3.3.4 Java Code public boolean isSymmetric(TreeNode root) { if (root == null) { return true; } return isSymmetric(root.left, root.right); } private boolean isSymmetric(TreeNode left, TreeNode right) { if (left == null &amp;&amp; right == null) { return true; } else if (left == null || right == null) { return false; } else { return left.val == right.val &amp;&amp; isSymmetric(left.left, right.right) &amp;&amp; isSymmetric(left.right, right.left); } } "],
["binary-tree-level-order-traversal-leet-code-102-medium.html", "4.4 Binary Tree Level Order Traversal / Leet Code 102 / Medium", " 4.4 Binary Tree Level Order Traversal / Leet Code 102 / Medium 4.4.1 Description Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). 4.4.2 Example Figure 4.8: Some caption. return its level order traversal as: [ [3], [9,20], [15,7] ] 4.4.3 Solution - BFS with Two Loops 4.4.3.1 Walkthrough Create a queue and push node of the same level in a two dimensional array list while traversing the tree with BFS algorithm. 4.4.3.2 Analysis Breadth first traversal has time complexity of O(n), as every node is visited and thus the space complexity is also O(n). 4.4.3.3 Algorithm bfs 1.2.2 4.4.3.4 Java Code - BFS with Two Loops public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; levels = new ArrayList&lt;&gt;(); if(root == null) { return levels; } queue.offer(root); while(!queue.isEmpty()) { //number of element for this level int currentLevelSize = queue.size(); List&lt;Integer&gt; level = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; currentLevelSize; i++) { TreeNode node = queue.poll(); level.add(node.val); // push all elements for next level if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } //add all elements for this level levels.add(level); } return levels; } 4.4.4 Solution - BFS with One Loops 4.4.4.1 Walkthrough Create a queue and push node of the same level in a two dimensional array list while traversing the tree with BFS algorithm. 4.4.4.2 Analysis Breadth first traversal has time complexity of O(n), as every node is visited and thus the space complexity is also O(n). 4.4.4.3 Algorithm bfs 1.2.2 4.4.4.4 Java Code - BFS with One Loop public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; levels = new ArrayList&lt;&gt;(); if (root == null) { return levels; } Queue&lt;TreeNode&gt; currentLevelQueue = new LinkedList&lt;TreeNode&gt;(); Queue&lt;TreeNode&gt; nextLevelQueue = new LinkedList&lt;TreeNode&gt;(); currentLevelQueue.offer(root); //init level to null List&lt;Integer&gt; level = null; while(!currentLevelQueue.isEmpty()) { TreeNode node = currentLevelQueue.poll(); //starting a new level if (level == null) { level = new LinkedList&lt;Integer&gt;(); levels.add(level); } level.add(node.val); //push children to next level queue if (node.left != null) { nextLevelQueue.offer(node.left); } if (node.right != null) { nextLevelQueue.offer(node.right); } //swap queue and next, where next collects all nodes for next level if (currentLevelQueue.isEmpty()) { Queue&lt;TreeNode&gt; temp = currentLevelQueue; currentLevelQueue = nextLevelQueue; nextLevelQueue = temp; //init level to null level = null; } } return levels; } 4.4.5 Solution - DFS 4.4.5.1 Walkthrough We could traverse the tree recursively with strategy, and additionally pass current level into recursive method. 4.4.5.2 Analysis DFS has time complexity of O(n) as every node is visited and thus Auxiliary Space is also O(n). 4.4.5.3 Algorithm dfs 1.2.1 4.4.5.4 Java Code - DFS public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); traverse(root, 0, ans); return ans; } private void traverse(TreeNode root, int level, List&lt;List&lt;Integer&gt;&gt; ans) { if(root == null){ return; } if(ans.size()&lt;=level){ ans.add(new ArrayList&lt;&gt;()); } ans.get(level).add(root.val); traverse(root.left, level + 1, ans); traverse(root.right, level + 1, ans); } "],
["binary-tree-level-order-traversal-ii-leet-code-107-medium.html", "4.5 Binary Tree Level Order Traversal II / Leet Code 107 / Medium", " 4.5 Binary Tree Level Order Traversal II / Leet Code 107 / Medium 4.5.1 Description Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). 4.5.2 Example Figure 4.9: Some caption. return its level order traversal as: [ [15,7], [9,20], [3] ] 4.5.3 Solution 4.5.3.1 Walkthrough Create a queue and push node of the same level in a two dimensional array list while traversing the tree with BFS algorithm. In addition, we only insert nodes at the first position at current level list. 4.5.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.5.3.3 Algorithm bfs 1.2.2 4.5.3.4 Java Code - Two Loops public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) { Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; levels = new ArrayList&lt;&gt;(); if(root == null) { return levels; } queue.offer(root); while(!queue.isEmpty()) { //number of element for this level int currentLevelSize = queue.size(); List&lt;Integer&gt; level = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; currentLevelSize; i++) { TreeNode node = queue.poll(); level.add(node.val); // push all elements for next level if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } // insert the head of the list levels.add(0, level); } return levels; } 4.5.3.5 Walkthrough Create a queue and push node of the same level in a two dimensional array list while traversing the tree with BFS algorithm. In addition, we only insert nodes at the first position at current level list. 4.5.3.6 Analysis Time complexity is O(n) as every node is visited once. 4.5.3.7 Algorithm bfs 1.2.2 4.5.3.8 Java Code - One Loop public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; levels = new ArrayList&lt;&gt;(); if (root == null) { return levels; } Queue&lt;TreeNode&gt; currentLevelQueue = new LinkedList&lt;TreeNode&gt;(); Queue&lt;TreeNode&gt; nextLevelQueue = new LinkedList&lt;TreeNode&gt;(); currentLevelQueue.offer(root); //init level to null List&lt;Integer&gt; level = null; while (!currentLevelQueue.isEmpty()) { TreeNode node = currentLevelQueue.poll(); //starting a new level if (level == null) { level = new LinkedList&lt;Integer&gt;(); // insert to head levels.add(0, level); } level.add(node.val); //push children to next level queue if (node.left != null) { nextLevelQueue.offer(node.left); } if (node.right != null) { nextLevelQueue.offer(node.right); } //swap queue and next, where next collects all nodes for next level if (currentLevelQueue.isEmpty()) { Queue&lt;TreeNode&gt; temp = currentLevelQueue; currentLevelQueue = nextLevelQueue; nextLevelQueue = temp; //init level to null level = null; } } return levels; } "],
["binary-tree-zigzag-level-order-traversal-leet-code-103-medium.html", "4.6 Binary Tree Zigzag Level Order Traversal / Leet Code 103 / Medium", " 4.6 Binary Tree Zigzag Level Order Traversal / Leet Code 103 / Medium 4.6.1 Description Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between). 4.6.2 Example Figure 4.10: Some caption. return its level order traversal as: [ [3], [20,9], [15,7] ] 4.6.3 Solution 4.6.3.1 Walkthrough Create a queue and push node of the same level in a two dimensional array list while traversing the tree with BFS algorithm. While pushing the value to the level, remember the current level and evaluate the zig-zag pattern. That is, insert nodes for certain level at the first position at current level list. 4.6.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.6.3.3 Algorithm bfs 1.2.2 4.6.3.4 Java Code - Two Loops public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) { Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; levels = new ArrayList&lt;&gt;(); if(root == null) { return levels; } queue.offer(root); int levelNum = 1; while(!queue.isEmpty()) { //number of element for this level int currentLevelSize = queue.size(); List&lt;Integer&gt; level = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; currentLevelSize; i++) { TreeNode node = queue.poll(); if(levelNum % 2 != 0) { level.add(node.val); } else { level.add(0, node.val); } // push all elements for next level if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } levelNum++; levels.add(level); } return levels; } 4.6.3.5 Walkthrough Create a queue and push node of the same level in a two dimensional array list while traversing the tree with BFS algorithm. While pushing the value to the level, remember the current level and evaluate the zig-zag pattern. 4.6.3.6 Analysis Time complexity is O(n) as every node is visited once. 4.6.3.7 Algorithm bfs 1.2.2 4.6.3.8 Java Code - One Loop public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; levels = new ArrayList&lt;&gt;(); if (root == null) { return levels; } Queue&lt;TreeNode&gt; currentLevelQueue = new LinkedList&lt;TreeNode&gt;(); Queue&lt;TreeNode&gt; nextLevelQueue = new LinkedList&lt;TreeNode&gt;(); currentLevelQueue.offer(root); //init level = null List&lt;Integer&gt; level = null; int levelNum = 1; while (currentLevelQueue.isEmpty() == false) { TreeNode node = currentLevelQueue.poll(); //starting a new level if (level == null) { level = new LinkedList&lt;Integer&gt;(); levels.add(level); } if(levelNum % 2 != 0) { level.add(node.val); } else { level.add(0, node.val); } //push children to next level queue if (node.left != null) { nextLevelQueue.offer(node.left); } if (node.right != null) { nextLevelQueue.offer(node.right); } //swap queue and next, where next collects all nodes for next level if (currentLevelQueue.isEmpty()) { Queue&lt;TreeNode&gt; temp = currentLevelQueue; currentLevelQueue = nextLevelQueue; nextLevelQueue = temp; //init level = null level = null; levelNum++; } } return levels; } "],
["count-complete-tree-nodes-leet-code-222-medium.html", "4.7 Count Complete Tree Nodes / Leet Code 222 / Medium", " 4.7 Count Complete Tree Nodes / Leet Code 222 / Medium 4.7.1 Description Given a complete binary tree, count the number of nodes. In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. In a full binary tree, it is completely filled at the last level, leaving the total node number of \\(2^{height} - 1\\) 4.7.2 Example Figure 4.11: Some caption. output 6 4.7.3 Solution 4.7.3.1 Walkthrough Recursively call at each node, and determine if it is a full binary tree or complete binary tree. if it is full binary tree (left height == right height), return \\((2^{h} - 1)\\), else return 1 + rec(node.left) + rec(node.right) 4.7.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.7.3.3 Algorithm dfs 1.2.1 4.7.3.4 Java Code public int countNodes(TreeNode root) { if(root == null) { return 0; } int lHeight = 0, rHeight = 0; for (TreeNode node = root; node != null; node = node.left, lHeight++); for (TreeNode node = root; node != null; node = node.right, rHeight++); if (lHeight == rHeight) { /* * full binary tree * 2^leftNum - 1 */ return (1 &lt;&lt; lHeight) - 1; } else { return 1 + countNodes(root.left) + countNodes(root.right); } } "],
["distance-of-a-node-from-the-root-firebase-level-3.html", "4.8 Distance of a node from the root / Firebase / Level 3", " 4.8 Distance of a node from the root / Firebase / Level 3 4.8.1 Description Given the root of a Binary Tree and an integer that represents the data value of a TreeNode present in the tree, write a method - pathLengthFromRoot that returns the distance between the root and that node. You can assume that the given key exists in the tree. The distance is defined as the minimum number of nodes that must be traversed to reach the target node. 4.8.2 Example Figure 4.12: Some caption. pathLengthFromRoot(root,5) = 3 pathLengthFromRoot(root,1) = 1 pathLengthFromRoot(root,3) = 2 4.8.3 Solution 4.8.3.1 Walkthrough Have a global variable of ArrayList to remember the path. Create a helper function to recursively traverse the tree. If the target does not lie either in the left or right subtree of the current node.Thus, remove current node’s value from trace list. 4.8.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.8.3.3 Algorithm backtrack 1.2.6, dfs 1.2.1 4.8.3.4 Java Code List&lt;TreeNode&gt; trace = new ArrayList&lt;&gt;(); int pathLengthFromRoot(TreeNode root, int target) { path.clear(); boolean result = backtrack(root, target); if(result) { return trace.size(); } else { return 0; } } boolean backtrack(TreeNode root, int target) { trace.add(root); if(root == null) { return false; } if(root.data == target) { //found the node return true; } if(backtrack(root.left, target) || backtrack(root.right, target) ) { return true; } //not in current path, backtrack trace.remove(path.size() - 1); return false; } "],
["path-sum-leet-code-112-easy.html", "4.9 Path Sum / Leet Code 112 / Easy", " 4.9 Path Sum / Leet Code 112 / Easy 4.9.1 Description Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. 4.9.2 Example Figure 4.13: Some caption. Given the below binary tree and sum = 22, return true, as there exist a root-to-leaf path \\(5-&gt;4-&gt;11-&gt;2\\) which sum is 22. 4.9.3 Solution 4.9.3.1 Walkthrough Has a variable to remember accumulated sum and recursively call on its left and right subtree. the result if and only if the accumulated sum equals to target sum or accumulate result with logical OR operator also only when traversal reach to leaf node. 4.9.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.9.3.3 Algorithm dfs 1.2.1 4.9.3.4 Java Code public boolean hasPathSum(TreeNode root, int sum) { return hasPathSum(root, 0, sum); } public boolean hasPathSum(TreeNode root, int current, int target) { if (root == null) { return false; } current += root.val; if (root.left == null &amp;&amp; root.right == null) { return current == target; } else { return hasPathSum(root.left, current, target) || hasPathSum(root.right, current, target); } } "],
["path-sum-ii-leet-code-113-medium.html", "4.10 Path Sum II / Leet Code 113 / Medium", " 4.10 Path Sum II / Leet Code 113 / Medium 4.10.1 Description Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. 4.10.2 Example Figure 4.14: Some caption. Given the below binary tree and sum = 22, return: [ [5,4,11,2], [5,8,4,5] ] 4.10.3 Solution 4.10.3.1 Walkthrough Additional list is needed to keep track current path: adding current node on entering and removing (current) node on exiting. Remember and the list if and only if current sum equals to target sum for leaf nodes. Need to remove the node list to back track also to help us locate more path in the tree. 4.10.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.10.3.3 Algorithm backtrack 1.2.6, dfs 1.2.1 4.10.3.4 Java Code public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;(); List&lt;Integer&gt; trace = new LinkedList&lt;&gt;(); backtrack(root, 0, sum, result, trace); return result; } private void backtrack(TreeNode root, int current, int target, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; trace) { if (root == null) { return; } trace.add(root.val); current += root.val; //leaf node if (root.left == null &amp;&amp; root.right == null &amp;&amp; current == target) { //to copy the valid list result.add(new LinkedList&lt;&gt;(trace)); return; } //otherwise - intermediate nodes if (root.left != null) { pathSum(root.left, current, target, result, trace); //clean up last inserted left node to back track one step trace.remove(trace.size() - 1); } if (root.right != null) { pathSum(root.right, current, target, result, trace); //clean up last inserted right node to back track one step trace.remove(trace.size() - 1); } } "],
["path-sum-iii-leet-code-437-easy.html", "4.11 Path Sum III / Leet Code 437 / Easy", " 4.11 Path Sum III / Leet Code 437 / Easy 4.11.1 Description You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000. ### Example Figure 4.15: Some caption. sum = 8, Return 3. The paths that sum to 8 are: 1. 5 -&gt; 3 2. 5 -&gt; 2 -&gt; 1 3. -3 -&gt; 11 4.11.2 Solution 4.11.2.1 Walkthrough Continue the recursive on left and right subtrees and when accumulated sum equals to the target sum. Use a length-1 array to keep track the count of path number in the recursive. We should consider both cases to include root and exlude root. For instance, if there is a tree [1,-2,1,-1] and taget sum is -1. There are four paths combined : 1. [1,-2] 2. [-2,1] 3. [-1] 4. [1,-2,1,-1] In addition, we need to store accumulated count across recursive function calls. Thus, data type cannot be Immutable, since each arithmetic operation would create another object. Thus, we need to have a mutable variable that exists across each stack frame: Have a int[1] to store the accumulated count. Have a wrapper object to reset the value towards computation. Have a shared variable declared for this purpose. 4.11.2.2 Analysis Time complexity is O(n) as every node is visited once. 4.11.2.3 Algorithm dfs 1.2.1 4.11.2.4 Java Code int count = 0; public int pathSum(TreeNode root, int sum) { helperSum(root, 0, sum); return count; } private void helperSum(TreeNode root, int current, int target) { if (root == null) { return; } // root included helper(root, current, target); // root excluded helperSum(root.left, current, target); helperSum(root.right, current, target); } private void helper(TreeNode root, int current, int target) { if (root == null) { return; } current += root.val; if (current == target) { count++; // do not return. } helper(root.left, current, target); helper(root.right, current, target); } "],
["binary-tree-preorder-traversal-leet-code-144-medium.html", "4.12 Binary Tree Preorder Traversal / Leet Code 144 / Medium", " 4.12 Binary Tree Preorder Traversal / Leet Code 144 / Medium 4.12.1 Description Given a binary tree, return the preorder traversal of its nodes’ values. 4.12.2 Example Figure 4.16: Some caption. Output: [1,2,4,5,3] 4.12.3 Solution - Iterative I 4.12.3.1 Walkthrough For iterative solution, use a stack to store the root node that will be used to retrieve root.right for later use. For initial loop condiition, be sure to include (root != null) to make sure loop starts since stack initially is empty. 4.12.3.2 Analysis Time complexity is O(n) as every node is visited once. #### Algorithm 4.12.3.3 Java Code - Iterative I public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); //stack is used to store the root node that will be used access root.right later Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(!stack.isEmpty() || root != null) { if(root != null) { stack.push(root); result.add(root.val); // Add before going to children root = root.left; } else { root = stack.pop().right; } } return result; } 4.12.4 Solution - Iterative II 4.12.4.1 Walkthrough To convert an inherently recursive procedures to iterative, we need an explicit stack, and do following while the stack is not empty: Pop an item from stack and process it. Push of popped item to stack Push of popped item to stack Since stack is a LIFO, when the right child node is pushed before the left child node to a stack, the left child node would be processed before the right child node. 4.12.4.2 Analysis Time complexity is O(n) as every node is visited once. 4.12.4.3 Algorithm 4.12.4.4 Java Code - Iterative II public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); //stack is used to store the root node that will be used access root.right later Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if (root == null) { return result; } stack.push(root); while (!stack.empty()) { Node node = nodeStack.pop(); result.add(node.val); // Push the RIGHT child of the popped node to stack if (node.right != null) { stack.push(node.right); } // Push the LEFT child of the popped node to stack if (node.left != null) { stack.push(node.left); } } return result; } 4.12.5 Solution - Recursive 4.12.5.1 Walkthrough For recursive implementation, do the following step To process data at current node Recursively invoke left child node. Recursively invoke right child node. 4.12.5.2 Analysis Time complexity is O(n) as every node is visited once. Auxiliary Space is O(1) if we do not consider the size of stacks for function calls, otherwise O(n). 4.12.5.3 Algorithm dfs 1.2.1 4.12.5.4 Java Code - Recursive public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); traversalHelper(root, result); return result; } public void traversalHelper(TreeNode root, List&lt;Integer&gt; list) { if(root == null) { return; } list.add(root.val); traversalHelper(root.left, list); traversalHelper(root.right, list); } "],
["binary-tree-inorder-traversal-leet-code-94-medium.html", "4.13 Binary Tree Inorder Traversal / Leet Code 94 / Medium", " 4.13 Binary Tree Inorder Traversal / Leet Code 94 / Medium 4.13.1 Description Given a binary tree, return the inorder traversal of its nodes’ values. 4.13.2 Example Figure 4.17: Some caption. Output: [4, 2, 5, 1, 3] 4.13.3 Solution - Iterative I 4.13.3.1 Walkthrough For iterative solution, use a stack to store the root node that will be used to retrieve root.right for later use. For initial loop condiition, be sure to include (root != null) to make sure loop starts since stack initially is empty. 4.13.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.13.3.3 Algorithm 4.13.3.4 Java Code - Iterative I public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); //stack is used to store the root node that will be used access root.right later Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(!stack.isEmpty() || root != null) { if(root != null) { stack.push(root); root = root.left; } else { root = stack.pop(); result.add(root.val); root = root.right; } } return result; } 4.13.4 Solution - Inorder Recursive 4.13.4.1 Walkthrough For recursive implementation, do the following step Recursively invoke left child node. To process data at current node Recursively invoke right child node. 4.13.4.2 Analysis Time complexity is O(n) as every node is visited once. Auxiliary Space is O(1) if we do not consider the size of stacks for function calls, otherwise O(n). 4.13.4.3 Algorithm dfs 1.2.1 4.13.4.4 Java Code - Inorder Recursive public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); traversalHelper(root, result); return result; } public void traversalHelper(TreeNode root, List&lt;Integer&gt; list) { if(root == null) { return; } traversalHelper(root.left, list); list.add(root.val); traversalHelper(root.right, list); } "],
["binary-tree-postorder-traversal-leet-code-145-hard.html", "4.14 Binary Tree Postorder Traversal / Leet Code 145 / Hard", " 4.14 Binary Tree Postorder Traversal / Leet Code 145 / Hard 4.14.1 Description Given a binary tree, return the postorder traversal of its nodes’ values. 4.14.2 Example Figure 4.18: Some caption. Output: [4, 5, 2, 3, 1] 4.14.3 Solution - Iterative I 4.14.3.1 Walkthrough For iterative solution, use a stack to store the root node that will be used to retrieve root.right for later use. For initial loop condiition, be sure to include (root != null) to make sure loop starts since stack initially is empty. 4.14.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.14.3.3 Algorithm 4.14.3.4 Java Code - Iterative I public List&lt;Integer&gt; postorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); //stack is used to store the root node that will be used access root.right later Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(!stack.isEmpty() || root != null) { if(root != null) { stack.push(root); //insert to head result.add(0, root.val); root = root.right; } else { root = stack.pop().left; } } return result; } 4.14.4 Solution - Iterative with Two Stacks 4.14.4.1 Walkthrough The idea is to push reverse postorder traversal to a stack. Once we have the reversed postorder traversal in a stack, we can just pop all items one by one from the stack and process them; this order will be in postorder because of the LIFO property of stacks. To get a reversed postorder elements in a stack - the second stack is used for this purpose, this sequence is very similar to the preorder traversal. The only difference is that the right child is visited before left child, and therefore the sequence is “root right left” instead of “root left right”. 4.14.4.2 Analysis Time complexity is O(n) as every node is visited once. 4.14.4.3 Algorithm 4.14.4.4 Java Code - Iterative with Two Stacks public List&lt;Integer&gt; postorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack1 = new Stack&lt;&gt;(); //stack2 is used to store the reversed postorder elements in a stack Stack&lt;TreeNode&gt; stack2 = new Stack&lt;&gt;(); if (root == null) { return result; } stack.push(root); while (!stack1.isEmpty()) { // Pop an item from stack1 and push it to stack2 TreeNode node = stack1.pop(); stack2.push(node); // Push LEFT child of popped item to stack1 if (node.left != null) { stack1.push(node.left); } // Push RIGHT child of popped item to stack1 if (node.right != null) { stack1.push(node.right); } } //Traverse all reversed elements in second stack while (!stack2.isEmpty()) { TreeNode node = stack2.pop(); result.add(node.val) } return result; } 4.14.5 Solution - Recursive 4.14.5.1 Walkthrough For recursive implementation, do the following step Recursively invoke left child node. Recursively invoke right child node. To process data at current node 4.14.5.2 Analysis Time complexity is O(n) as every node is visited once. Auxiliary Space is O(1) if we do not consider the size of stacks for function calls, otherwise O(n). 4.14.5.3 Algorithm dfs 1.2.1 4.14.5.4 Java Code - Recursive public List&lt;Integer&gt; postorderTraversal(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); traversalHelper(root, result); return result; } public void traversalHelper(TreeNode root, List&lt;Integer&gt; list) { if(root == null) { return; } traversalHelper(root.left, list); traversalHelper(root.right, list); list.add(root.val); } "],
["maximum-depth-of-binary-tree-leet-code-104-easy.html", "4.15 Maximum Depth of Binary Tree / Leet Code 104 / Easy", " 4.15 Maximum Depth of Binary Tree / Leet Code 104 / Easy 4.15.1 Description Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 4.15.2 Example Figure 4.19: Some caption. return its depth = 3. 4.15.3 Solution 4.15.3.1 Walkthrough Recursively for each level: Take the larger depth of left and right subtree. add one for current level 4.15.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.15.3.3 Algorithm recursion 1.2.5 4.15.3.4 Java Code public int maxDepth(TreeNode root) { if(root == null) { return 0; } int lHeight = 0, rHeight = 0; if(root.left != null) { lHeight = maxDepth(root.left); } if(root.right != null) { rHeight = maxDepth(root.right); } return Math.max(lHeight, rHeight) + 1; } "],
["minimum-depth-of-binary-tree-leet-code-104-easy.html", "4.16 Minimum Depth of Binary Tree / Leet Code 104 / Easy", " 4.16 Minimum Depth of Binary Tree / Leet Code 104 / Easy 4.16.1 Description Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. 4.16.2 Example Figure 4.20: Some caption. return its minimum depth = 2. 4.16.3 Solution - Recursive 4.16.3.1 Walkthrough If a node has a missing child (depth is 0 ), then we need to drill down to the other path to the leaf node recursively. If both nodes exist, take the minimum value out of the left and right subtree. 4.16.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.16.3.3 Algorithm dfs 1.2.1 4.16.3.4 Java Code - Recursive public int minDepth(TreeNode root) { if(root == null) { return 0; } if(root.left == null) { //drill down to leaf node of the other path return minDepth(root.right) + 1; } else if(root.right == null) { //drill down to leaf node of the other path return minDepth(root.left) + 1; } else { return Math.min(minDepth(root.left), minDepth(root.right)) + 1; } } 4.16.4 Solution - Iterative BFS 4.16.4.1 Walkthrough Iterative: With BFS strategy, use two queues. One for current level and the other for next level. While traversing the currentLevel queue, add left and right children to the nextLevel queue. If currentLevel is empty, switch to nextLevel by currentLevel=nextLevel and nextLevel = new Queue(); Also, increment depth by 1 4.16.4.2 Analysis Time complexity is O(n) as every node is visited once. 4.16.4.3 Algorithm bfs 1.2.2 4.16.4.4 Java Code - Iterative BFS public int minDepth(TreeNode root) { if(root == null) { return 0; } Queue&lt;TreeNode&gt; currentLevel = new LinkedList&lt;&gt;(); Queue&lt;TreeNode&gt; nextLevel = new LinkedList&lt;&gt;(); currentLevel.offer(root); int depth = 1; while(!currentLevel.isEmpty()) { TreeNode node = currentLevel.poll(); if(node.left == null &amp;&amp; node.right == null) { return depth; } if(node.left != null) { nextLevel.offer(node.left); } if(node.right != null) { nextLevel.offer(node.right); } //go to children level by swapping queues, increase depth if(currentLevel.isEmpty()) { currentLevel = nextLevel; nextLevel = new LinkedList&lt;&gt;(); depth++; } } return depth; } "],
["count-univalue-subtrees-leet-code-250-medium.html", "4.17 Count Univalue Subtrees / Leet Code 250 / Medium", " 4.17 Count Univalue Subtrees / Leet Code 250 / Medium 4.17.1 Description Given a binary tree, count the number of uni-value subtrees. A Uni-value subtree means all nodes of the subtree have the same value. 4.17.2 Example Figure 4.21: Some caption. return 4. 4.17.3 Solution 4.17.3.1 Walkthrough There are scenarios that returns true Recursively validate left node.val and right node.val == root.val A leaf node In addition, we need to store accumulated count across recursive function calls. Thus, data type cannot be Immutable, since each arithmetic operation would create another object. Thus, we need to have a mutable variable that exists across each stack frame: Have a int[1] to store the accumulated count. Have a wrapper object to reset the value towards computation. Have a shared variable declared for this purpose. 4.17.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.17.3.3 Algorithm dfs 1.2.1 4.17.3.4 Java Code int count = 0; public int countUnivalSubtrees(TreeNode root) { helper(root, count); return count; } boolean helper(TreeNode root) { if (root == null) { return true; } boolean left = helper(root.left); boolean right = helper(root.right); if (left &amp;&amp; right) { //validate left subtree if (root.left != null &amp;&amp; root.left.val != root.val) { return false; } // validate right subtree if (root.right != null &amp;&amp; root.right.val != root.val) { return false; } count++; return true; } else { return false; } } "],
["validate-binary-search-tree-leet-code-98-medium.html", "4.18 Validate Binary Search Tree / Leet Code 98 / Medium", " 4.18 Validate Binary Search Tree / Leet Code 98 / Medium 4.18.1 Description Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. 4.18.2 Example Figure 4.22: Some caption. Output: true Figure 4.23: Some caption. Output: false. Explanation: The root node’s value is 5 but its right child’s value is 4. 4.18.3 Solution - Recursive 4.18.3.1 Walkthrough For recursive, define a numeric lower and upper bounds for each validation - initially, (long) (Integer.MIN_VALUE - 1) and (long) (Integer.MAX_VALUE + 1). Recursively validate the node boundary by replacing with left and right nodes. 4.18.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.18.3.3 Algorithm dfs 1.2.1 4.18.3.4 Java Code - Recursive public boolean isValidBST(TreeNode root) { return isValidBST(root, (long) Integer.MIN_VALUE - 1, (long) Integer.MAX_VALUE + 1); } public boolean isValidBST(TreeNode root, long lowerBound, long upperBound) { if(root == null) { return true; } else { boolean result = root.val &gt; lowerBound &amp;&amp; root.val &lt; upperBound; return result &amp;&amp; isValidBST(root.left, lowerBound, root.val) &amp;&amp; isValidBST(root.right, root.val, upperBound); } } 4.18.4 Solution - Iterative BFS 4.18.4.1 Walkthrough For iterative, we have a wrapper to hold upper and lower bounds for each nodes. Use BFS to iteratively traverse the tree and add left or right nodes with proper boundaries accordingly. 4.18.4.2 Analysis Time complexity is O(n) as every node is visited once. 4.18.4.3 Algorithm bfs 1.2.2 4.18.4.4 Java Code - Iterative BFS //Decorator pattern private static class BoundedTreeNode extends TreeNode { int upper; int lower; TreeNode proxy; BoundedTreeNode(TreeNode node, int max, int min) { this.proxy = node; this.upper = max; this.lower = min; } } public static boolean validateBSTItr(TreeNode root) { if(root == null) { return true; } Queue&lt;BoundedTreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(new BoundedTreeNode(root, Integer.MAX_VALUE, Integer.MIN_VALUE)); while(!queue.isEmpty()) { BoundedTreeNode node = queue.poll(); if(node.proxy.data &gt; node.upper || node.proxy.data &lt; node.lower) { // out of boundary return false; } if(node.proxy.left != null) { queue.offer(new BoundedTreeNode(node.proxy.left, node.proxy.data, node.lower)); } if(node.proxy.right != null) { queue.offer(new BoundedTreeNode(node.proxy.right, node.upper, node.proxy.data)); } } return true; } "],
["binary-tree-upside-down-leet-code-156-medium.html", "4.19 Binary Tree Upside Down / Leet Code 156 / Medium", " 4.19 Binary Tree Upside Down / Leet Code 156 / Medium 4.19.1 Description Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root. 4.19.2 Example Figure 4.24: Some caption. return the root of the binary tree Figure 4.25: Some caption. 4.19.3 Solution 4.19.3.1 Walkthrough The newRoot of a flipped tree will be root.left that is Figure 4.26: Some caption. flips to Figure 4.27: Some caption. Additionally, we need to properly place the children of root.left. 4.19.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.19.3.3 Algorithm dfs 1.2.1 4.19.3.4 Java Code public TreeNode upsideDownBinaryTree(TreeNode root) { if(root == null || root.left == null) { return root; } TreeNode newRoot = upsideDownBinaryTree(root.left); //children of root.left root.left.left = root.right; root.left.right = root; root.left = null; root.right = null; return newRoot; } "],
["inorder-successor-in-bst-leet-code-285-medium.html", "4.20 Inorder Successor in BST / Leet Code 285 / Medium", " 4.20 Inorder Successor in BST / Leet Code 285 / Medium 4.20.1 Description Given a binary search tree and a node in it, find the in-order successor of that node in the BST. Note: If the given node has no in-order successor in the tree, return null. 4.20.2 Example 4.20.3 Solution 4.20.3.1 Walkthrough 4.20.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.20.3.3 Algorithm bfs 1.2.2 4.20.3.4 Java Code public TreeNode inorderSuccessor(TreeNode root, TreeNode p) { Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); TreeNode node = null, prev = null; while (!stack.isEmpty() || node != null) { if (node != null) { stack.push(node); node = node.left; } else { node = stack.pop(); if (prev == p) { return node; } prev = node; node = node.right; } } return null; } "],
["binary-tree-longest-consecutive-sequence-leet-code-298-medium.html", "4.21 Binary Tree Longest Consecutive Sequence / Leet Code 298 / Medium", " 4.21 Binary Tree Longest Consecutive Sequence / Leet Code 298 / Medium 4.21.1 Description Given a binary tree, find the length of the longest consecutive sequence path. The path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path need to be from parent to child (cannot be the reverse). 4.21.2 Example Figure 4.28: Some caption. Longest consecutive sequence path is 3-4-5, so return 3. Figure 4.29: Some caption. Longest consecutive sequence path is 2-3,not3-2-1, so return 2. 4.21.3 Solution 4.21.3.1 Walkthrough For each recursive call, if root.val == target, length++ otherwise, reset length = 1 Retrieve for the maximum length and recursively call on left and right subtrees with increasing sequence (root.val + 1). If we want longest increaing sequence, change to (root.val &gt;= target) to verify increasing sequence. 4.21.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.21.3.3 Algorithm dfs 1.2.1 4.21.3.4 Java Code private int longest; public int longestConsecutive(TreeNode root) { if (root == null) { return 0; } longestConsecutive(root, 0, root.val); return longest; } public void longestConsecutive(TreeNode root, int length, int target) { if (root == null) { return; } else if (root.val == target) { length++; } else { length = 1; } longest = Math.max(longest, length); //root.val + 1 for increasing sequencef longestConsecutive(root.left, length, root.val + 1); longestConsecutive(root.right, length, root.val + 1); } "],
["find-leaves-of-binary-tree-leet-code-366-medium.html", "4.22 Find Leaves of Binary Tree / Leet Code 366 / Medium", " 4.22 Find Leaves of Binary Tree / Leet Code 366 / Medium 4.22.1 Description Given a binary tree, collect a tree’s nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty. 4.22.2 Example Figure 4.30: Some caption. Returns [4, 5, 3], [2], [1]. 4.22.3 Solution 4.22.3.1 Walkthrough For each node, compute maximum level (leaf node is -1) out of recursive call to left and right subtree + 1. If level increases, add a new list and add the node.val into the list – list.add(node.val) 4.22.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.22.3.3 Algorithm dfs 1.2.1 4.22.3.4 Java Code public List&lt;List&lt;Integer&gt;&gt; findLeaves(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;List&lt;Integer&gt;&gt;(); helper(root, result); return result; } private int helper(TreeNode root, List&lt;List&lt;Integer&gt;&gt; result) { if (root == null) { return -1; } int level = Math.max(helper(root.left, result), helper(root.right, result)) + 1; //add a new level if level increases if (result.size() &lt;= level) { result.add(new LinkedList&lt;Integer&gt;()); } //add root.val result.get(level).add(root.val); return level; } "],
["diameter-of-binary-tree-leet-code-543-easy.html", "4.23 Diameter of Binary Tree / Leet Code 543 / Easy", " 4.23 Diameter of Binary Tree / Leet Code 543 / Easy 4.23.1 Description Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. 4.23.2 Example Given a binary tree Figure 4.31: Some caption. Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. Note: The length of path between two nodes is represented by the number of edges between them. 4.23.3 Solution 4.23.3.1 Walkthrough Have a help function to compute the left and right height as well as diameter (left height + right height). Find the maximum diameter among root, left and right. 4.23.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.23.3.3 Algorithm dfs 1.2.1 4.23.3.4 Java Code public int diameterOfBinaryTree(TreeNode root) { int[] result = diameterAndHeight(root); return result[0]; } public int[] diameterAndHeight(TreeNode root) { int heightDiameter[] = { 0, 0 }; // initialize the diameter and height if (root != null) { int[] leftResult = diameterAndHeight(root.left); int[] rightResult = diameterAndHeight(root.right); int height = Math.max(leftResult[1], rightResult[1]) + 1; int leftDiameter = leftResult[0]; int rightDiameter = rightResult[0]; int rootDiameter = leftResult[1] + rightResult[1]; int finalDiameter = Math.max(rootDiameter, Math.max(leftDiameter, rightDiameter)); heightDiameter[0] = finalDiameter; heightDiameter[1] = height; } return heightDiameter; } "],
["binary-tree-serialization-firecode-level-3.html", "4.24 Binary Tree Serialization / Firecode / Level 3", " 4.24 Binary Tree Serialization / Firecode / Level 3 4.24.1 Description In Computer Science, serialization is the process of converting objects or data structures into a sequence (or series) of characters that can be stored easily in a file / database table or transmitted across a network. Serialized objects need to be de-serialized to create a semantically identical clone of the original object, before being used in programs. You’re given the root node of a binary tree - TreeNode root in the method serializeTree. This method should serialize the binary tree and output a String str, which is then used as an input parameter for the method restoreTree. restoreTree should create a Binary Tree that is structurally identical to the one you serialized and return the root node of the tree. Your task is to fill in the logic for these 2 methods. Don’t worry about passing the serialized String to restoreTree - that will be done automatically when you run your code. Feel free to use any notation you prefer when serializing the binary tree. The choice of traversal algorithm is also open - but try and limit the time complexity of both methods to O(n). 4.24.2 Example 4.24.3 Solution 4.24.3.1 Walkthrough Your serialized String will be used to restore the tree. Be sure to use the same format and notation in restoreTree that you use to serialize in serializeTree. For example, the following binary tree Figure 4.32: Some caption. would be serialize into string “1 2 4 # # 5 # # 3 # #”. 4.24.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.24.3.3 Algorithm dfs 1.2.1 4.24.3.4 Java Code public String serializeTree(TreeNode root){ StringBuilder sb = new StringBuilder(); if (root == null) { sb.append(&quot;# &quot;); } else { sb.append(root.data + &quot; &quot;); sb.append(serializeTree(root.left)); sb.append(serializeTree(root.right)); } return sb.toString(); } public TreeNode restoreTree(String str){ if (str == null || str.length() == 0) { return null; } StringTokenizer tokenizer = new StringTokenizer(str, &quot; &quot;); return deserialize(tokenizer); } private TreeNode deserialize(StringTokenizer tokenizer){ if (!tokenizer.hasMoreTokens()) { return null; } String val = tokenizer.nextToken(); if (val.equals(&quot;#&quot;)) { return null; } TreeNode root = new TreeNode(Integer.parseInt(val)); root.left = deserialize(tokenizer); root.right = deserialize(tokenizer); return root; } "],
["fill-in-the-ancestors-of-the-node-in-a-binary-tree-firebase-level-3.html", "4.25 Fill in the Ancestors of the Node in a Binary Tree / Firebase / Level 3", " 4.25 Fill in the Ancestors of the Node in a Binary Tree / Firebase / Level 3 4.25.1 Description Given a binary tree’s root node, an empty ArrayList and an integer nodeData, write a method that finds a target node - N with data = nodeData and populates the ArrayList with the data of the ancestor nodes of N - added from the bottom - up 4.25.1.1 Algorithm dfs 1.2.1, backtrack 1.2.6 4.25.2 Example Figure 4.33: Some caption. Node: 5 = [2, 1] 4.25.3 Solution 4.25.3.1 Walkthrough We use an arrayList to keep the current path of TreeNode visited, also TreeNode to be removed for backtracking purposes. We use recurisve call and terminate on leave nodes as well as target node is found. The recursive function returns a boolean value when the target node / value is found on the subtree path. 4.25.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.25.3.3 Algorithm dfs 1.2.1, backtrack 1.2.6 4.25.3.4 Java Code public ArrayList&lt;Integer&gt; ancestorsList = new ArrayList&lt;Integer&gt;(); public boolean printAncestors(TreeNode root, int nodeData) { if(root == null) { return false; } if(root.data == nodeData) { return true; } else { ancestorsList.add(0, root.data); boolean isRightSubtree = printAncestors(root.left, nodeData) || printAncestors(root.right, nodeData); if(!isRightSubtree) { //remove the backtrack nodes ancestorsList.remove(0); } return isRightSubtree; } } "],
["find-the-kth-largest-node-in-a-bst-firecode-level-3.html", "4.26 Find the \\(k^{th}\\) Largest Node in a BST / Firecode / Level 3", " 4.26 Find the \\(k^{th}\\) Largest Node in a BST / Firecode / Level 3 4.26.1 Description Given a Binary Search Tree and an integer k, implement a method to find and return its \\(k^{th}\\) largest node 4.26.2 Example Figure 4.34: Some caption. In the above scenario, if k = 1, then the output is 10 i.e. k = 1, represents the largest element of the tree, k = 2, represents the second largest element and so on. 4.26.3 Solution 4.26.3.1 Walkthrough First we compute the size of right subtree, and evaluate the following possibilities if k == (sizeOfRightSubtree + 1), return this node if k \\(&lt;\\) sizeOfRightSubtree, the target must reside in the right subtree. Drill down to right subtree if k \\(&gt;\\) sizeOfRightSubtree, the target must reside in the left subtree. Drill down to the left subtree and change target position to (k - sizeOfRightSubtree - 1) 4.26.3.2 Analysis Time complexity is O(log(n)) as a certain path of nodes will be visited since this is a BST. 4.26.3.3 Algorithm dfs 1.2.1, bst 1.2.11 4.26.3.4 Java Code public TreeNode findKthLargest(TreeNode root, int k) { if(root == null) { return null; } int rightSubtreeSize = size(root.right); if( (rightSubtreeSize + 1) == k) { return root; } else if( rightSubtreeSize &gt; k ) { //drill down to the right subtree return findKthLargest(root.right, k); } else { //drill down to the left subtree return findKthLargest(root.left, k - rightSubtreeSize - 1); } } "],
["convert-sorted-array-to-binary-search-tree-leet-code-108-easy.html", "4.27 Convert Sorted Array to Binary Search Tree / Leet Code 108 / Easy", " 4.27 Convert Sorted Array to Binary Search Tree / Leet Code 108 / Easy 4.27.1 Description Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1 4.27.2 Example Figure 4.35: Some caption. 4.27.3 Solution 4.27.3.1 Walkthrough To create a tree of minimal height, we need to mathch the number of nodes in the left subtree to the number of the nodes in the right subtree as much as possible. This means that we want the root to be the middle of the array, since this would mean that half the elements would be less than the root and half wood be greater than it. 4.27.3.2 Analysis The overal time complexity is O(n) as every node is visited once. 4.27.3.3 Algorithm dfs 1.2.1 4.27.3.4 Java Code public TreeNode sortedArrayToBST(int[] nums) { return buildHeightBalancedBST(nums, 0, nums.length -1); } public TreeNode buildHeightBalancedBST(int[] nums, int start, int end) { if(start &gt; end) { return null; } int mid = (start + end) / 2; TreeNode node = new TreeNode(nums[mid]); node.left = buildHeightBalancedBST(nums, start, mid - 1); node.right = buildHeightBalancedBST(nums, mid + 1, end); return node; } "],
["populating-next-right-pointers-in-each-node-leet-code-116-medium.html", "4.28 Populating Next Right Pointers in Each Node / Leet Code 116 / Medium", " 4.28 Populating Next Right Pointers in Each Node / Leet Code 116 / Medium 4.28.1 Description You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. 4.28.2 Example 4.28.3 Solution 4.28.3.1 Walkthrough 4.28.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.28.3.3 Algorithm dfs 1.2.1 4.28.3.4 Java Code - PreOrder Recursive public Node connect(Node root) { if(root == null){ return root; } if(root.left == null) { return root; } // populate left child.next =&gt; right child root.left.next=root.right; // previously populated, i.e. root(2) if(root.next != null){ //root.next = 3 which connects to another branch root.right.next=root.next.left; } connect(root.left); connect(root.right); return root; } "],
["construct-binary-tree-from-preorder-and-inorder-traversal-leet-code-105-medium.html", "4.29 Construct Binary Tree from Preorder and Inorder Traversal / Leet Code 105 / Medium", " 4.29 Construct Binary Tree from Preorder and Inorder Traversal / Leet Code 105 / Medium 4.29.1 Description Given preorder and inorder traversal of a tree, construct the binary tree. You may assume that duplicates do not exist in the tree. 4.29.2 Example preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree: Figure 4.36: Some caption. 4.29.3 Solution 4.29.3.1 Walkthrough PreOrder array is used to construct data value of a node, whereas InOrder array is used to acknowledge the left and right boundary of a node. We could use a Map to store the InOrder array associated with its index (position in array) value and biuld tree according to the following conditions: if startIdx \\(&gt;\\) endIdx Return null. (Terminal) if startIdx \\(==\\) endIdx The node is here. (Terminal) if startIdx \\(&gt;\\) endIdx There should be more nodes in this branch. 4.29.3.2 Analysis Time complexity is O(n) as every node is visited once. 4.29.3.3 Algorithm dfs 1.2.1 4.29.3.4 Java Code - PreOrder Recursive int preorderIndex = 0; public TreeNode buildTree(int[] preorder, int[] inorder) { if (preorder.length == 0) { return null; } Map&lt;Integer, Integer&gt; inorderIndex = new HashMap&lt;&gt;(); for (int i = 0; i &lt; inorder.length; i++) { inorderIndex.put(inorder[i], i); } return buildTree(preorder, inorderIndex, 0, inorder.length - 1); } private TreeNode buildTree(int[] preorder, Map&lt;Integer, Integer&gt; inorderIndex, int startIdx, int endIdx) { if (startIdx &gt; endIdx) { return null; } int val = preorder[preorderIndex++]; TreeNode node = new TreeNode(val); if (startIdx == endIdx) { return node; } int inIndex = inorderIndex.get(val); node.left = buildTree(preorder, inorderIndex, startIdx, inIndex - 1); node.right = buildTree(preorder, inorderIndex, inIndex + 1, endIdx); return node; } "],
["graph.html", "Chapter 5 Graph", " Chapter 5 Graph Imagine a graph with as the following: 1 -- 0 -- 4 | 5 -- 6 | / | \\ | / | \\ 2 -- 3 -- 7 An adjacency list is created with an array of lists. Size of the array is equal to the number of vertices. Each entry represents the list of vertices adjacent to the \\(i^{th}\\) vertex. Each node maintains a list of all its adjacent edges, then, for each node, you could discover all its neighbors by traversing its adjacency list just once in linear time. | 0 | -- 1 -- 4 | 1 | -- 0 -- 5 | 2 | -- 3 -- 5 -- 6 | 3 | -- 2 -- 6 -- 7 | 4 | -- 0 | 5 | -- 1 -- 2 -- 6 | 6 | -- 2 -- 3 -- 5 -- 7 | 7 | -- 3 -- 6 The adjacency information can also transform into matrix form with the convention followed here (for undirected graphs) is that each edge adds 1 to the appropriate cell in the matrix, and each loop adds 2. For each node, you have to traverse an entire row of length V in the matrix to discover all its outgoing edges. 0, 1, 0, 0, 1, 0, 0, 0 1, 0, 0, 0, 0, 1, 0, 0 0, 0, 0, 1, 0, 1, 1, 0 0, 0, 1, 0, 0, 0, 1, 1 1, 0, 0, 0, 0, 0, 0, 0 0, 1, 1, 0, 0, 0, 1, 0 0, 0, 1, 1, 0, 1, 0, 1 0, 0, 0, 1, 0, 0, 1, 0 In addition, a “visited” array that we’ll use to keep track of which vertices have been visited. class Graph { private int numOfVertices; //No. of vertices private List&lt;Integer&gt; adj[]; //Adjacency List private boolean[] visited; //visited mark for each vertex // Constructor public Graph(int num) { numOfVertices = num; adj = new LinkedList[v]; for (int i=0; i&lt;numOfVertices; ++i) { adj[i] = new LinkedList(); } } ... } There is an alternative implementation to represent per node with a list of adjacent nodes. class Node { public int val; public List&lt;Node&gt; neighbors; private boolean visited; //visited mark for the vertex public Node(int _val, List&lt;Node&gt; _neighbors) { val = _val; neighbors = _neighbors; } ... } 5.0.1 Depth First Traversal A depth first traversal without labeling the visited node usually ends up in exponential time complexity. There will be many subproblems being reevaluated (which were visited in past). Thus, the time complexity is \\(O(2^{h+1} - 1)\\) (as a full binary tree) If your graph is implemented as an adjacency matrix, then, for each node, you have to traverse an entire row of length V in the matrix to discover all its outgoing edges. So, the complexity of DFS is \\(O(|V| * |V|) = O(|V|^2)\\). If your graph is implemented using adjacency lists, wherein each node maintains a list of all its adjacent edges, then, for each node, you could discover all its neighbors by traversing its adjacency list just once in linear time. For a directed graph, the sum of the sizes of the adjacency lists of all the nodes is E (total number of edges). So, the complexity of DFS is O(V) + O(E) = O(V + E). For an undirected graph, each edge will appear twice. Once in the adjacency list of either end of the edge. So, the overall complexity will be \\(O(|V|) + O (2\\cdot |E|) = O(|V + E|)\\). 5.0.1.1 Algorithm dfs 1.2.1 void helper(int node, boolean visited[]) { // Mark the current node as visited and print it visited[node] = true; // Recur for all the vertices adjacent to this vertex for(Integer adjNode: adj[node]) { if (!visited[adjNode]) { helper(adjNode, visited); } } } // The function to do DFS traversal. It uses recursive DFSUtil() void dfs(int root) { // Mark all the vertices as not visited(set as // false by default in java) boolean visited[] = new boolean[numOfVertices]; helper(root, visited); } 5.0.2 Bread First Traversal For every single vertex in the graph, we will end up looking at its neighboring nodes only once (directed graph) or twice (undirected graph). The time complexity for both a directed and undirected graph is the sum of the vertices and their edges as represented by the graph in its adjacency list representation, or \\(O(|V| + |E|)\\) The power of using breadth-first search to traverse through a graph is that it can easily tell us the shortest way to get from one node to another. 5.0.2.1 Algorithm bfs 1.2.2 class Graph { private int numOfVertices; // No. of vertices private LinkedList&lt;Integer&gt; adj[]; //Adjacency Lists ... void traversal(Integer root) { // Mark all the vertices as not visited(By default // set as false) boolean visited[] = new boolean[numOfVertices]; // Create a queue for BFS Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); // Mark the current node as visited and enqueue it visited[root] = true; queue.offer(root); while (queue.size() != 0) { // Dequeue a vertex from queue and print it Integer node = queue.poll(); // Get all adjacent vertices of the dequeued vertex s // If a adjacent has not been visited, then mark it // visited and enqueue it for(Integer adjNode : adj[node]) { if (!visited[adjNode] &amp;&amp; !queue.contain(adjNode)) { queue.offer(adjNode); } } } } } 5.0.3 Topological Sorting A traversal algorithm for is a linear ordering of vertices such that for every directed edge \\([u,v]\\), vertex u comes before v in the ordering. In DFS implementation of Topological Sort we focused on sink vertices, i.e, vertices with zero out-going edges, and then at last had to reverse the order in which we got the (which we did by using a stack, which is a Last In First Out data structure). A DAG has to have at least one sink vertex which is the vertex which has no outbound edges. In DFS we print the nodes as we see them, which means when we print a node, it has just been discovered but not yet processed, which means it is in the Visiting state. So DFS gives the order in which the nodes enter the Visiting state and not the Visited state. For topological sorting we need to have the order in which the nodes are completely processed, i.e, the order in which the nodes are marked as Visited. Because when a node is marked Visited then all of its child node have already been processed, so they would be towards the right of the child nodes in the topological sort, as it should be. For example, in the given graph, the vertex ‘5’ should be printed before vertex ‘0’, but unlike DFS, the vertex ‘4’ should also be printed before vertex ‘0’. 5 -&gt; 0 &lt;- 4 | | v v 2 -&gt; 3 -&gt; 1 In topological sorting, we use a temporary stack. We don’t print the vertex immediately, we first recursively call topological sorting for all its adjacent vertices, then push it to a stack. Finally, print contents of stack. The final sequence is [5, 4, 2, 3, 1, 0] 5.0.3.1 Algorithm topological \\@ref(topological), dfs \\@ref(dfs) void helper(Integer v, Stack stack) { visited[v] = true; // Recur for all the vertices adjacent to this // vertex Iterator&lt;Integer&gt; it = adj[v].iterator(); while (it.hasNext()) { Integer adjNode = it.next(); if (!visited[adjNode]) { helper(adjNode, visited, stack); } } // Push current vertex to stack which stores result stack.push(new Integer(v)); } List&lt;Integer&gt; topologicalSort(Graph graph) { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); // Call the recursive helper function to store // Topological Sort starting from all vertices // one by one for (int i = 0; i &lt; numOfVertices; i++) { if (visited[i] == false) { helper(i, visited, stack); } } //Now the stack contains the topological sorting of the graph for (Integer vertex : stack) { result.add(stack.pop()); } return result } In BFS implementation of the Topological sort we do the opposite: We look for for edges with no inbound edges (). And consequently in BFS implementation we don’t have to reverse the order in which we get the vertices, since we get the vertices in order of the topological ordering. We use First-In-First-Out data structure Queue in this implementation. We just search for the vertices with zero indegrees and put them in the queue till we have processed all the vertices of the graph. Polling vertices from the queue one by one give the topological sort of the graph. Lastly check if the result set does not contain all the vertices that means there is at least one cycle in the graph. That is because the indegree of those vertices participating in the loop could not be made 0 by decrementing. in-degree, out-degree 5.0.3.2 Algorithm topological 1.2.3, bfs 1.2.2 public List topological_sort_bfs(int[][] graph) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); int[] indegree = new int[numOfVertices]; // compute the indegree of all the vertices in the graph // For edge (0,1), indegree[1]++; for (int i = 0; i &lt; numOfVertices; i++) { for(Integer vertex : adj[i]) { indegree[vertex]++; } } Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); // initialize the queue with all the vertices with no inbound edges for (Integer vertex = 0; index &lt; numOfVertices; index++) { if (indegree[vertex] == 0) { queue.offer(vertex); } } while (!queue.isEmpty()) { Integer vertex = queue.poll(); result.add(vertex); // now disconnect vertex1 from the graph // and decrease the indegree of the other end of the edge by 1 for (Integer adjVertex : adj[i]) { indegree[adjVertex]--; if (indegree[adjVertex] == 0) { queue.offer(adjVertex); } } } // check if the graph had a cycle / loop if (result.size() != numOfVertices) { return new ArrayList&lt;Integer&gt;(); } return result; } "],
["graph-serialization.html", "5.1 Graph Serialization / /", " 5.1 Graph Serialization / / 5.1.1 Description Given the a node to a Graph, represent that Graph as a String in such a way that it may be translated back to a Graph using the generated String A Node contains an integer value and all of the node’s neighbors. ### Example N.A. 5.1.2 Solution 5.1.2.1 Walkthrough We use BFS to traverse the graph with a visited Set to avoid running into cycle, and add child node only on unvisited adjacent nodes. For serialization, we simply place current val as first element and adjacent nodes val at the same line for the following elements, i.e. current, adj1, adj2, adj3, ..etc. Therefore, there will be two occurrence for each node-pair (edges) in the serialized content. For deserialization, it is easier by first splitting the lines and splitting by the dilimter ‘,’ and finally reassemble the graph data structure. 5.1.2.2 Analysis The time complexity for both a directed and undirected graph is the sum of the vertices and their edges as represented by the graph in its adjacency list representation, or \\(O(|V| + |E|)\\) Graph: 1 Serialized Content: 1 Graph: 1 - 2 | | 3 - 5 | 4 Serialized Content: 1, 2, 3 2, 1, 5 3, 1, 5, 4 4, 3 5, 2, 3 5.1.2.3 Algorithm bfs 1.2.2 5.1.2.4 Java Code class Graph { private int numOfVertices; // No. of vertices private LinkedList&lt;Integer&gt; adj[]; //Adjacency Lists // Constructor Graph(int num) { numOfVertices = num; adj = new LinkedList[numOfVertices]; for (int i = 0; i &lt; numOfVertices; ++i) { adj[i] = new LinkedList(); } } // Function to add an edge into the graph from v1 to v2 public void addEdge(int v1, int v2) { adj[v1].add(v2); } public String serialize(Integer rootId) { StringBuilder stringBuilder = new StringBuilder(); if(adj.length &lt;= 0) { return &quot;&quot;; } boolean visited[] = new boolean[numOfVertices]; Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); // Mark the current node as visited and enqueue it queue.offer(rootId); while (queue.size() != 0) { Integer nodeId = queue.poll(); visited[nodeId]=true; stringBuilder.append(serializeNode(nodeId)); // Get all adjacent vertices of the dequeued vertex s // If a adjacent has not been visited, then mark it // visited and enqueue it for(Integer adjNodeId : adj[nodeId]) { if (!visited[adjNodeId] &amp;&amp; !queue.contains(adjNodeId)) { queue.offer(adjNodeId); } } } return stringBuilder.toString(); } private String serializeNode(int nodeId) { StringBuilder sb = new StringBuilder(); //serialize node and adjacency nodes sb.append(nodeId); for(Integer adjNodeId: adj[nodeId]) { sb.append(&quot;,&quot;); sb.append(adjNodeId); } sb.append(&quot;\\r\\n&quot;); return sb.toString(); } public Graph deserialize(String input) { String[] lines = input.split(&quot;\\r\\n&quot;); Graph graph = new Graph(lines.length); for(String line: lines) { String[] nodes = line.split(&quot;,&quot;); if(nodes.length &gt; 1) { int srcNodeId = Integer.parseInt(nodes[0]); //there are adjacent nodes for(int j = 1; j &lt; nodes.length; j++) { Integer dstNodeId = Integer.valueOf(nodes[j]); graph.addEdge(srcNodeId, dstNodeId); } } } return graph; } } "],
["distance-of-nearest-cell-having-1-in-a-binary-matrix.html", "5.2 Distance of nearest cell having 1 in a binary matrix", " 5.2 Distance of nearest cell having 1 in a binary matrix 5.2.1 Description Given a binary matrix of N x M, containing at least a value 1. The task is to find the distance of nearest 1 in the matrix for each cell. The distance is calculated as \\(|i_1 - i_2| + |j_1 - j_2|\\), where \\(i_1, j_1\\) are the row number and column number of the current cell and \\(i_2, j_2\\) are the row number and column number of the nearest cell having value 1. 5.2.2 Example Input: 0, 0, 0, 1 0, 0, 1, 1 0, 1, 1, 0 Output: 3, 2, 1, 0 2, 1, 0, 0 1, 0, 0, 1 5.2.3 Solution 5.2.3.1 Walkthrough Consider each cell as a node and each boundary between any two adjacent cells be an edge. Number each cell from 1 to N*M. Now, push all the node whose corresponding cell value is 1 in the matrix in the queue. Apply BFS using this queue to find the minimum distance of the adjacent node. 5.2.3.2 Analysis * Create a graph with adjacency list for all nodes from 1 to rows * cols. Time complexity is O(rows * cols) * Create an empty queue and 1 dimensional array of size (rows * cols) for visited[] and distance (init Integer.MAX) Time complexity is O(rows * cols) * For all nodes in the original matrix being 1, insert the associated node id into the queue and set the distance to 0. * Perform a BFS traversal of graph using above created queue. In BFS, we first explore immediate adjacent of all 1’s, then adjacent of adjacent and determine the minimum distance. Time complexity is O(rows * cols) since all elements will be visited once. Thus, the overall time complexity is O(rows * cols) 5.2.3.3 Algorithm bfs 1.2.2 5.2.3.4 Java Code class Graph { private int numOfVertices; // No. of vertices private LinkedList&lt;Integer&gt; adj[]; //Adjacency Lists // Constructor Graph(int[][] matrix) { int rows = matrix.length; int cols = matrix[0].length; if(matrix.length == 0) { return; } numOfVertices = rows * cols; adj = new LinkedList[numOfVertices]; for (int i = 0; i &lt; numOfVertices; ++i) { adj[i] = new LinkedList(); } } // Function to add an edge into the graph from v1 to v2 public void addEdge(int src, int dst) { adj[src].add(dst); } public void fillAdjacency(int[][] matrix) { int rows = matrix.length; int cols = matrix[0].length; for(int i = 0; i &lt; rows; i++) { for(int j = 0; j &lt; cols; j++) { int srcNodeId = this.computeNodeId(i, j, cols); int dstNodeId = -1; //adding left or right neighbor nodes, if there are any (cols &gt; 1) if(cols &gt; 1) { if (j == 0) { dstNodeId = this.computeNodeId(i, j + 1, cols); this.addEdge(srcNodeId, dstNodeId); } else if (j == cols - 1) { dstNodeId = this.computeNodeId(i, j - 1, cols); this.addEdge(srcNodeId, dstNodeId); } else { dstNodeId = this.computeNodeId(i, j - 1, cols); this.addEdge(srcNodeId, dstNodeId); dstNodeId = this.computeNodeId(i, j + 1, cols); this.addEdge(srcNodeId, dstNodeId); } } //adding above or below neighbor nodes, if there are any (rows &gt; 1) if(rows &gt; 1) { if (i == 0) { dstNodeId = this.computeNodeId(i + 1, j, cols); this.addEdge(srcNodeId, dstNodeId); } else if (i == rows - 1) { dstNodeId = this.computeNodeId(i - 1, j, cols); this.addEdge(srcNodeId, dstNodeId); } else { dstNodeId = this.computeNodeId(i - 1, j, cols); this.addEdge(srcNodeId, dstNodeId); dstNodeId = this.computeNodeId(i + 1, j, cols); this.addEdge(srcNodeId, dstNodeId); } } } } } private int computeNodeId(int i, int j, int cols) { // Example // [0][0] = 0 * 2 + 0 = 0 // [0][1] = 0 * 2 + 1 = 1 // [1][0] = 1 * 2 + 0 = 2 // [1][1] = 1 * 2 + 1 = 3 return i * cols + j; } private void init(Queue&lt;Integer&gt; queue, int[][] matrix, boolean[] visited, int[] dist) { //Traverse all matrix elements. If it is a 1, then insert associated node id into queue if(matrix.length == 0) { return; } int rows = matrix.length; int cols = matrix[0].length; for(int i = 0; i &lt; rows; i++) { for (int j = 0; j &lt; cols; j++) { int nodeId = computeNodeId(i, j, cols); if(matrix[i][j] == 1) { queue.offer(nodeId); visited[nodeId] = true; } else { dist[nodeId] = Integer.MAX_VALUE; } } } } public int[] bfs(int[][] matrix) { int[] dist = new int[numOfVertices]; boolean visited[] = new boolean[numOfVertices]; Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); // Mark the current node as visited and enqueue it init(queue, matrix, visited, dist); while (queue.size() != 0) { Integer nodeId = queue.poll(); // Get all adjacent vertices of the dequeued vertex s // If a adjacent has not been visited, then mark it // visited and enqueue it for (Integer adjNodeId : adj[nodeId]) { if (!visited[adjNodeId] ) { //find minimum value among adjaNodeId and its neighbors + 1 dist[adjNodeId] = Math.min(dist[adjNodeId], dist[nodeId] + 1); queue.offer(adjNodeId); visited[adjNodeId] = true; } } } return dist; } } "],
["clone-graph-leetcode-133-medium.html", "5.3 Clone Graph / LeetCode 133 / Medium", " 5.3 Clone Graph / LeetCode 133 / Medium 5.3.1 Description Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors. 5.3.2 Example 5.3.3 Solution - DFS 5.3.3.1 Walkthrough Have a map as cache to store the mapping between original and new node. Recursively walk through the each adjacent node and assign into the adjacency list if existed in cache; otherwise, recursively clone the node. 5.3.3.2 Analysis Since each edge will appear twice. Once in the adjacency list of either end of the edge. So, the overall complexity will be \\(O(|V|) + O(2 \\cdot |E|) = O(|V + E|)\\) 5.3.3.3 Algorithm dfs 1.2.1 5.3.3.4 Java Code //use this map to store original and cloned node. //also act as visited[] Map&lt;Node, Node&gt; map = new HashMap&lt;&gt;(); public Node cloneGraph(Node node) { map.put(node, new Node(node.val, new ArrayList&lt;Node&gt;())); for(Node neighbor: node.neighbors){ if(map.containsKey(neighbor)) { //if neighbor is cloned Node cloneNode = map.get(node); Node cloneNeighbor = map.get(neighbor); cloneNode.neighbors.add(cloneNeighbor); } else { //recursively clone and add the neighbor Node cloneNode = map.get(node); cloneNode.neighbors.add(cloneGraph(neighbor)); } } return map.get(node); } 5.3.4 Solution - BFS 5.3.4.1 Walkthrough We use BFS to traverse the graph with a map cache to store the original and cloned node. This cache can only be used as visited[]. 5.3.4.2 Analysis For every single vertex in the graph, we will end up visiting its neighboring nodes only twice. The time complexity is the sum of the vertices and their edges as represented by the graph in its adjacency list representation: \\(O(|V| + |E|)\\) 5.3.4.3 Algorithm bfs 1.2.2 5.3.4.4 Java Code public Node cloneGraph(Node root) { //use this map to store original and cloned node //also act as visited[] Map&lt;Node, Node&gt; map = new HashMap&lt;&gt;(); Queue&lt;Node&gt; queue = new ArrayDeque&lt;&gt;(); queue.offer(root); map.put(root, new Node(root.val, new ArrayList&lt;&gt;())); while (!queue.isEmpty()) { Node node = queue.poll(); for (Node neighbor : node.neighbors) { // neighbor node is not yet cloned if (!map.containsKey(neighbor)) { map.put(neighbor, new Node(neighbor.val, new ArrayList&lt;&gt;())); queue.offer(neighbor); } //assign the mapping righ tafter Node cloneNode = map.get(node); Node cloneNeighbor = map.get(neighbor); cloneNode.neighbors.add(cloneNeighbor); } } return map.get(root); } "],
["course-schedule-i-leetcode-207-medium.html", "5.4 Course Schedule I / LeetCode 207 / Medium", " 5.4 Course Schedule I / LeetCode 207 / Medium 5.4.1 Description There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? 5.4.2 Example 5.4.2.1 Example 1 Input: 2, [[1,0]] Output: true Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. 5.4.2.2 Example 2 Input: 2, [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. 5.4.3 Solution - Topological Sort via BFS 5.4.3.1 Walkthrough This problem can be converted to finding if a graph contains a cycle using topological sort 5.4.3.2 Analysis A BFS would cost \\(O(|V| + |E|)\\) 5.4.3.3 Algorithm topological 1.2.3, bfs 1.2.2 5.4.3.4 Java Code public boolean canFinish(int numCourses, int[][] prerequisites) { if(numCourses == 0 || prerequisites.length == 0){ return true; } // counter for number of prerequisites int[] numPrereq = new int[numCourses]; for(int i = 0; i &lt; prerequisites.length; i++){ numPrereq[prerequisites[i][0]]++; } //store courses that have no prerequisites Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); for(int i = 0; i &lt; numCourses; i++){ if(numPrereq[i] == 0){ queue.offer(i); } } // store the topological sorting order List&lt;Integer&gt; order = new ArrayList&lt;&gt;(); while(!queue.isEmpty()) { int vertex = queue.poll(); order.add(vertex); for(int i = 0; i &lt; prerequisites.length; i++){ // if a course&#39;s prerequisite can be satisfied by a course in queue if(prerequisites[i][1] == vertex) { numPrereq[prerequisites[i][0]]--; if(numPrereq[prerequisites[i][0]] == 0) { queue.offer(prerequisites[i][0]); } } } } return order.size() == numCourses; } 5.4.4 Solution - Topological Sort via DFS 5.4.4.1 Walkthrough 5.4.4.2 Analysis A DFS would cost \\(O(|V| + |E|)\\) 5.4.4.3 Algorithm topological 1.2.3, dfs 1.2.1 5.4.4.4 Java Code public boolean canFinish(int numCourses, int[][] prerequisites) { if(numCourses == 0 || prerequisites.length == 0){ return true; } //track state of visited courses // -1: VISITING // 1: VISITED int[] visited = new int[numCourses]; // use the map to store what courses depend on a course // can transform into an adjcency list Map&lt;Integer, List&lt;Integer&gt;&gt; adjMap = new HashMap&lt;&gt;(); for(int[] edge: prerequisites){ if(adjMap.containsKey(edge[1])) { adjMap.get(edge[1]).add(edge[0]); } else { List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(edge[0]); adjMap.put(edge[1], list); } } for(int i = 0; i &lt; numCourses; i++) { if(!dfs(adjMap, visited, i)) { return false; } } return true; } private boolean dfs(Map&lt;Integer, List&lt;Integer&gt;&gt; adjMap, int[] visited, Integer vertex){ if(visited[vertex] == -1) { return false; } if(visited[vertex] == 1) { return true; } visited[vertex] = -1; if(adjMap.containsKey(vertex)){ for(Integer adjVertex: adjMap.get(vertex)){ if(!dfs(adjMap, visited, adjVertex)) { return false; } } } visited[vertex] = 1; return true; } "],
["course-schedule-ii-leetcode-210-medium.html", "5.5 Course Schedule II / LeetCode 210 / Medium", " 5.5 Course Schedule II / LeetCode 210 / Medium 5.5.1 Description There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]. Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. 5.5.2 Example 5.5.2.1 Example 1 Input: 2, [[1,0]] Output: [0,1] 5.5.2.2 Example 2 Input: 4, [[1,0],[2,0],[3,1],[3,2]] Output: [0,1,2,3] or [0,2,1,3] 5.5.3 Solution - Topological Sort via BFS 5.5.3.1 Walkthrough This problem can be converted to finding if a graph contains a cycle using topological sort 5.5.3.2 Analysis A BFS would cost \\(O(|V| + |E|)\\) 5.5.3.3 Algorithm topological 1.2.3, bfs 1.2.2 5.5.3.4 Java Code public int[] findOrder(int numCourses, int[][] prerequisites) { //if there is no prerequisites, return a sequence of courses if(prerequisites.length == 0){ int[] res = new int[numCourses]; for(int i = 0; i &lt; numCourses; i++){ res[i] = i; } return res; } // counter for number of prerequisites int[] numPrereq = new int[numCourses]; for(int i = 0; i &lt; prerequisites.length; i++){ numPrereq[prerequisites[i][0]]++; } //store courses that have no prerequisites Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); for(int i = 0; i &lt; numCourses; i++){ if(numPrereq[i] == 0){ queue.offer(i); } } // store the topological sorting order List&lt;Integer&gt; order = new ArrayList&lt;&gt;(); while(!queue.isEmpty()) { int vertex = queue.poll(); order.add(vertex); for(int i = 0; i &lt; prerequisites.length; i++){ // if a course&#39;s prerequisite can be satisfied by a course in queue if(prerequisites[i][1] == vertex) { numPrereq[prerequisites[i][0]]--; if(numPrereq[prerequisites[i][0]] == 0) { queue.offer(prerequisites[i][0]); } } } } int numOfPreReq = order.size(); if(numOfPreReq == numCourses) { return toArray(order); } else { return new int[0]; } } private int[] toArray(List&lt;Integer&gt; list) { int[] result = new int[list.size()]; for(int i = 0; i &lt; list.size(); i++) { int item = list.get(i); result[i] = item; } return result; } "],
["graph-validate-tree-leetcode-261-medium.html", "5.6 Graph Validate Tree / LeetCode 261 / Medium", " 5.6 Graph Validate Tree / LeetCode 261 / Medium 5.6.1 Description Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), check if these edges form a valid tree. 5.6.2 Example 5.6.3 Solution - Topological Sorting via DFS 5.6.3.1 Walkthrough This problem can be converted to finding the cycle from a graph using Topological Sorting 5.6.3.2 Analysis A DFS would cost \\(O(|V| + |E|)\\) 5.6.3.3 Algorithm topological 1.2.3, dfs 1.2.1 5.6.3.4 Java Code - Topological Sorting via DFS public boolean validTree(int n, int[][] edges) { HashMap&lt;Integer, ArrayList&lt;Integer&gt;&gt; map = new HashMap&lt;Integer, ArrayList&lt;Integer&gt;&gt;(); for(int i=0; i&lt;n; i++){ ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); map.put(i, list); } for(int[] edge: edges){ map.get(edge[0]).add(edge[1]); map.get(edge[1]).add(edge[0]); } boolean[] visited = new boolean[n]; if(!helper(0, -1, map, visited)) return false; for(boolean b: visited){ if(!b) return false; } return true; } private boolean helper(int curr, int parent, HashMap&lt;Integer, ArrayList&lt;Integer&gt;&gt; map, boolean[] visited){ if(visited[curr]) return false; visited[curr] = true; for(int i: map.get(curr)){ if(i!=parent &amp;&amp; !helper(i, curr, map, visited)){ return false; } } return true; } 5.6.4 Solution - Topological Sorting via BFS 5.6.4.1 Walkthrough This problem can be converted to finding the cycle from a graph using Topological Sorting 5.6.4.2 Analysis A BFS cost \\(O(|V| + |E|)\\) 5.6.4.3 Algorithm topological 1.2.3, bfs 1.2.2 5.6.4.4 Java Code - Topological Sorting via BFS public boolean validTree(int n, int[][] edges) { ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); for(int i=0; i&lt;n; i++){ list.add(new ArrayList&lt;&gt;()); } //build the graph for(int[] edge: edges){ int a = edge[0]; int b = edge[1]; list.get(a).add(b); list.get(b).add(a); } //use queue to traverse the graph HashSet&lt;Integer&gt; visited = new HashSet&lt;&gt;(); LinkedList&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.offer(0); while(!q.isEmpty()){ int head = q.poll(); if(visited.contains(head)){ return false; } visited.add(head); ArrayList&lt;Integer&gt; vList = list.get(head); for(int v: vList){ if(!visited.contains(v)){ q.offer(v); } } } if(visited.size()&lt;n){ return false; } return true; } "],
["linked-list.html", "Chapter 6 Linked List\n", " Chapter 6 Linked List\n"],
["add-two-numbers-leet-code-2-medium.html", "6.1 Add Two Numbers / Leet Code 2 / Medium", " 6.1 Add Two Numbers / Leet Code 2 / Medium 6.1.1 Description You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. 6.1.2 Example Input: Figure 6.1: Some caption. Figure 6.2: Some caption. Output: Figure 6.3: Some caption. Explanation: 342 + 465 = 807. 6.1.3 Solution 6.1.3.1 Walkthrough First add two number digit by digit until one number run out of digit. Copy the other number for the remaining of digits. 6.1.3.2 Analysis Time complexity is O(n + m) as every node is visited once. 6.1.3.3 Algorithm 6.1.3.4 Java Code public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode currentN1 = l1; ListNode currentN2 = l2; ListNode currentDigit = new ListNode(0); ListNode resultHead = currentDigit; int digitCarry = 0; int digitSum = 0; while(currentN1 != null &amp;&amp; currentN2 != null) { digitSum = currentN1.val + currentN2.val + digitCarry; digitCarry = digitSum / 10; digitSum %= 10; currentDigit.next = new ListNode(digitSum); currentDigit = currentDigit.next; currentN1 = currentN1.next; currentN2 = currentN2.next; } //Copy the remaining of number 1 while(currentN1 != null) { digitSum = currentN1.val + digitCarry; digitCarry = digitSum / 10; digitSum %= 10; currentDigit.next = new ListNode(digitSum); currentDigit = currentDigit.next; currentN1 = currentN1.next; } //Copy the remaining of number 2 while(currentN2 != null) { digitSum = currentN2.val + digitCarry; digitCarry = digitSum / 10; digitSum %= 10; currentDigit.next = new ListNode(digitSum); currentDigit = currentDigit.next; currentN2 = currentN2.next; } if(digitCarry &gt; 0) { currentDigit.next = new ListNode(digitCarry); currentDigit = currentDigit.next; } return resultHead.next; } "],
["reverse-linked-list-leet-code-206-easy.html", "6.2 Reverse Linked List / Leet Code 206 / Easy", " 6.2 Reverse Linked List / Leet Code 206 / Easy 6.2.1 Description Reverse a singly linked list. 6.2.2 Example Input: Figure 6.4: Some caption. Output: Figure 6.5: Some caption. 6.2.3 Solution - Recursive 6.2.3.1 Walkthrough For recursive solution, have a pointer remember original next and swap its link with the original head. Call the method recursively. 6.2.3.2 Analysis Time complexity is O(n) since every node is visited. 6.2.3.3 Algorithm recursion 1.2.5 6.2.3.4 Java Code - Recursive public ListNode reverseList(ListNode node) { if(node == null) { return null; } else if(node.next == null) { return node; } else { ListNode origNext = node.next; ListNode newNode = reverseList(origNext); //origNext -&gt; node origNode.next = node; //delete link node.next = null; return newNode; } } 6.2.4 Solution - Iterative 6.2.4.1 Walkthrough For iterative solution, have a helper pointer to remember the previous position and reverse the links between current and headPrev nodes while iterating the list. Figure 6.6: Some caption. Finally, reset where begin.next points to head of the list after reverse - tail of the original list, and return the head of the reversed list. Figure 6.7: Some caption. 6.2.4.2 Analysis Time complexity is O(n) since every node is visited. 6.2.4.3 Algorithm 6.2.4.4 Java Code - Iterative public ListNode reverseList(ListNode head) { if(head == null || head.next == null) { return head; } ListNode headPrev = new ListNode(0); headPrev.next = head; return reverse(headPrev); } public ListNode reverse(ListNode begin) { ListNode prev = begin.next; ListNode current = prev.next; //reverse links between current and prev while (current != null) { ListNode next = current.next; /* * swap links between current and prev */ current.next = prev; prev = current; current = next; } begin.next.next = current; begin.next = prev; return begin.next; } "],
["reverse-linked-list-ii-leet-code-92-medium.html", "6.3 Reverse Linked List II / Leet Code 92 / Medium", " 6.3 Reverse Linked List II / Leet Code 92 / Medium 6.3.1 Description Reverse a linked list from position m to n. Do it in one-pass 6.3.2 Example Input: Figure 6.8: Some caption. , m = 2, n = 4 Output: Figure 6.9: Some caption. 6.3.3 Solution 6.3.3.1 Walkthrough Have a helper pointer to to move to (M-1) position and reverse the links between current and prev nodes while iterating the list for (N-M) nodes. Figure 6.10: Some caption. Finally, reset where begin.next points to head of the list after reverse - tail of the original list, and return the tail of the reversed list. Figure 6.11: Some caption. 6.3.3.2 Analysis Time complexity is O(n) as every node is visited once. 6.3.3.3 Algorithm 6.3.3.4 Java Code public ListNode reverseBetween(ListNode head, int m, int n) { if(head == null) { return head; } //headHelper.next is original head ListNode headPrev = new ListNode(0); headPrev.next = head; ListNode mMinus1 = headPrev; //move to starting position for (int i = 0; i &lt; m - 1; i++) { mMinus1 = mMinus1.next; } //reverse node between (m, n) reverseList(mMinus1, n-m); return headPrev.next; } public ListNode reverseList(ListNode begin, int length) { ListNode prev = begin.next; ListNode current = prev.next; //reverse links between current and prev int i = 0; while (i &lt; length) { ListNode next = current.next; /* * swap links between current and prev */ current.next = prev; prev = current; current = next; i++; } // tail of reversed is head of original list ListNode tail = begin.next; begin.next.next = current; begin.next = prev; return tail; } "],
["reverse-nodes-in-k-group-leetcode-25-hard.html", "6.4 Reverse Nodes in k-Group / LeetCode 25 / Hard", " 6.4 Reverse Nodes in k-Group / LeetCode 25 / Hard 6.4.1 Description Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. You may not alter the values in the nodes, only nodes itself may be changed. 6.4.2 Example Input: Figure 6.12: Some caption. k = 2 becomes Figure 6.13: Some caption. k=3 becomes Figure 6.14: Some caption. 6.4.3 Solution 6.4.3.1 Walkthrough Have a index to remember when to start reversing and when to stop and reverse the links between current and prev nodes while iterating the list until the stop position is met. Figure 6.15: Some caption. Finally, reset where begin.next points to head of the list after reverse - tail of the original list, and return the tail of the reversed list. Figure 6.16: Some caption. 6.4.3.2 Analysis Time complexity is O(n) as every node is visited once. 6.4.3.3 Algorithm 6.4.3.4 Java Code public ListNode reverseKGroup(ListNode head, int k) { if(head==null || k==1) { return head; } ListNode headPrev = new ListNode(0); headPrev.next = head; ListNode prev = headPrev; int i = 0; ListNode current = head; while(current!=null){ i++; if((i % k) == 0){ ListNode revTail = reverseList(prev, current.next); prev = revTail; current = revTail.next; }else{ current = current.next; } } return headPrev.next; } public ListNode reverseList(ListNode begin, ListNode end) { ListNode prev = begin.next; ListNode current = prev.next; //reverse links between current and prev while (current != end) { ListNode next = current.next; /* * swap links between current and prev */ current.next = prev; prev = current; current = next; } // tail of reversed is head of original list ListNode tail = begin.next; begin.next.next = end; begin.next = prev; return tail; } "],
["linked-list-cycle-leet-code-141-easy.html", "6.5 Linked List Cycle / Leet Code 141 / Easy", " 6.5 Linked List Cycle / Leet Code 141 / Easy 6.5.1 Description Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. 6.5.2 Example Input: Figure 6.17: Some caption. Output: true. Explanation: There is a cycle in the linked list, where tail connects to the second node. Input: Figure 6.18: Some caption. Output: true. Explanation: There is a cycle in the linked list, where tail connects to the first node. Input: Figure 6.19: Some caption. Output: false. Explanation: There is no cycle in the linked list. 6.5.3 Solution 6.5.3.1 Walkthrough Having two pointers, one running twice as fast as the other(p1 = p1.next; p2 = p2.next.next). If there is a cycle, eventually (p1 == p2) representing a node in the cycle. A better traversal algorithm would make p1 at the middle of the cycled list whereas p2 at the tail of the cycled list. 6.5.3.2 Analysis Time complexity is O(n) as every node is visited once. 6.5.3.3 Algorithm 6.5.3.4 Java Code public boolean hasCycle(ListNode head) { if(head == null) { return false; } ListNode fast = head, slow = head; while(fast != null &amp;&amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if(fast == slow) { return true; } } return false; } "],
["linked-list-cycle-ii-leet-code-142-medium.html", "6.6 Linked List Cycle II / Leet Code 142 / Medium", " 6.6 Linked List Cycle II / Leet Code 142 / Medium 6.6.1 Description Given a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list. 6.6.2 Example Input: Figure 6.20: Some caption. Output: tail connects to node index 1. Explanation: There is a cycle in the linked list, where tail connects to the second node. Input: Figure 6.21: Some caption. Output: tail connects to node index 0. Explanation: There is a cycle in the linked list, where tail connects to the first node. Input: Figure 6.22: Some caption. Output: null (no cycle). Explanation: There is no cycle in the linked list. 6.6.3 Solution 6.6.3.1 Walkthrough Having two pointers, one talks twice as fast as the other. If there is a cycle (p1 == p2), p1 would be at the middle of the cycled list whereas p2 at the tail of the cycled list. In other words, # of steps taken from header to p1 equals to # of steps taken from p1 to p2. 6.6.3.2 Analysis Time complexity is O(n) as every node is visited once. 6.6.3.3 Algorithm 6.6.3.4 Java Code public ListNode detectCycle(ListNode head) { if(head == null || head.next == null) { return null; } ListNode fast = head, slow = head; while(fast != null &amp;&amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if(fast == slow) { break; } } if(fast == slow) { ListNode cycleHead = head; /* * slow is at middle of CYCLED list * Initially, cycleHead is at header * cycleHead --&gt; slow == slow --&gt; fast */ while(fast != cycleHead) { fast = fast.next; cycleHead = cycleHead.next; } return cycleHead; } else {//no cycle return null; } } "],
["odd-even-linked-list-leet-code-328-medium.html", "6.7 Odd Even Linked List / Leet Code 328 / Medium", " 6.7 Odd Even Linked List / Leet Code 328 / Medium 6.7.1 Description Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. 6.7.2 Example Input: Figure 6.23: Some caption. Output: Figure 6.24: Some caption. 6.7.3 Solution 6.7.3.1 Walkthrough Have two helper pointers to construct to list: one for odd nodes and one for even nodes. Assign those nodes accordingly while traversing the list. Finally, connect odd nodes list to even nodes list. 6.7.3.2 Analysis The program should run in O(1) Auxiliary Space and O(n) time complexity. 6.7.3.3 Algorithm 6.7.3.4 Java Code public ListNode oddEvenList(ListNode head) { if(head == null || head.next == null || head.next.next == null ) { return head; } ListNode oddHeadPrev = new ListNode(0), currentOdd = oddHeadPrev; ListNode evnHeadPrev = new ListNode(0), currentEvn = evnHeadPrev; ListNode current = head; int index = 1; while(current != null) { // Same as index % 2 == 1 if( (index &amp; 1) &gt; 0 ) { currentOdd.next = current; currentOdd = currentOdd.next; } else { currentEvn.next = current; currentEvn = currentEvn.next; } index++; current = current.next; } //connect odd nodes list with even nodes list currentOdd.next = evnHeadPrev.next; //connect event nodes to null currentEvn.next = null; return oddHeadPrev.next; } "],
["merge-two-sorted-lists-leet-code-21-easy.html", "6.8 Merge Two Sorted Lists / Leet Code 21 / Easy", " 6.8 Merge Two Sorted Lists / Leet Code 21 / Easy 6.8.1 Description Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 6.8.2 Example 6.8.3 Solution 6.8.3.1 Walkthrough This is the same as merge() to sort a list in Leet Code 148. First we will create a new ListNode and a current pointer. While traversing the node, compre the nodes at each list and nodes with smaller value will attach to the final sorted list. Exit traversal when either list hits the end. If there are nodes remained in either list, connect to that remaining nodes of the list. 6.8.3.2 Analysis The cost for each merge is O(n) as every node is visited once in the list. There are two lists, thus the overall time complexity remains O(n). 6.8.3.3 Algorithm 6.8.3.4 Java Code public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode headPrev = new ListNode(0), current = headPrev; while(l1 != null &amp;&amp; l2 != null) { if(l1.val &lt; l2.val) { //l1 &lt; l2 current.next = l1; l1 = l1.next; } else { current.next = l2; l2 = l2.next; } current = current.next; } // connect to the rest of the remaining nodes if(l1 != null) { current.next = l1; } else { // l2 = remaining of list or null current.next = l2; } return headPrev.next; } "],
["merge-k-sorted-lists-leet-code-23-hard.html", "6.9 Merge k Sorted Lists / Leet Code 23 / Hard", " 6.9 Merge k Sorted Lists / Leet Code 23 / Hard 6.9.1 Description Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 6.9.2 Example 6.9.3 Solution - Merge lists one by one 6.9.3.1 Walkthrough One solution is to leverage the previous problem of merging 2 list. 6.9.3.2 Analysis We will need to merge two lists for (k-1) times, where each merge() will cost O(n) in time complexity and O(1) in Auxiliary Space. The total cost for merge is \\(\\sum_{i=1}^{k-1} (i * \\frac{n}{k} + \\frac{n}{k}) = O(k \\cdot n)\\) in time complexity, where n is the total node number in k list. and O(1) in Auxiliary Space. However, this would not be an efficient solution if k is large. 6.9.3.3 Algorithm 6.9.3.4 Java Code - Merge lists one by one public ListNode mergeKLists(ListNode[] lists) { if(lists.length == 0) { return null; } ListNode newHead = lists[0]; //merge k-1 times for(int i = 1; i &lt; lists.length; i++) { newHead = merge(newHead, lists[i]); } return newHead; } public ListNode merge(ListNode l1, ListNode l2) { ListNode headPrev = new ListNode(0), current = headPrev; while(l1 != null &amp;&amp; l2 != null) { if(l1.val &lt; l2.val) { //l1 &lt; l2 current.next = l1; l1 = l1.next; } else { current.next = l2; l2 = l2.next; } current = current.next; } // connect to the rest of the remaining nodes if(l1 != null) { current.next = l1; } else { current.next = l2; } return headPrev.next; } 6.9.4 Solution - Min Heap 6.9.4.1 Walkthrough We could compare every leading elements in k lists and retrieve the node with the smallest value using Min Heap. 6.9.4.2 Analysis Since the original k lists were sorted, therefore, we could retrieve all \\(n \\cdot k\\) elements in sorted order by retrieve the min element from PriorityQueue (min heap). The comparison cost is O(log k) for every pop and insertion to the priority queue since there are at most k elements (from k list). Additionally, there are a total number of n nodes in all lists. Thus, the overall time complexity is \\(O(\\log k \\cdot n)\\) and Auxiliary Space for the ﬁnal list is O(n), where n is the total node number in all k lists. 6.9.4.3 Algorithm bfs 1.2.2, heap 1.2.15 6.9.4.4 Java Code - Min Heap public ListNode mergeKLists(ListNode[] lists) { if(lists.length == 0) { return null; } ListNode head = null, current = null; PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;(new Comparator&lt;ListNode&gt;() { @Override public int compare(ListNode node1, ListNode node2) { return node1.val - node2.val; } }); //insert all heads into the priority queue for(ListNode headOfList : lists) { if(headOfList != null) { queue.offer(headOfList); } } while(!queue.isEmpty()) { ListNode node = queue.poll(); //add next node into priority queue if(node.next != null) { queue.offer(node.next); } // construct the list with the min element from queue if(head == null) { head = node; current = node; } else { current.next = node; current = current.next; } } return head; } "],
["palindrome-linked-list-leet-code-234-easy.html", "6.10 Palindrome Linked List / Leet Code 234 / Easy", " 6.10 Palindrome Linked List / Leet Code 234 / Easy 6.10.1 Description Given a singly linked list, determine if it is a palindrome. 6.10.2 Example Input: Figure 6.25: Some caption. return false Output: Figure 6.26: Some caption. return true 6.10.3 Solution 6.10.3.1 Walkthrough Locate the mid node, and use that to reverse the 2nd half of the list. We will have two sublists: [o, …, m] and [r, …, m]. Event number of list: Figure 6.27: Some caption. Odd number of list: Figure 6.28: Some caption. Traverse the two sublists, beginning at head of original and head of reversed sublists respectively. If any node is not equal, then it is NOT palindrome. 6.10.3.2 Analysis Time complexity is O(n) as every node is visited once. 6.10.3.3 Algorithm 6.10.3.4 Java Code public boolean isPalindrome(ListNode head) { if(head == null || head.next == null) { return true; } ListNode mid = head, tail = head; //locating mid and tail nodes while(tail.next != null &amp;&amp; tail.next.next != null) { mid = mid.next; tail = tail.next.next; } // retrieve the head of reversed 2nd half sublist ListNode reversed2ndHalfHead = reverse(mid); ListNode currentOrg = head, currentRev = reversed2ndHalfHead; while(currentOrg != null &amp;&amp; currentRev != null) { //if any in original 1st half does not match reversed 2nd half if(currentOrg.val != currentRev.val) { return false; } currentOrg = currentOrg.next; currentRev = currentRev.next; } return true; } public ListNode reverse(ListNode head) { ListNode headPrev = new ListNode(0); ListNode current = head; //reverse links between current and prev while (current != null) { ListNode next = current.next; /* * swap links between current and prev */ current.next = headPrev.next; headPrev.next = current; current = next; } return headPrev.next; } "],
["intersection-of-two-linked-lists-leet-code-160-easy.html", "6.11 Intersection of Two Linked Lists / Leet Code 160 / Easy", " 6.11 Intersection of Two Linked Lists / Leet Code 160 / Easy 6.11.1 Description Write a program to find the node at which the intersection of two singly linked lists begins. If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. The intersected nodes must continue to the end of both lists. If two nodes intersect, two node pointers refer to the same ListNode object in memory. 6.11.2 Example Input: Figure 6.29: Some caption. Output: Reference of the node with value = 8 Input Explanation: The intersected node’s value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B. 6.11.3 Solution 6.11.3.1 Walkthrough First we compute the length of both list and we get rid of the leading extra node of the longer list. For the # of remaining nodes of the longer list should equal to the # of shorter list. We traverse both list, and determine when (p1 == p2) - instead of (p1.val == p2.val) 6.11.3.2 Analysis Time complexity is O(n) as every node is visited once. 6.11.3.3 Algorithm 6.11.3.4 Java Code public ListNode getIntersectionNode(ListNode headA, ListNode headB) { int lenA = 0, lenB = 0; //compute length of both lists for(ListNode current = headA; current != null; current = current.next, lenA++); for(ListNode current = headB; current != null; current = current.next, lenB++); //both conditions need to be the same ListNode currentLonger = lenA &gt; lenB ? headA : headB; ListNode currentShorter = lenA &gt; lenB ? headB : headA; //Move currentLonger to the position where remaining of nodes equal to len(currentShorter) for(int i = 0; i &lt; Math.abs(lenA - lenB); i++, currentLonger = currentLonger.next); while(currentLonger != null &amp;&amp; currentShorter != null) { //If the node intersect, nodeA == nodeB if(currentLonger == currentShorter) { //return current node return currentLonger; } currentLonger = currentLonger.next; currentShorter = currentShorter.next; } //no match return null; } "],
["remove-nth-node-from-end-of-list-leet-code-19-medium.html", "6.12 Remove Nth Node From End of List / Leet Code 19 / Medium", " 6.12 Remove Nth Node From End of List / Leet Code 19 / Medium 6.12.1 Description Given a linked list, remove the n-th node from the end of list and return its head. 6.12.2 Example Input: Figure 6.30: Some caption. , and n = 2. Output: Figure 6.31: Some caption. 6.12.3 Solution - TWO Pass 6.12.3.1 Walkthrough The simpliest solution is to do solve this problem in two passes. First round is to find out the length of the list, whileas the second iteration is to iterate to the node posiion \\(length -n + 1\\) or prev node position \\(length - n\\), begining from a dummy node headPrev. Finally, we need to check and move the head node appropriately if we are deleting it. 6.12.3.2 Analysis Time complexity is O(n) as every node is visited once. 6.12.3.3 Algorithm 6.12.3.4 Java Code - TWO Pass public ListNode removeNthFromEnd(ListNode head, int n) { if(head == null) { return null; } //Quick check to see if we are deleting the only node in the list if (head.next == null &amp;&amp; n &lt;= 1){ return null; } int length = 0; //1st pass: to get length of the list for(ListNode current = head; current != null; current = current.next) { length++; } // removal position is over list length if(n &gt; length) { return head; } //move to the position before the target int position = length - n; //keep track of current traversed # of nodes int count = 0; ListNode headPrev = new ListNode(0); headPrev.next = head; ListNode removedPrev = headPrev; //2nd pass: move to the one before target while( count &lt; position) { removedPrev = removedPrev.next; count++; } removedPrev.next = removedPrev.next.next; //if removing head, renew head if(removedPrev == headPrev) { head = removedPrev.next; } return head; } 6.12.4 Solution - ONE Pass 6.12.4.1 Walkthrough The simpliest solution is to do solve this problem in two passes. First round is to find out the length of the list, whileas the second iteration is to iterate to the node posiion \\(length -n + 1\\) or prev node position \\(length - n\\), begining from a dummy node headPrev. Finally, we need to check and move the head node appropriately if we are deleting it. 6.12.4.2 Analysis Time complexity is O(n) as every node is visited once. 6.12.4.3 Java Code - ONE Pass public ListNode removeNthFromEnd(ListNode head, int n) { //Quick check to see if we are deleting the only node in the list if (head.next == null &amp;&amp; n == 1){ return null; } //keep track of current traversed # of nodes int count = 0; //Add a node to the begining of our linked list to make deletions easier at the top ListNode headPrev = new ListNode(0); headPrev.next = head; ListNode current = headPrev; ListNode removedPrev = headPrev; while(current != null) { count++; if( (count - n) &gt; 1 ) { removedPrev = removedPrev.next; } if(current.next == null) { //the last node, removedPrev is also at the right position if(removedPrev.next != null &amp;&amp; removedPrev.next.next == null) { //to remove tail node removedPrev.next = null; } else { // to remove non-tail node (including head) removedPrev.next = removedPrev.next.next; } break; } current = current.next; } return headPrev.next; } "],
["insert-a-node-at-the-nth-position-in-doubly-linked-list-firebase-level-3.html", "6.13 Insert a Node at the Nth Position in Doubly Linked List / Firebase / Level 3", " 6.13 Insert a Node at the Nth Position in Doubly Linked List / Firebase / Level 3 6.13.1 Description In doubly linked list, implement a method to insert a node at specified position and return the list’s head. Do nothing if insertion position is outside the bounds of the list. 6.13.2 Example Figure 6.32: Some caption. given the list, insert a new node at index 2 with value 4. Result: Figure 6.33: Some caption. If the index exceed the length, return the list unchanged: Figure 6.34: Some caption. 6.13.3 Solution 6.13.3.1 Walkthrough The simpliest solution is to do solve this problem in two passes. First round is to find out the length of the list and check if the request position is over the lenght limit. The second iteration is to traverse to the previous insertion position, begining from a dummy node headPrev. Finally, we need to check if we are inserting a head / a tail or an intermediate node. 6.13.3.2 Analysis Time complexity is O(n) as every node is visited once. 6.13.3.3 Algorithm 6.13.3.4 Java Code public DoublyLinkedNode insertAtPos(DoublyLinkedNode head, int data, int pos) { DoublyLinkedNode newNode = new DoublyLinkedNode(data); //Quick check if we are inserting the only node in the list if(head == null) { if(pos == 1) { return newNode; } else { return head; } } int len = 1; //1st pass: to get length of the list for(DoublyLinkedNode current = head; current != null; current = current.next) { len++; } //pos is over list length if(pos &gt; len) { return head; } DoublyLinkedNode headPrev = new DoublyLinkedNode(0); headPrev.next = head; head.prev = headPrev; DoublyLinkedNode insertPrev = headPrev; //2nd pass: move to before the insertion position for(int i = 0; i &lt; (pos - 1); i++) { insertPrev = insertPrev.next; } if(insertPrev == headPrev) { // insert head head.prev = newNode; newNode.next = head; return newNode; } else if(insertPrev.next == null) { // insert tail insertPrev.next = newNode; newNode.prev = insertPrev; return head; } else { // insert intermediate DoublyLinkedNode insertNext = insertPrev.next; insertPrev.next = newNode; newNode.prev = insertPrev; newNode.next = insertNext; insertNext.prev = newNode; return head; } } "],
["reorder-list-leet-code-143-medium.html", "6.14 Reorder List / Leet Code 143 / Medium", " 6.14 Reorder List / Leet Code 143 / Medium 6.14.1 Description Given a singly linked list L: Figure 6.35: Some caption. , reorder it to Figure 6.36: Some caption. You may not modify the values in the list’s nodes, only nodes itself may be changed. 6.14.2 Example Given Figure 6.37: Some caption. , reorder it to Figure 6.38: Some caption. 6.14.3 Solution 6.14.3.1 Walkthrough We could do the following: Locate the middle and tail nodes Reverse the nodes in the 2nd half othe list in-place] Change links between nodes in 1st and 2nd half of list, one by one. 6.14.3.2 Analysis Time complexity is O(n) as every node is visited once. 6.14.3.3 Algorithm 6.14.3.4 Java Code public void reorderList(ListNode head) { if (head == null || head.next == null) { return; } //locating middle and tail nodes ListNode middle = head; ListNode tail = head; while (tail.next != null &amp;&amp; tail.next.next != null) { middle = middle.next; tail = tail.next.next; } /* * reverse nodes for the 2nd half of the list * L0 &gt; L1 &gt; ... &gt; Ln &gt; L_{n-1} &gt; ... */ ListNode middlePrev = middle; ListNode prev = middle.next; /* * reverse links between prev, current and current.next by FIXING middlePrev * 7 &gt; 8 &gt; 9 * 8 &gt; 7 &gt; 9 */ while (prev.next != null) { ListNode current = prev.next; prev.next = current.next; current.next = middlePrev.next; middlePrev.next = current; } //change links between nodes in 1st and 2nd half, one by one. ListNode current1 = head; ListNode current2 = middlePrev.next; while (current1 != middlePrev) { middlePrev.next = current2.next; current2.next = current1.next; current1.next = current2; current1 = current2.next; current2 = middlePrev.next; } } "],
["remove-duplicates-from-sorted-list-leet-code-83-easy.html", "6.15 Remove Duplicates from Sorted List / Leet Code 83 / Easy", " 6.15 Remove Duplicates from Sorted List / Leet Code 83 / Easy 6.15.1 Description Given a sorted linked list, delete all duplicates such that each element appear only once. 6.15.2 Example Input Figure 6.39: Some caption. Output Figure 6.40: Some caption. 6.15.3 Solution - non sorted list 6.15.3.1 Walkthrough If this is a non sorted list, we need to keep a record (HashSet) and a prev node. Remove the duplicate node if found - set.add() returns false 6.15.3.2 Analysis Time complexity is O(n) as every node is visited once. 6.15.3.3 Algorithm 6.15.3.4 Java Code - non sorted list public ListNode removeDuplicates(ListNode head) { ListNode prev = new ListNode(0); prev.next = head; ListNode current = head; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); while(current != null) { int value = current.data; if(!set.add(value)) { //duplicated entry prev.next = prev.next.next; } else { prev = prev.next; } current = current.next; } return head; } 6.15.4 Solution - sorted list 6.15.4.1 Walkthrough If this is a sorted list, we could utilize the fact that if current.data == next.data. Remove the next node. 6.15.4.2 Analysis Time complexity is O(n) as every node is visited once. 6.15.4.3 Algorithm 6.15.4.4 Java Code - sorted list public ListNode deleteDuplicates(ListNode head) { ListNode current = head; while(current != null) { if(current.next != null &amp;&amp; current.val == current.next.val) { //remove the current node current.next = current.next.next; } else { current = current.next; } } return head; } "],
["copy-list-with-random-pointer-leetcode-138-medium.html", "6.16 Copy List with Random Pointer / LeetCode 138 / Medium", " 6.16 Copy List with Random Pointer / LeetCode 138 / Medium 6.16.1 Description A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. The Linked List is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val: an integer representing Node.val random_index: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node. 6.16.2 Example Deep copy of the following array: Figure 6.41: Some caption. 6.16.3 Solution 6.16.3.1 Walkthrough We could not copy random index (\\(\\Rightarrow\\)) in 1st pass, since the desginated node might not be created yet. Thus, we need to perform in 3 pass: copy every node, i.e., duplicate every node and next index (\\(\\rightarrow\\)), and insert it to the list Figure 6.42: Some caption. copy random pointers for all newly created nodes Figure 6.43: Some caption. break the list to two Figure 6.44: Some caption. finally, Figure 6.45: Some caption. 6.16.3.2 Analysis Time complexity is O(n) as every node is visited once. 6.16.3.3 Algorithm 6.16.3.4 Java Code public Node copyRandomList(Node head) { if (head == null) { return null; } // copy every node and insert to list Node current = head; while (current != null) { Node dup = new Node(current.val); dup.next = current.next; current.next = dup; current = dup.next; } // copy random pointer for each new node current = head; while (current != null) { Node dup = current.next; if (current.random != null) { dup.random = current.random.next; } current = dup.next; } // break list to two current = head; Node newHead = head.next; while (current != null) { Node dup = current.next; current.next = dup.next; if (dup.next != null) { dup.next = dup.next.next; } current = current.next; } return newHead; } "],
["common-data-structure-set-stack-heap-treemap.html", "Chapter 7 Common Data Structure : Set / Stack / Heap / TreeMap", " Chapter 7 Common Data Structure : Set / Stack / Heap / TreeMap In Java, an implementation for minmum heap is defined as PriorityQueue class.\n"],
["group-anagrams-leet-code-49-medium.html", "7.1 Group Anagrams / Leet Code 49 / Medium", " 7.1 Group Anagrams / Leet Code 49 / Medium 7.1.1 Description Given an array of strings, group anagrams together. 7.1.2 Example Input: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”], Output: [ [“ate”,“eat”,“tea”], [“nat”,“tan”], [“bat”]] 7.1.3 Solution 7.1.3.1 Walkthrough Assume they are all anagrams, and we keeps a map to store the list of anagrams associated with their unique pattern , i.e. sorted string; that is, \\(&lt;\\)sorted_str, List of anagram\\(&gt;\\). Finally, we collect the list of anagram in another list to return. 7.1.3.2 Analysis Time complexity is O(n) as every word is processed once. 7.1.3.3 Algorithm 7.1.3.4 Java Code public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) { Map&lt;String, List&lt;String&gt;&gt; index = new HashMap&lt;&gt;(); List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); if(strs == null || strs.length == 0) { return result; } for(String str : strs) { char[] chars = str.toCharArray(); Arrays.sort(chars); String sortedStr = new String(chars); List&lt;String&gt; list = index.getOrDefault(sortedStr, new ArrayList&lt;&gt;()); list.add(str); // only insert if key was asbsent index.putIfAbsent(sortedStr, list); } for(Map.Entry&lt;String, List&lt;String&gt;&gt; entry : index.entrySet()) { result.add(entry.getValue()); } return result; } "],
["longest-substring-without-repeating-characters-leetcode-3-medium.html", "7.2 Longest Substring Without Repeating Characters / LeetCode 3 / Medium", " 7.2 Longest Substring Without Repeating Characters / LeetCode 3 / Medium 7.2.1 Description Given a string, find the length of the longest substring without repeating characters. 7.2.2 Example Input: “abcabcbb”, Output: 3 , Explanation: The answer is “abc”, with the length of 3. Input: “bbbbb”, Output: 1 , Explanation: The answer is “b”, with the length of 1. Input: “pwwkew”, Output: 3, Explanation: The answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. ### Solution - Sliding Window #### Walkthrough Use two indices left, and right to remember a substring (sliding window). Use a Set to check for unique characters. If there is unique character, move right index outward (expand substring); otherwise, move left index rightward (shorten substring). Measure the longest length of substring at each expansion. 7.2.2.1 Analysis Time complexity is O(n) as every letter is visited once. 7.2.2.2 Algorithm 7.2.2.3 Java Code - Sliding Window public int lengthOfLongestSubstring(String s) { int len = s.length(); Set&lt;Character&gt; uniqueChars = new HashSet&lt;&gt;(); int maxLen = 0, right = 0, left = 0; while( right &lt; len &amp;&amp; left &lt; len) { //looking for longest repeating unique substring [left, right] if(!uniqueChars.contains(s.charAt(right))) { //unique char, expand substring uniqueChars.add(s.charAt(right)); right++; maxLen = Math.max(maxLen, right - left); } else { //not unique, shorten substring uniqueChars.remove(s.charAt(left)); left++; } } return maxLen; } "],
["find-kth-largest-element-in-an-array-leetcode-215-medium.html", "7.3 Find \\(k^{th}\\) Largest Element in an Array / LeetCode 215 / Medium", " 7.3 Find \\(k^{th}\\) Largest Element in an Array / LeetCode 215 / Medium 7.3.1 Description Find the \\(k^{th}\\) largest element in an unsorted array. Note that it is the \\(k^{th}\\) largest element in the sorted order, not the \\(k^{th}\\) distinct element. 7.3.2 Example Input: [3,2,1,5,6,4] and k = 2. Output: 5 Input: [3,2,3,1,2,4,5,5,6] and k = 4. Output: 4 7.3.3 Solution 7.3.3.1 Walkthrough Retrieving the \\(k^{th}\\) largest element equals to retriving smallest element in a k-sized min-heap - The value of each node is equal to or greater than the value of its parent node and root has the smallest value. Therefore, we need to maintain a min-heap (PriorityQueue in java) of while inserting new element. Below illustrated how to track a 2nd largest element from a min heap 3 -&gt; [3*] 2 -&gt; [2*, 3] 1 -&gt; 1, [2*, 3] 5 -&gt; 1, 2, [3*, 5] 6 -&gt; 1, 2, 3, [5*, 6] 4 -&gt; 1, 2, 3, 4, [5*, 6] Finally, return root as it is the smallest element (*) in the heap. 7.3.3.2 Analysis In addition, add() and remove() take \\(O(log(k))\\), since there are at most k element. Thus, total time complexity is \\(O(n \\cdot log(k))\\). Total Auxiliary Space is O(k) due to size of the heap. 7.3.3.3 Algorithm heap 1.2.15 7.3.3.4 Java Code public int findKthLargest(int[] nums, int k) { Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(); for(int num: nums) { helper(num, k); } // return the smallest element (root) from heap return heap.peek(); } private void helper(int num, int size) { heap.add(num); if(heap.size() &gt; size) { //remove smallest element from min-heap heap.remove(); } } "],
["merge-k-sorted-arrays.html", "7.4 Merge K Sorted Arrays", " 7.4 Merge K Sorted Arrays 7.4.1 Description 7.4.2 Example 7.4.3 Solution - Min Heap 7.4.3.1 Walkthrough This is similar to the problem of merging K sorted list. we could compare every leading elements in k array and retrieve the node with the smallest value using Min Heap. Since the original k arrays were sorted, therefore, we could retrieve all \\(n \\cdot k\\) elements in sorted order by retrieve the min element from PriorityQueue. 7.4.3.2 Analysis The comparison cost is O(log(k)) for every pop and insertion to priority queue since there are at most k elements (from k arrays). Additionally, there are a total number of n nodes in all arrays. Thus, the overall time complexity is \\(O(n \\cdot log(k))\\) and Auxiliary Space for the ﬁnal array is O(n), where n is the total node number in all k arrays. 7.4.3.3 Algorithm heap 1.2.15 7.4.3.4 Java Code- Min Heap class ArrayContainer implements Comparable&lt;ArrayContainer&gt; { int [] array; int index; public ArrayContainer(int[] data, int idx) { array = data; index = idx; } public void advanceIndex() { index++; } @Override public int compareTo(ArrayContainer that) { //comparing element from both arrays at index return this.array[index] - that.array[index]; } } int[] mergeSortedArray(int[][] arrays) { Queue&lt;ArrayContainer&gt; queue = new PriorityQueue&lt;ArrayContainer&gt;(); int numOfElements = 0; // init queue w.r.t. first element of each array for(int i = 0; i &lt; arrays.length; i++) { queue.offer(new ArrayContainer(arrays[i], 0)); numOfElements += arrays[i].length; } int mainIdx = 0; int result[] = new int[numOfElements]; while(!queue.isEmpty()) { // return the array at index which is the smallest element in queue ArrayContainer cantainer = queue.poll(); result[mainIndex] = cantainer.array[index]; mainIndex++; // advance the index and re-add to the queue if(cantainer.index &lt; cantainer.array.length - 1) { cantainer.advanceIndex(); queue.offer(cantainer); } } return result; } "],
["my-calendar-i-leetcode-729-medium.html", "7.5 My Calendar I / LeetCode 729 / Medium", " 7.5 My Calendar I / LeetCode 729 / Medium 7.5.1 Description Implement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking. Your class will have the method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start &lt;= x &lt; end. A double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.) For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar. 7.5.2 Example 7.5.3 Solution - Interval Data Structure 7.5.3.1 Walkthrough We could implment a Data Structure to illustrate a duration interval which has a method to evaluate if this interval is overlapping with another interval. 7.5.3.2 Analysis Time complexity is O(n) for each query as every booking is visited once in the list. 7.5.3.3 Algorithm 7.5.3.4 Java Code - Interval Data Structure class Booking { public int start; public int end; public Booking(int start, int end) { this.start = start; this.end = end; } public boolean isOverlapped(Booking that) { // this: |--------| // that: |------| if(isBetween(this.end, that.start, that.end)) { return true; } else if(isBetween(that.end, this.start, this.end)) { // this: |------| // that: |--------| return true; } else { return false; } } private boolean isBetween(int target, int start, int end) { return target &gt; start &amp;&amp; target &lt;= end; } } class MyCalendar { private List&lt;Booking&gt; bookings = new ArrayList&lt;&gt;(); public boolean book(int start, int end) { Booking newBooking = new Booking(start, end); for(Booking existedBooking : bookings) { if(existedBooking.isOverlapped(newBooking)) { return false; } } bookings.add(newBooking); return true; } } 7.5.4 Solution - TreeMap 7.5.4.1 Walkthrough Alternatively, we could leverage TreeMap to retrieve the logical relations between keys by calling lowerKey(). The lowerKey() method is used to find the next greatest element after the element passed as the parameter. 7.5.4.2 Analysis Time complexity is O(log(n)) for each query as TreeMap takes O(log(n)) to find the location to insert. 7.5.4.3 Algorithm 7.5.4.4 Java Code - TreeMap class MyCalendar { private TreeMap&lt;Integer, Integer&gt; bookings = new TreeMap&lt;&gt;(); public boolean book(int start, int end) { Integer nextStart = bookings.lowerKey(end); // check if the next closest interval of which end time is less than start time if (nextStart == null || bookings.get(nextStart) &lt;= start) { // either no interval start time &lt; end // existed interval end time &gt; start bookings.put(start, end); return true; } else { return false; } } } "],
["searching-and-sorting.html", "Chapter 8 Searching and Sorting\n", " Chapter 8 Searching and Sorting\n"],
["sort-a-list-leet-code-148-medium.html", "8.1 Sort a List / Leet Code 148 / Medium", " 8.1 Sort a List / Leet Code 148 / Medium 8.1.1 Description Sort a linked list in O(n log n) time using constant Auxiliary Space. 8.1.2 Example Input: Figure 8.1: Some caption. Output: Figure 8.2: Some caption. 8.1.3 Solution 8.1.3.1 Walkthrough With the idea of Merge sort: Divide the list in half by finding the middle element of the list. Need to remove the link of middle node which was previously links to mid - likely the last node in the 1st half list. Invoke sortList() recurisvely on two sub-lists Merge and sort against two sub-lists and return head of the list. 8.1.3.2 Analysis In such recursive call to sortList() - O(log(n)) and merge() - O(n), each call creates constant number of temporary nodes. For all rounds, it will require \\(O(1)\\) of Auxiliary Space. (Unlike time complexity, storage space in recusive scenario can be reused; and thus, will remain \\(O(1)\\) for all rounds) 8.1.3.3 Algorithm dnc 1.2.10, recursion 1.2.5, ms 1.2.12 8.1.3.4 Java Code public ListNode sortList(ListNode head) { if (head == null || head.next == null) { return head; } ListNode midPrev = null, mid = head, tail = head; while (tail != null &amp;&amp; tail.next != null) { midPrev = mid; //mid moves one node at a time mid = mid.next; //tail moves two node at a time tail = tail.next.next; } //Remove the link of middle node which previously links to mid - likely the last node in the 1st //half list midPrev.next = null; // call sortList() recursively ListNode l1 = sortList(head); ListNode l2 = sortList(mid); return merge(l1, l2); } // merge l1 and l2 in sorted order and return the head of sorted list. private ListNode merge(ListNode l1, ListNode l2) { //Two helper nodes, headPrev.next points to the head of merged list ListNode current = new ListNode(0), headPrev = current; while (l1 != null &amp;&amp; l2 != null) { if (l1.val &lt; l2.val) { current.next = l1; l1 = l1.next; } else { current.next = l2; l2 = l2.next; } current = current.next; } // l2 is empty with l1 remaining if (l1 != null) { current.next = l1; } // l1 is empty with l2 remaining if (l2 != null) { current.next = l2; } return headPrev.next; } "],
["insertion-sort-list-leet-code-147-medium.html", "8.2 Insertion Sort List / Leet Code 147 / Medium", " 8.2 Insertion Sort List / Leet Code 147 / Medium 8.2.1 Description Sort a linked list using insertion sort. Algorithm of Insertion Sort: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. 8.2.2 Example Input: Output: 8.2.3 Solution 8.2.3.1 Walkthrough With Insertion Sort, we could construct a new list by arranging links in place. We need to do the following: Maintain pointers to node that will be insert-attempted (current) and a previously sorted nodes. At each iteration, finds the location it belongs within the sorted list, and inserts between sorted and sorted.next. Insert the current node between sorted and sorted.next Figure 8.3: Some caption. Reset sorted to head of list It repeats until no input elements remain. 8.2.3.2 Analysis There are two loops, thus time complexity is \\(O(n^2)\\) 8.2.3.3 Algorithm 8.2.3.4 Java Code public ListNode insertionSortList(ListNode head) { if (head == null) { return head; } ListNode headPrev = new ListNode(0); //new starter of the sorted list ListNode current = head; //the node will be inserted ListNode sorted = headPrev; //insert node between sorted and sorted.next while (current != null) { ListNode next = current.next; //Moving prev until sorted.next.val &gt;= current.val while (sorted.next != null &amp;&amp; sorted.next.val &lt; current.val) { sorted = sorted.next; } //insert between sorted and sorted.next current.next = sorted.next; sorted.next = current; //move sorted back to head for next round search sorted = headPrev; current = next; } return headPrev.next; } "],
["selection-sort-array-firecode-level-2.html", "8.3 Selection Sort Array / Firecode / Level 2", " 8.3 Selection Sort Array / Firecode / Level 2 8.3.1 Description 8.3.2 Example 8.3.3 Solution 8.3.3.1 Walkthrough Have two nested loops, outer loop move one by one indicating the boundary of unsorted subarray [i…j-1] vs [j … n (or n-1)], where the inner loop is to find the minimum element in unsorted array j = [i+1, … ,n-1]. Swap the found minimum element with the current element i. [[(1), 5, 6], 2, ...], min_idx = (0) [[1, 2, 5, 6], ...] 8.3.3.2 Analysis There are two loops, thus time complexity is \\(O(n^2)\\) 8.3.3.3 Algorithm 8.3.3.4 Java Code public static int[] selectionSortArray(int[] arr){ int n = arr.length; // One by one move boundary of unsorted subarray [i...j-1] vs [j ... n] for (int i = 0; i &lt; n; i++) { // Find the minimum element in unsorted array j = [i+1, ... ,n-1] int min_idx = i; for (int j = i+1; j &lt; n; j++) { if (arr[j] &lt; arr[min_idx]) { min_idx = j; } } // Swap the found minimum element with the current element int temp = arr[min_idx]; arr[min_idx] = arr[i]; arr[i] = temp; } return arr; } "],
["quick-sort-array.html", "8.4 Quick Sort Array / /", " 8.4 Quick Sort Array / / 8.4.1 Description 8.4.2 Example 8.4.3 Solution 8.4.3.1 Walkthrough First, we check the indices and continue only if there are still elements to be sorted. We get the index of the sorted pivot and use it to recursively call partition() method with the same parameters as the quickSort() method, but with different indices. As for the partition() method, this function takes the last element as the pivot. Then, checks each element and swaps it before the pivot if its value is smaller. By the end of the partitioning, all elements less then the pivot are on the left of it and all elements greater then the pivot are on the right of it. The pivot is at its final sorted position and the function returns this position. 8.4.3.2 Analysis The worst case occurs when the partition process always picks greatest or smallest element as pivot and can be \\(O(n^2)\\). In average case, the time complexity is \\(O(n \\cdot log(n))\\) 8.4.3.3 Algorithm qs 1.2.14 8.4.3.4 Java Code public void quickSort(int arr[], int begin, int end) { if (begin &lt; end) { int partitionIndex = partition(arr, begin, end); quickSort(arr, begin, partitionIndex-1); quickSort(arr, partitionIndex+1, end); } } //smaller elements go left side of pivot //larger elements go right side of pivot private int partition(int arr[], int begin, int end) { int pivot = arr[end]; //index of smaller element int i = (begin - 1); for (int j = begin; j &lt; end; j++) { /* * swap if element is smaller than pivot */ if (arr[j] &lt;= pivot) { i++; int swapTemp = arr[i]; arr[i] = arr[j]; arr[j] = swapTemp; } } //swap a[i + 1] and a[end] int swapTemp = arr[i + 1]; arr[i + 1] = arr[end]; arr[end] = swapTemp; return i + 1; } "],
["top-k-elements.html", "8.5 Top K elements", " 8.5 Top K elements 8.5.1 Description Get k largest elements in an array of size n 8.5.2 Example 8.5.3 Solution - Sort array before retrieval 8.5.3.1 Walkthrough 8.5.3.2 Analysis Sort the elements in descending order in \\(O(n \\cdot log(n))\\) Get the first k numbers of the sorted array O(k). 8.5.3.3 Algorithm 8.5.3.4 Java Code - Sort array before retrieval public int[] findFirstKElement(int[] arr, int k) { int n = arr.length; Arrays.sort(arr); int [] result = new int[k]; int index = 0; for(int i = n - 1; i &gt;= n - k - 1 &amp;&amp; i &gt;= 0; i--) { result[index++] = arr[i]; } return result; } 8.5.4 Solution - Retrieve k element during sort 8.5.4.1 Walkthrough 8.5.4.2 Analysis Modify Bubble Sort to run the outer loop at most k times. \\(O(n \\cdot k)\\) 8.5.4.3 Algorithm bs 1.2.13 8.5.4.4 Java Code - Retrieve k element during sort public int[] findFirstKElement(int[] arr, int k) { int n = arr.length; for (int i = 0; i &lt; n-1 &amp;&amp; i &lt; k; i++) { for (int j = 0; j &lt; n-i-1; j++) { if (arr[j] &gt; arr[j+1]) { // swap arr[j] and arr[j+1] int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } int [] result = new int[k]; int index = 0; for(int i = n - 1; i &gt;= n - k - 1 &amp;&amp; i &gt;= 0; i--) { result[index++] = arr[i]; } return result; } 8.5.5 Solution - MinHeap 8.5.5.1 Walkthrough Retrieving the top k largest elements equals to retriving smallest element in a k-sized min-heap for k times.The value of each node is equal to or greater than the value of its parent node and root has the smallest value. Therefore, we need to maintain a min-heap (PriorityQueue in java) of while inserting new element. Below illustrated how to track a top 2 largest elements from a min heap 3 -&gt; [3*] 2 -&gt; [2*, 3] 1 -&gt; 1, [2*, 3] 5 -&gt; 1, 2, [3*, 5] 6 -&gt; 1, 2, 3, [5*, 6] 4 -&gt; 1, 2, 3, 4, [5*, 6] Finally, return root as it is the smallest element (*) in the heap. 8.5.5.2 Analysis In addition, add() and remove() take \\(O(log(k))\\), since there are at most k element. Thus, total time complexity is \\(O(n \\cdot log(k))\\). Total Auxiliary Space is O(k) due to size of the heap. 8.5.5.3 Algorithm heap 1.2.15 8.5.5.4 Java Code public int findFirstKElement(int[] nums, int k) { Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(); for(int num: nums) { helper(num, k); } int[] result = new int[heap.size()]; int index = 0; while(!heap.isEmpty()) { result[index] = heap.remove(); index++; } // return the elements from heap in sorted order return result; } private void helper(int num, int size) { heap.add(num); if(heap.size() &gt; size) { //remove smallest element from min-heap heap.remove(); } } "],
["string-manipulation.html", "Chapter 9 String Manipulation\n", " Chapter 9 String Manipulation\n"],
["binary-representation-firecode-level-2.html", "9.1 Binary Representation / Firecode / Level 2", " 9.1 Binary Representation / Firecode / Level 2 9.1.1 Description Write a method to compute the binary representation of a positive integer. The method should return a string with 1s and 0s. 9.1.2 Example computeBinary(6) = “110” computeBinary(5) = “101” 9.1.3 Solution 9.1.3.1 Walkthrough Counting down from val to 0, each time val /= 2. if val is even number, append “0” otherwise append “1”. 9.1.3.2 Analysis Time complexity is O(log(val)) since this is the number of computation performed. 9.1.3.3 Algorithm public static String computeBinary(int val) { if(val == 0) { return &quot;0&quot;; } String result = &quot;&quot;; while(val &gt; 0) { if(val % 2 == 0) { result = &quot;0&quot; + result; } else { result = &quot;1&quot; + result; } val = val / 2; } return result; } "],
["insert-stars-firecode-level-2.html", "9.2 Insert Stars / Firecode / Level 2", " 9.2 Insert Stars / Firecode / Level 2 9.2.1 Description Given a string, recursively compute a new string where the identical adjacent characters in the original string are separated by a \"*\". 9.2.2 Example insertPairStar(“cac”) = “cac” insertPairStar(“cc”) = \"c*c\" 9.2.3 Solution 9.2.3.1 Walkthrough Use recursive call with substring() method to narrow the original string from outside and find out if there are identical adjacent characters existed. Append \"*\" if there is. 9.2.3.2 Analysis Complexity is O(n) as each alphabet is processed once. 9.2.3.3 Algorithm recursion 1.2.5 public static String insertPairStar(String s) { if(s == null) { return null; } if(s.length() == 1) { //base case return s; } else if(s.substring(0, 1).equals(s.substring(1, 2))) { //identical adjacent char return s.substring(0,1) + &quot;*&quot; + insertPairStar(s.substring(1,s.length())); } else { //recursive call return s.substring(0,1) + insertPairStar(s.substring(1,s.length())); } } "],
["word-ladder-leetcode-127-medium.html", "9.3 Word Ladder / LeetCode 127 / Medium", " 9.3 Word Ladder / LeetCode 127 / Medium 9.3.1 Description Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note: Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. 9.3.2 Example Input: beginWord = “hit”, endWord = “cog”, wordList = [“hot”,“dot”,“dog”,“lot”,“log”,“cog”] Output: 5 Explanation: As one shortest transformation is “hit” \\(-&gt;\\) “hot” \\(-&gt;\\) “dot” \\(-&gt;\\) “dog” \\(-&gt;\\) “cog”, return its length 5. 9.3.3 Solution - BFS 9.3.3.1 Walkthrough Use a queue to grow the tree that beginWord could possibly ‘mutate’ to, each time with a different character. Find the first path that generate endWord; otherwise, continue enumeration until all possibilities exhaust. 9.3.3.2 Analysis Time complexity is O(n) as each word is processed once. 9.3.3.3 Algorithm backtrack 1.2.6, bfs 1.2.2 9.3.3.4 Java Code - BFS public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) { Set&lt;String&gt; dict = new HashSet&lt;&gt;(wordList); Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.offer(beginWord); int level = 1; while (!queue.isEmpty()) { //Since we are adding element into queue dynamically, it is better to invoke //queue.size() at beginning b/c queue size would change on the fly. for (int i = queue.size(); i &gt; 0; i--) { String word = queue.poll(); if (word.equals(endWord)) { //find match to endWord return level; } //Enumerate all OTHER possible chars against word for (int j = 0; j &lt; word.length(); j++) { char[] array = word.toCharArray(); for (char c = &#39;a&#39;; c &lt;= &#39;z&#39;; c++) { //Skip on the same character if (c == word.charAt(j)) { continue; } array[j] = c; String guess = String.valueOf(array); if (dict.remove(guess)) { //if dict contains element, return true queue.offer(guess); } } } } level++; } return 0; } "],
["longest-common-prefix-leetcode-14-easy.html", "9.4 Longest Common Prefix / LeetCode 14 / Easy", " 9.4 Longest Common Prefix / LeetCode 14 / Easy 9.4.1 Description Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". 9.4.2 Example Input: [“flower”,“flow”,“flight”] Output: “fl” Input: [“dog”,“racecar”,“car”] Output: \"\" 9.4.3 Solution 9.4.3.1 Walkthrough Take the first string as pivotal string and compare it against all other strings. If there is a common character, advance the common index; otherwise, return the substring(0, commonIndex + 1); 9.4.3.2 Analysis Assume there are at most m letter in the longest string and n strings in total. The time complexity is O(m * n). 9.4.3.3 Algorithm public String longestCommonPrefix(String[] strs) { if(strs == null || strs.length == 0) { return &quot;&quot;; } int commonIdx = -1; String prefix = strs[0]; for(int i = 0; i &lt; prefix.length(); i++) { for(String str : strs) { if(str.length() == i) { //if we have reached the end of a string return prefix.substring(0, commonIdx + 1); } if(prefix.charAt(i) != str.charAt(i)) { //if one of the char does not match return commonIdx == -1 ? &quot;&quot; : prefix.substring(0, commonIdx + 1); } } commonIdx = i; } return prefix.substring(0, commonIdx + 1); } "],
["longest-common-substring.html", "9.5 Longest Common Substring", " 9.5 Longest Common Substring 9.5.1 Description Given two strings X and Y, find the length of the longest common substring. 9.5.2 Example X = “abcdxyz”, y = “xyzabcd”. Output : 4 The longest common substring is “abcd” and is of length 4. Input : X = “zxabcdezy”, y = “yzabcdezx”. Output : 6 The longest common substring is “abcdez” and is of length 6. 9.5.3 Solution 9.5.3.1 Walkthrough We first declare a 2D array to store the length of each common substring in both strings: We first initialize the 1st row and 1st column of the 2D array by checking 1st character of a string against the other string - as specified in red color in the table. Next we run two nested loops, iterating with both strings and checking if there is a common character. If there is a common character at {dp[i][j]}, where i is the position from str1 and j is the position from str2. Increment the value from {dp[i-1][j-1]} - as specified in blue color in the table. During the traversal, we could also retrive the longest length. 9.5.3.2 Analysis Both space and time complexity are \\(O(n^2)\\), where n is the length of string 9.5.3.3 Algorithm dp 1.2.7 public static int getLCSLength(String str1, String str2){ int[][] dp = new int[str1.length()][str2.length()]; //To store the length of common substring int maxLength = 0; for(int i = 0; i &lt; str2.length(); i++){ //Init the first row of 2D array dp[0][i] = (str1.charAt(0) == str2.charAt(i)) ? 1 : 0; } for(int j = 0; j &lt; str1.length(); j++){ //Init the first column of 2D array dp[j][0] = (str2.charAt(0) == str1.charAt(j)) ? 1 : 0; } for (int i = 1; i &lt; str1.length(); i++) { for (int j = 1; j &lt; str2.length(); j++) { if(str1.charAt(i) == str2.charAt(j)){ // a common character dp[i][j] = dp[i-1][j-1] + 1; maxLength = Math.max(maxLength, dp[i][j]); } else{ dp[i][j] = 0; } } } return maxLength; } "],
["longest-palindromic-substring-leetcode-5-medium.html", "9.6 Longest Palindromic Substring / LeetCode 5/ Medium", " 9.6 Longest Palindromic Substring / LeetCode 5/ Medium 9.6.1 Description Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. 9.6.2 Example Input: “babad” Output: “bab” Note: “aba” is also a valid answer. 9.6.3 Solution - Longest Common Substring 9.6.3.1 Walkthrough The idea is to check a of Longest Common Substring between the sring s and reverse(s). Take S = “abc435cba” and rev(S) = “cba534cba” for example, both “abc” and “cba” are LCS but not Palindromic Substring. When we need to further check if the substring is palindromic, we need to find the index of LCS, call that {beforeRev}. {beforeRev} = length - 1 - {j} = 9 - 1 - 2 = 6. Next we add the length of LCS at {(i,j)} : {beforeRev} + {dp[i][j]} - 1 = 6 + 3 - 1 = 8, but {i} = 2. Therefore, it is NOT palindromic. Take S = “aba435aba” and rev(S) = “aba534aba” for example, “aba” is both LCS and Palindromic Substring. When we need to further check if the substring is palindromic, we first eval {beforeRev} = length - 1 - {j} = 9 - 1 - 2 = 6 and add the length of LCS at {(i,j)}: {beforeRev} + {dp[i][j]}- 1 = 6 + 3 - 1 = 8 where {i} = 8. Therefore, it is palindromic. 9.6.3.2 Analysis Both time and Auxiliary Space take \\(O(n^2)\\) 9.6.3.3 Algorithm dp 1.2.7 9.6.3.4 Java Code - Longest Common Substring public String longestPalindrome(String s) { if (s.equals(&quot;&quot;)) { return &quot;&quot;; } String reverse = new StringBuffer(s).reverse().toString(); int length = s.length(); int maxLen = 0; int maxEnd = 0; int[][] dp = new int[length][length]; //To store the length of common substring for(int i = 0; i &lt; reverse.length(); i++){ //Init the first row of 2D array dp[0][i] = (s.charAt(0) == reverse.charAt(i)) ? 1 : 0; } for(int j = 0; j &lt; s.length(); j++){ //Init the first column of 2D array dp[j][0] = (reverse.charAt(0) == s.charAt(j)) ? 1 : 0; } for (int i = 0; i &lt; length; i++) { for (int j = 0; j &lt; length; j++) { if(s.charAt(i) == reverse.charAt(j)){ if (i &gt; 0 &amp;&amp; j &gt; 0) { dp[i][j] = dp[i - 1][j - 1] + 1; } } else{ dp[i][j] = 0; } if (dp[i][j] &gt; maxLen) { int beforeRev = length - 1 - j; //further check if it is a palindromic if (beforeRev + dp[i][j] - 1 == i) { maxLen = dp[i][j]; maxEnd = i; } } } } String result = s.substring(maxEnd - maxLen + 1, maxEnd + 1); return result; } "],
["word-break-leet-code-139-medium.html", "9.7 Word Break / Leet Code 139 / Medium", " 9.7 Word Break / Leet Code 139 / Medium 9.7.1 Description Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words. 9.7.2 Example For example, given s = “leetcode”, dict = [“leet”, “code”]. Return true because “leetcode” can be segmented as “leet code”. Input: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”] Return false. 9.7.3 Solution - Recursion 9.7.3.1 Walkthrough Consider each prefix and search it in dictionary. If the prefix is present in dictionary, we recursively search for the rest of the string and AND all sub results. 9.7.3.2 Analysis The time complexity is exponential, since there are some overlapping subproblems in the recursion tree. \\(O(2^{log(n)})\\), where n is the length of the word. 9.7.3.3 Algorithm recursion 1.2.5 9.7.3.4 Java Code - Recursion public boolean wordBreak(String word, List&lt;String&gt; dict) { int length = word.length(); // base case if (length == 0) { return true; } //else check for all words for (int i = 1; i &lt;= length; i++) { // Now we will first divide the word into two parts , // the prefix will have a length of i and check if it is   // present in dictionary ,if yes then we will check for   // suffix of length size-i recursively. if both prefix and   // suffix are present the word is found in dictionary.   if (dict.contains(word.substring(0,i)) &amp;&amp;   wordBreak(word.substring(i, length), wordDict)) { return true; } }           // if all cases failed then return false return false;         } 9.7.4 Solution - Dynamic Programming 9.7.4.1 Walkthrough Create a array of (length of string + 1). In order to ensure the string contains segment of substring in the list, we need to ensure: dp[index of segment 1]: true dp[index of segment 2]: true dp[other indices] : false Finally, we only need to check the value of dp[index of last segment]. 9.7.4.2 Analysis Assume there are at most m letter in the given string and n words in dictionary. The time complexity is O(m * n). 9.7.4.3 Algorithm dp 1.2.7 9.7.4.4 Java Code - Dynamic Programming public boolean wordBreak(String s, List&lt;String&gt; wordDict) { int n = s.length(); boolean[] dp = new boolean[n + 1]; dp[0] = true; for (int endIdx = 1; endIdx &lt;= s.length(); endIdx++) { for (String segment : wordDict) { int prevIdx = endIdx - segment.length(); /* * 1. prevIdx &gt;= 0 : to avoid IndexOutOfBoundError * 2. dp[prevIdx] : to make sure prev word is a match * 3. s.substring(prevIdx, endIdx).equals(segment) : to make sure current word is a match * * If 3 conditions match, move to next round (endIdx) */ if (prevIdx &gt;= 0 &amp;&amp; dp[prevIdx] &amp;&amp; s.substring(prevIdx, endIdx).equals(segment)) { dp[endIdx] = true; break; } } } return dp[n]; } 9.7.5 Solution - Trie with Dynamic Programming 9.7.5.1 Walkthrough Figure 9.1: Some caption. Construct a trie with each word in the dictionary with each node having a property to denote the end of word. Then construct a dynamic programming array to record if the word exists by traversing the Trie tree. Lastly, check the dp[lastIndex] value, true if the string constsis all valid words; false, otherwise. 9.7.5.2 Analysis Time complexity is O(n * h), where where n is the length of the string word and h is the average length of words in the dictionary (average hight of the tree). 9.7.5.3 Algorithm dp 1.2.7 private static class TrieNode { boolean isEnd; // next characters TrieNode [] next; public TrieNode() { this.isEnd = false; this.next = new TrieNode[26]; } } private static class Trie { TrieNode root; public Trie() { this.root=new TrieNode(); } private void insert(TrieNode root, String word, int index) { if (index == word.length()) { root.isEnd = true; return; } int charIndex = word.charAt(index) - &#39;a&#39;; if (root.next[charIndex] == null) { root.next[charIndex] = new TrieNode(); } insert(root.next[charIndex], word, index + 1); } public void insert(String word) { insert(root, word, 0); } private void lookUp(TrieNode root, String str, int start, int index, boolean [] presence) { int nextCharInStr = start + index; if (root.isEnd) { presence[nextCharInStr] = true; } if (nextCharIndex == str.length()) { return; } int charIndex = str.charAt(nextCharInStr) - &#39;a&#39;; // traverse down the trie if TrieNode / char exists if (root.next[charIndex] != null) { lookUp(root.next[charIndex], str, start, index + 1, presence); } } public void lookUp(String str, int start, boolean [] presence) { lookUp(root, str, start, 0, presence); } } public boolean wordBreak(String str, List&lt;String&gt; wordDict) { Trie trie = new Trie(); for (String word : wordDict) { trie.insert(word); } boolean [] presence = new boolean [str.length() + 1]; presence[0] = true; for(int i = 0;i &lt; str.length();i++) { if (presence[i]) { trie.lookUp(str, i, presence); } } return presence[str.length()]; } "],
["verifying-an-alien-dictionary-leetcode-953-easy.html", "9.8 Verifying an Alien Dictionary / LeetCode 953 / Easy", " 9.8 Verifying an Alien Dictionary / LeetCode 953 / Easy 9.8.1 Description In an alien language, surprisingly they also use english lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters. Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographicaly in this alien language. 9.8.2 Example Input: words = [“hello”,“leetcode”], order = “hlabcdefgijkmnopqrstuvwxyz”. Output: true Explanation: As ‘h’ comes before ‘l’ in this language, then the sequence is sorted. Input: words = [“word”,“world”,“row”], order = “worldabcefghijkmnpqstuvxyz”. Output: false Explanation: As ‘d’ comes after ‘l’ in this language, then words[0] \\(&gt;\\) words[1], hence the sequence is unsorted. Input: words = [“apple”,“app”], order = “abcdefghijklmnopqrstuvwxyz”. Output: false Explanation: The first three characters “app” match, and the second string is shorter (in size.) According to lexicographical rules “apple” \\(&gt;\\) “app”, because ‘l’ \\(&gt;\\) ‘\\(\\emptyset\\)’, where ‘\\(\\emptyset\\)’ is defined as the null character which is less than any other character. 9.8.3 Solution 9.8.3.1 Walkthrough For each pair of words, return false if the lexicographical order of the first different pair of chars provide the null char if the word is shorter than the other. Otherwise, compare pair of words until end of list 9.8.3.2 Analysis Assume there are n words, and maximum word length is m. Thus the time complexity is O(n * m). 9.8.3.3 Algorithm public boolean isAlienSorted(String[] words, String order) { //compare word by word for(int i = 0; i &lt; words.length - 1; i++) { String w1 = words[i]; String w2 = words[i + 1]; int maxLen = Math.max(w1.length(), w2.length()); for(int j = 0; j &lt; maxLen; j++) { char c1 = j &lt; w1.length() ? w1.charAt(j) : 0; char c2 = j &lt; w2.length() ? w2.charAt(j) : 0; //find the first pair of different chars if(c1 != c2) { if(isSorted(c1, c2, order)) { //sorted on the first pair of different chars break; } else { return false; } } } } return true; } private boolean isSorted(char first, char second, String order) { if(first != 0 &amp;&amp; second != 0) { return order.indexOf(first) &lt;= order.indexOf(second); } else if(first == 0) { return true; } else { //second == 0 return false; } } "],
["find-the-first-non-repeated-character-in-the-string.html", "9.9 Find The First Non-Repeated Character in the String / /", " 9.9 Find The First Non-Repeated Character in the String / / 9.9.1 Description Given a string, find the first non-repeating character in it. 9.9.2 Example For example, if the input string is “GeeksforGeeks”, then output should be ‘f’ and if input string is “GeeksQuiz”, then output should be ‘G’. 9.9.3 Solution 9.9.3.1 Walkthrough Have an array to record the count of occurrence for each alphabet int the string regardless of lower or upper case. That is, count[‘G’]++, count[‘e’]++, count[‘e’]++ so on and so forth. Therefore, if we traverse the string again, with the count we would be able to tell which is the first non repeated character if available. We should not use boolean array here since there are three outcome for each chracter: appear once appear multipe times does not appaer 9.9.3.2 Analysis The runtime complexity is O(n) as each character in string will be visited once. 9.9.3.3 Algorithm /* The method returns index of first non-repeating character in a string. If all characters are repeating then returns -1 */ int firstNonRepeating(String str) { int count[] = new int[1000]; // calculate count of each characters in the passed string for (int i = 0; i &lt; str.length(); i++) { count[str.charAt(i)]++; } for (int i = 0; i &lt; str.length(); i++) { if (count[str.charAt(i)] == 1) { return i; } } return -1; } "],
["math.html", "Chapter 10 Math\n", " Chapter 10 Math\n"],
["power-of-2-firebase-level-2.html", "10.1 Power of 2 / Firebase / Level 2", " 10.1 Power of 2 / Firebase / Level 2 10.1.1 Description Write a method - isPowOfTwo to test whether or not a given positive integer is a power of 2. 10.1.2 Example isPowOfTwo(5) = false isPowOfTwo(8) = true 10.1.3 Solution - Recursive 10.1.3.1 Walkthrough For recursive solution, we invoke recursive calls on even numbrers and return true on \\(2^0\\) = 1. Return false for other cases. For bitwise op solution, if we take 3 (011) &amp; with 4 (100) and result is 0 10.1.3.2 Analysis Time Complexity is O(log(n)) since this is the number of computation performed. 10.1.3.3 Algorithm recursion 1.2.5 10.1.3.4 Java Code - Recursive boolean isPowerOfTwo(int n) { if(num == 0) { return false; } else if( num == 1) { return true; } else if( (num &amp; 1) == 1 ) { //odd number return false; } else { return isPowOfTwo(num / 2); } } 10.1.4 Solution - Bitwise Op 10.1.4.1 Walkthrough 10.1.4.2 Analysis Time complexity is constant O(1) and Auxiliary Space is O(1). 10.1.4.3 Java Code - Bitwise Op boolean isPowerOfTwo(int num) { return (num != 0) &amp;&amp; ((num &amp; (num - 1)) == 0); } "],
["powx-n-leet-code-50-medium.html", "10.2 Pow(x, n) / Leet Code 50 / Medium", " 10.2 Pow(x, n) / Leet Code 50 / Medium 10.2.1 Description Implement pow(x, n), which calculates x raised to the power n (x^n). 10.2.2 Example 2.00000^10 = 1024.00000 2.00000^{-2} = 0.25000 10.2.3 Solution 10.2.3.1 Walkthrough Try to utilize the formula where \\(x^{n} = x^{\\frac{n}{2} + \\frac{n}{2} + (n - \\frac{n}{2} * 2)}\\), regardless n is odd or even. The terminal conditions are \\(x^0 = 1\\), \\(x^1 = x\\), \\(x^{-1} = \\frac{1}{x}\\) 10.2.3.2 Analysis Time Complexity is O(log(n)) since this is the number of computation performed. 10.2.3.3 Algorithm 10.2.3.4 Java Code public double myPow(double x, int n) { if(n == 0) { return 1.0; } if(n == 1) { return x; } if(n == -1) { return 1/x; } int remainPower = n - n/2 * 2; double halfPower = myPow(x, n/2); return halfPower * halfPower * myPow(x, remainPower); } "],
["count-primes-leet-code-204-easy.html", "10.3 Count Primes / Leet Code 204 / Easy", " 10.3 Count Primes / Leet Code 204 / Easy 10.3.1 Description Count the number of prime numbers less than a non-negative number, n. 10.3.2 Example 10.3.3 Solution 10.3.3.1 Walkthrough 10.3.3.2 Analysis Time Complexity is O() since this is the number of computation performed. 10.3.3.3 Algorithm 10.3.3.4 Java Code public int countPrimes(int n) { if (n&lt;=2) { return 0; } if (n==3) { return 1; } int r = n-2; for (int i=4; i&lt;n; i++){ for (int j=2; j&lt;=i/j; j++){ if (i%j==0) { r--; break; } } } return r; } "],
["summation-using-bitwise-operator-leetcode-371-easy.html", "10.4 Summation using Bitwise operator / LeetCode 371 / Easy", " 10.4 Summation using Bitwise operator / LeetCode 371 / Easy 10.4.1 Description Calculate the sum of two integers a and b using bitwise oeprators (operator + and - NOT allowed) ### Example 10.4.2 Solution 10.4.2.1 Walkthrough 10.4.2.2 Analysis Time Complexity is O() since this is the number of computation performed. 10.4.2.3 Algorithm 10.4.2.4 Java Code public int getSum(int a, int b) { int carry = a &amp; b; int result = a ^ b; while(carry != 0) { int shiftedcarry = carry &lt;&lt; 1; carry = result &amp; shiftedcarry; result ^= shiftedcarry; } return result; } "],
["fibonacci-sequence-firecode-level-2.html", "10.5 Fibonacci Sequence / Firecode / Level 2", " 10.5 Fibonacci Sequence / Firecode / Level 2 10.5.1 Description The Fibonacci Sequence is the series of numbers: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, … The next number is found by adding up the two numbers before it. Your goal is to write an optimal method - betterFibonacci that returns the nth Fibonacci number in the sequence. n is 0 indexed, which means that in the sequence 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, …, n == 0 should return 0 and n == 3 should return 2. Your method should exhibit a runtime complexity of O(n) and use constant O(1) space. 10.5.2 Example The \\(n_{th}\\) fibonacci number is \\[\\begin{equation} f(n) = \\begin{cases} 1 &amp; \\text{if $n = 1$} 1 &amp; \\text{if $n = 2$} f(n - 1) + f(n - 2) &amp; \\text{if $n \\gt 2$} \\end{cases} \\end{equation}\\] $ fib(3) = fib(2) + fib(1) = 2 fib(4) = fib(3) + fib(2) = 3 fib(5) = fib(4) + fib(3) = 5 $ 10.5.3 Solution - Top-down Recursion 10.5.3.1 Walkthough The recursion tree of this strategy is Figure 10.1: Some caption. There are many duplicated subproblems. 10.5.3.2 Analysis Thus, the overall time complexity is expensive, O(2^{h}) 10.5.3.3 Algorithm recursion 1.2.5 10.5.3.4 Java Code - Top-down Recursion int fib(int x) { return (x == 0 || x == 1) ? x : fib(x - 1) + fib(x - 2); } 10.5.4 Solution - Tail Recursion 10.5.4.1 Walkthough 10.5.4.2 Algorithm recursion 1.2.5 10.5.4.3 Java Code - Tail Recursion int fib(int x) { if(x &lt;= 2) { return 2; } else { return fibTailRec(x, 0, 1); } } int fibTailRec(int x, int fMinus1, int fMinus2) { if(x == 0) { return fMinus1; } return fibTailRec(x - 1, fMinus2, fMinus1 + fMinus2); } 10.5.5 Solution - Dynamic Programming (Bottom-up Iteration) 10.5.5.1 Walkthrough Define n0 and n1 and another variable to add n0 + n1. Have a loop to iterate the compute these three values from 2 to n. return n1. 10.5.5.2 Analysis Time Complexity is O(n) since this is the number of computation performed. 10.5.5.3 Algorithm dp 1.2.7 10.5.5.4 Java Code - Dynamic Programming (Bottom-up Iteration) int fib(int n) { if(n == 0) { return 0; } if(n == 1) { return 1; } int n0 = 0, n1 = 1, temp = 0; for(int i = 2; i &lt;= n; i++) { temp = n0 + n1; n0 = n1; n1 = temp; } return n1; } 10.5.6 Solution - Dynamic Programming with Memoization 10.5.6.1 Walkthough The strategy is to avoid overlapping subproblems using cache. 10.5.6.2 Analysis There will only be n + 1 subproblems computed. The time complexity is \\(O(n)\\) 10.5.6.3 Algorithm memo 1.2.8, recursion 1.2.5, dp 1.2.7 10.5.6.4 Java Code - Dynamic Programming with Memoization int fib(int x) { return fibMemoization(x, new int[x + 1]); } int fibMemoization(int x, int[] mem) { if (mem[x] != 0) { return mem[x]; } if (x == 1 || x == 2) { return 1; } int n = fibMemoization(x - 1, mem) + fibMemoization(x - 2,mem); mem[x] = n; return n; } "],
["min-operations-to-reduce-number-to-1.html", "10.6 Min operations to reduce number to 1 / /", " 10.6 Min operations to reduce number to 1 / / 10.6.1 Description Given a positive integer n and 3 operations on n: * n - 1 * n / 2 (if n is even) * n / 3 (if n \\% 3 == 0) Find the minimum number of above operations to reduce n to 1. 10.6.2 Example Input: n = 9 Output: 2 Explanation: Step 1: 9 / 3 = 3 Step 2: 3 / 3 = 1 Input: n = 8 Output: 3 Explanation: Step 1: 8 / 2 = 4 Step 2: 4 / 2 = 2 Step 3: 2 - 1 = 1 10.6.3 Solution - Recursion 10.6.3.1 Walkthrough 10.6.3.2 Analysis O(n^3) 10.6.3.3 Algorithm recursion 1.2.5 10.6.3.4 Java Code public int minHops(int num) { return rec(num, 0); } private int rec(int num, int count) { if(num &lt;= 1) { return count; } int minCount = Integer.MAX_VALUE; if( num % 3 == 0) { minCount = Math.min(minCount, rec(num / 3, count + 1)); } if( num % 2 == 0) { minCount = Math.min(minCount, rec(num / 2, count + 1)); } minCount = Math.min(minCount, rec(num - 1, count + 1)); } "],
["interactive-problems.html", "Chapter 11 Interactive Problems\n", " Chapter 11 Interactive Problems\n"],
["guess-the-word-leetcode-843-hard.html", "11.1 Guess the Word / LeetCode 843 / Hard", " 11.1 Guess the Word / LeetCode 843 / Hard 11.1.1 Description We are given a word list of unique words, each word is 6 letters long, and one word in this list is chosen as secret. You may call master.guess(word) to guess a word. The guessed word should have type string and must be from the original list with 6 lowercase letters. This function returns an integer type, representing the number of exact matches (value and position) of your guess to the secret word. Also, if your guess is not in the given wordlist, it will return -1 instead. For each test case, you have 10 guesses to guess the word. At the end of any number of calls, if you have made 10 or less calls to master.guess and at least one of these guesses was the secret, you pass the testcase. Besides the example test case below, there will be 5 additional test cases, each with 100 words in the word list. The letters of each word in those testcases were chosen independently at random from ‘a’ to ‘z’, such that every word in the given word lists is unique. 11.1.2 Example Input: secret = “acckzz”, wordlist = [“acckzz”,“ccbazz”,“eiowzz”,“abcczz”] master.guess(“aaaaaa”) returns -1, because “aaaaaa” is not in wordlist. master.guess(“acckzz”) returns 6, because “acckzz” is secret and has all 6 matches. master.guess(“ccbazz”) returns 3, because “ccbazz” has 3 matches. master.guess(“eiowzz”) returns 2, because “eiowzz” has 2 matches. master.guess(“abcczz”) returns 4, because “abcczz” has 4 matches. We made 5 calls to master.guess and one of them was the secret, so we pass the test case. 11.1.3 Solution 11.1.3.1 Walkthrough At start of the game, we simply have the choice of using each word in the wordlist to call master API, but as we are getting more and more feedbacks from the API, we should eliminate some choice by only keeping the words that have the same number of character matches as the match number returned from the master API. Then we use those words as the possible choices in the next round. Simply adapting the above strategy should give us a pretty good performance in terms of minimizing the number of calls to the master API. However, we could use minimax strategy to further improve the accuracy of our guesses at each round by avoiding choices that has little or no effect of reducing the number of choices we have to make in the next round. The idea is simply to make a choice that minimizes the maximum possible number of choices (worst outcome) we have to make at each time that we call master.guess(word). 11.1.3.2 Analysis Time Complexity is O() since this is the number of computation performed. 11.1.3.3 Algorithm minimax 1.2.4 11.1.3.4 Java Code final int N = 6; public void findSecretWord(String[] words, Master master) { List&lt;Integer&gt; wordIdxList = new ArrayList&lt;&gt;(); //init dictionary for (int idx = 0 ; idx &lt; words.length; idx++) { wordIdxList.add(idx); } while (wordIdxList.size() &gt; 0) { int minLoss = Integer.MAX_VALUE; int minIdx = -1; for (int idx : wordIdxList) { int loss = maxLoss(idx, words, wordIdxList); /* minimizes the possible number of choices (worst outcome) to make at each time that we call master.guess */ if (loss &lt; minLoss) { minLoss = loss; minIdx = idx; } } int match = master.guess(words[minIdx]); //made the correct guess, return if (match == N) { return; } List&lt;Integer&gt; nextIdxList = new ArrayList&lt;&gt;(); for (int idx: wordIdxList) { if (similarity(words[minIdx], words[idx]) == match) { nextIdxList.add(idx); } } wordIdxList = nextIdxList; } } /* * Retrieve the MAX # of word from CURRENT dict that has the same similarity with * guessed word, where guessWord != candidateWord. */ private int maxLoss(int guessIdx, String[] words, List&lt;Integer&gt; wordIdxList) { int[] bucket = new int[N]; int maxScore = 0; for (int idx : wordIdxList) { String guess = words[guessIdx]; String candidate = words[idx]; if (!guess.equals(candidate)) { int score = similarity(guess, candidate); bucket[score]++; } } for(int score : bucket) { maxScore = Math.max(maxScore, score); } return maxScore; } private int similarity(String s1, String s2) { int match = 0; for (int i = 0; i &lt; N; i++) { match += s1.charAt(i) == s2.charAt(i) ? 1 : 0; } return match; } \\end{lstlisting} "],
["advanced-data-structure.html", "Chapter 12 Advanced Data Structure\n", " Chapter 12 Advanced Data Structure\n"],
["design-a-lru-cache-leetcode-146-medium.html", "12.1 Design a LRU Cache / LeetCode 146 / Medium", " 12.1 Design a LRU Cache / LeetCode 146 / Medium 12.1.1 Description Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. The cache is initialized with a positive capacity. ### Example LRUCache cache = new LRUCache( 2 /* capacity */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // returns 1 cache.put(3, 3); // evicts key 2 cache.get(2); // returns -1 (not found) cache.put(4, 4); // evicts key 1 cache.get(1); // returns -1 (not found) cache.get(3); // returns 3 cache.get(4); // returns 4 12.1.2 Solution - Naive 12.1.2.1 Walkthrough Have a internal map to store cache data and doubly linked list to keep track history of data usage. The head node indicate it was recently used where the tail node represents data that were . That is, get(4) would change the cache: Figure 12.1: Some caption. In addition, put\\((4, v_2)\\) would change the cache: Figure 12.2: Some caption. 12.1.2.2 Analysis There is a Map used as internal cache and each public method will leverage this internal cache as storage, and thus each public method cost O(1) overhead. The Auxiliary Space is O(n) 12.1.2.3 Algorithm 12.1.2.4 Java Code - Naive class LRUCache { // Doubly Linked List class Node { int key; int data; private Node prev; private Node next; public Node(int key, int data) { this.key = key; this.data = data; } } private int capacity; // internal cache private Map&lt;Integer, Node&gt; cache = new HashMap&lt;&gt;(); private Node head; private Node tail; public LRUCache(int capacity) { this.capacity = capacity; } public int get(int key) { if (cache.containsKey(key)) { Node node = cache.get(key); //Reset the node to head position remove(node); setHead(node); return node.data; } return -1; } public void put(int key, int value) { if (cache.containsKey(key)) { Node old = cache.get(key); old.data = value; //Reset the node to head position remove(old); setHead(old); } else { // Put new &lt;key, val&gt; Node newNode = new Node(key, value); if (cache.size() &gt;= capacity) { //Cache is FULL. Remove tail cache.remove(tail.key); // remove LRU data from cache. remove(tail); setHead(newNode); } else { setHead(newNode); } cache.put(key, newNode); } } private void remove(Node node) { if (node == head) { // remove a head head = node.next; } else { // remove a non-head node.prev.next = node.next; } if (node == tail) { // remove a tail tail = node.prev; } else { // remove a non-head node.next.prev = node.prev; } } private void setHead(Node node) { node.next = head; node.prev = null; if (head != null) { // insert a new head node head.prev = node; } head = node; if (tail == null) { // insert first tail node tail = head; } } } 12.1.3 Solution - LinkedHashMap 12.1.3.1 Walkthrough An extended LinkedHashMap is to retrieve elements in the order in which they were last accessed. A special constructor is used to create this type of LinkedHashMap: new LinkedHashMap(initialCapacity, loadFactor, true) - the true means “accessOrder” instead of the “insertionOrder”. 12.1.3.2 Analysis 12.1.3.3 Algorithm 12.1.3.4 Java Code - LinkedHashMap public class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; { // indicate the capacity of cache. private final int maxEntries; private static final int DEFAULT_INITIAL_CAPACITY = 16; private static final float DEFAULT_LOAD_FACTOR = 0.75f; public LRUCache(int initialCapacity, float loadFactor, int maxEntries) { super(initialCapacity, loadFactor, true); this.maxEntries = maxEntries; } public LRUCache(int initialCapacity, int maxEntries) { this(initialCapacity, DEFAULT_LOAD_FACTOR, maxEntries); } public LRUCache(int maxEntries) { this(DEFAULT_INITIAL_CAPACITY, maxEntries); } protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) { return size() &gt; maxEntries; } } "],
["design-a-stack.html", "12.2 Design a Stack", " 12.2 Design a Stack 12.2.1 Description Stack is a LIFO data structure. 12.2.2 Example push 1: [1] push 2: [1] \\(\\rightarrow\\) [2] pop returns 2 12.2.3 Solution - Queue 12.2.3.1 Walkthrough Since a Queue is FIFO, that is first element will be processed first. Thus, we want to keep the top element to be inserted first. To achieve that, we could use a temp Stack to reverse the order after enqueue the added item into the stack first (will be processed first). 12.2.3.2 Analysis enqueue(item) takes O(n) time. dequeue() takes O(1) as it is only polling the top element. 12.2.3.3 Algorithm 12.2.3.4 Java Code - Queue class MyQueueBasedStack&lt;T&gt; { private Queue&lt;T&gt; value = new LinkedList&lt;&gt;(); public void push(T item) { Queue&lt;T&gt; temp = new LinkedList&lt;&gt;(); temp.enqueue(item); while(!value.isEmpty()) { temp.enqueue(value.dequeue()); } value = temp; } public void pop() { return value.poll(); } public T top() { return value.peek(); } public boolean empty() { return value.isEmpty(); } public int size() { return value.size(); } } "],
["design-a-queue.html", "12.3 Design a Queue", " 12.3 Design a Queue 12.3.1 Description Queue is a FIFO data structure 12.3.2 Example enqueue 1: [1] enqueue 2: [1] \\(\\rightarrow\\) [2] dequeue returns 1 12.3.3 Solution - Array 12.3.3.1 Walkthrough With array implementation, there is a need to resize when enqueueing exceeds limits. Thus, in average case, enqueue is constatnt time but will be O(n) in worst case. In order to mitigate this cost, we could init the Queue with an immutable large array. Each dequeue will move an index to the next element. Finally, there could be a background thread to periodically compact this immutable implementation into a new queue. enqueue(item) takes O(1) time, but O(n) when resize() is involved. dequeue() takes O(n) time search(val) takes O(n) as it traverse all elements. 12.3.3.2 Algorithm 12.3.3.3 Java Code - Array public class MyArrayQueue&lt;T&gt; { private T [] array; // position of last element private int endPos = -1; private static final int DEFAULT_INITIAL_CAPACITY = 10; public MyArrayQueue() { array = (T[]) new Object[DEFAULT_INITIAL_CAPACITY]; } public MyArrayQueue(int initialCapacity) { array = (T[]) new Object[initialCapacity]; } public boolean isEmpty() { return endPos == -1; } public int size() { return endPos + 1; } private void resize(int newSize) { System.out.println(&quot;Resizing from &quot; + array.length + &quot; to &quot; + newSize); T[] newArray = Arrays.copyOfRange(array, 0, newSize); array = newArray; } // add the item public void enqueue(T item) { Objects.requireNonNull(item); if( (endPos + 1) &gt;= array.length) { resize(2 * array.length); } endPos++; array[endPos] = item; } // remove first item public T dequeue() { if(endPos == -1) { throw new IllegalStateException(); } // return the first element T result = array[0]; //move the element one backward for(int i = 0; i &lt; endPos; i++) { array[i] = array[i+1]; } //nullify last position array[endPos] = null; endPos--; return result; } public boolean search(int val) { if(index &gt; endPos) { throw new IllegalStateException(); } for(int i = 0; i &lt;= endPos; i++) { if(array[i] == val) { return true; } } return false; } } 12.3.4 Solution - LinkedList 12.3.4.1 Walkthrough 12.3.4.2 Analysis * enqueue(item) takes O(1) time. %* enqueue(i, item) takes O(n) time to traverse to the previous element. * dequeue() takes O(1) %* dequeue(i) takes O(n) time to traverse to the previous element. * search(val) takes O(n) as it traverses all elements. 12.3.4.3 Algorithm 12.3.4.4 Java Code public class MyLinkedQueue&lt;T&gt; { private static class Node&lt;T&gt; { Node next; T data; } private Node&lt;T&gt; head; private Node&lt;T&gt; tail; // position of last element private int endPos = -1; private static final int DEFAULT_INITIAL_CAPACITY = 10; public boolean isEmpty() { return endPos == -1; } public int size() { return endPos + 1; } // add the item public void enqueue(T item) { Objects.requireNonNull(item); endPos++; Node newNode = new Node(); newNode.data = item; if(head == null) { head = newNode; } if(tail == null) { tail = newNode; } else { //insert to the tail of the list tail.next = newNode; tail = newNode; } } // remove and return a random item public T dequeue() { if(endPos == -1) { throw new IllegalStateException(); } // return the first node Node dieNode = head; //head == tail if(head.next == null) { head = null; tail = null; } else { head = head.next; } endPos--; return (T) dieNode.data; } public boolean search(int val) { if(index &gt; endPos) { throw new IllegalStateException(); } Node cursor = head; for(int i = 0; i &lt;= endPos; i++) { if(cursor.data == val) { return true; } cursor = cursor.next; } return false; } } 12.3.5 Solution - Stack 12.3.5.1 Walkthrough Since a Stack is LIFO, that is last element will be processed first. Thus, we want to keep the top element to be inserted last. To achieve that, we could use a temp Stack to reverse the order after pushing the added item into the stack first (will be processed last). 12.3.5.2 Analysis enqueue(item) takes O(n) time. dequeue() takes O(1) as it is only popping the top element. 12.3.5.3 Algorithm 12.3.5.4 Java Code - Stack class MyStackBasedQueue&lt;T&gt;() { private Stack&lt;T&gt; value = new Stack&lt;&gt;(); public void enqueue(T item) { if(value.isEmpty()) { // first element value.push(item); } else { Stack&lt;T&gt; temp = new Stack&lt;&gt;(); //1. Store previous element in temp while(!value.isEmpty()) { temp.push(value.pop()); } //2. push item to the back of the stack value.push(item); //3. reload the previous elements while(!temp.isEmpty()) { value.push(temp.pop()); } } } public T dequeue() { T result = value.top(); value.pop(); return result; } public int size() { return value.size(); } public T peek() { return value.top(); } public boolean empty() { return value.isEmpty(); } } "],
["design-a-hashset-leetcode-705-easy.html", "12.4 Design a HashSet / LeetCode 705 / Easy", " 12.4 Design a HashSet / LeetCode 705 / Easy 12.4.1 Description Design a HashSet without using any built-in hash table libraries. To be specific, your design should include these functions: add(value): Insert a value into the HashSet. contains(value) : Return whether the value exists in the HashSet or not. remove(value): Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing. 12.4.2 Example 12.4.3 Solution 12.4.3.1 Walkthrough A HashSet consists of an array of Node where its position is determined by a hash value / hash function. When there is a collision, we could chain the collided values together using a LinkedList or a Tree. For add() operation, we need to intensionally skip the duplicated key if the it already exists (from contains(key)) 12.4.3.2 Analysis The performance of each operation heavily depends on effectiveness of hash function. A good hash function would result in less collision, that is less traversal needed for the chaining list, but likely more auxiliary space required. Best case for each operation takes O(1). However, In worst case scenario, if it performs all elements on the same chaining list, all methods can take up to O(n). 12.4.3.3 Algorithm 12.4.3.4 Java Code - LinkedList for Chaining class Node { public int key; public Node next; } class MyHashSet { private Node[] list; private int size; public MyHashSet() { this.size = 10000; this.list = new Node[this.size]; } public void add(int key) { int index = key % this.size; if(contains(key)){ //skip for duplicated entry } else { //add as head of chaining Node oldHead = list[index]; Node newNode = new Node(); newNode.key = key; newNode.next = oldHead; list[index] = newNode; } } public void remove(int key) { int index = key % this.size; if(contains(key)) { Node current = list[index]; if(current.key == key) { // replace head of chaining list[index] = current.next; } else { // replace the middle of chaining Node prev = current; while(current != null &amp;&amp; current.key != key) { prev = current; current = current.next; } prev.next = current.next; } } else { //skip since not exist } } public boolean contains(int key) { int index = key % this.size; Node current = list[index]; while(current != null) { if(current.key == key) { return true; } current = current.next; } return false; } } "],
["design-a-hashmap-leetcode-706-easy.html", "12.5 Design a HashMap / LeetCode 706 / Easy", " 12.5 Design a HashMap / LeetCode 706 / Easy 12.5.1 Description Design a HashMap without using any built-in hash table libraries. To be specific, your design should include these functions: put(key, value) : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value. get(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key. remove(key) : Remove the mapping for the value key if this map contains the mapping for the key. 12.5.2 Example 12.5.3 Solution 12.5.3.1 Walkthrough A HashMap consists of an array of Node where its position is determined by a hash value / hash function. When there is a collision, we could chain the collided values together using a LinkedList or a Tree. One thing different from HashSet implementation is that we need to update the (key, val) entry if key already exists. 12.5.3.2 Analysis * add() : Best case takes O(1). * get(): Best case takes O(1) * remove(): Best case takes O(1). However, In worst case scenario, if it performs all elements on the same chaining list, all methods can be O(n). 12.5.3.3 Algorithm 12.5.3.4 Java Code - LinkedList for Chaining class Node { public int key; public int val; public Node next; } class MyHashMap { private Node[] list; private int size; /** Initialize your data structure here. */ public MyHashMap() { this.size = 10000; this.list = new Node[this.size]; } public void put(int key, int val) { Node result = getNode(key); if(result != null){ //if exist, update value result.val = val; } else { Node newNode = new Node(); newNode.key = key; newNode.val = val; //add as head of chaining int index = key % this.size; Node oldHead = list[index]; newNode.next = oldHead; list[index] = newNode; } } public int get(int key) { Node result = getNode(key); if(result != null) { return result.val; } else { return -1; } } public void remove(int key) { int index = key % this.size; if(exist(key)) { Node head = list[index]; if(head.key == key) { // replace head of chaining list[index] = head.next; } else { // replace the middle of chaining Node current = head; Node prev = head; while(current != null &amp;&amp; current.key != key) { prev = current; current = current.next; } prev.next = current.next; } } else { //skip since not exist } } private boolean exist(int key) { return getNode(key) != null; } private Node getNode(int key) { int index = key % this.size; Node current = list[index]; while(current != null) { if(current.key == key) { return current; } current = current.next; } return null; } } "],
["references.html", "References", " References "]
]
