# Arrays
If we are enumerating the cartesian products over two arrays of n elements.

```
A = [A_1, A_2, ..., A_n]
B = [B_1, B_2, ..., B_n]
A1 X A2 = [(A_1, B_1), (A_1, B_2), ..., (A_n, B_n)]
```

The time complexity is O(n^2).

```java
for(int i = 0; i < A.length; i++) {
    for(int j = 0; j < B.length; j++) {
        // process each (A_i, B_j)
    }
}
```

If we only need to enumerate part of the combination over two arrays while traversing both arrays simultaneously.

```
A = [A_1, A_2, ..., A_n]
B = [B_1, B_2, ..., B_n]
A1 X A2 = [(A_1, B_1), (A_2, B_1), (A_2, B_2), ..., (A_n, B_n)]
```

we could possibly reduce the complexity to O(n)

```java
for(int i = 0, j = 0; i < A.length; j < B.length;) {
    int a = A[i];
    int b = B[j];

    if(a < b) {
        i++;
    } else if(a > b) {
        j++;
    }
}
```



## Two Sums I {#two-sum-1}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 1
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/two-sum/
- **Tags**: `Hash Table`, `Array`
- **Techniques**: Hash Table, Two Pointers

### Description

Given an array of integers `nums` and an integer `target`, return **indices** of the two numbers such that they add up to `target`.

You may assume that each input would have **exactly one solution**, and you may **not use the same element twice**.

You can return the answer in any order.

### Examples

**Example 1:**
```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

**Example 2:**
```
Input: nums = [3,2,4], target = 6
Output: [1,2]
```

**Example 3:**
```
Input: nums = [3,3], target = 6
Output: [0,1]
```

### Constraints

- `2 <= nums.length <= 10^4`
- `-10^9 <= nums[i] <= 10^9`
- `-10^9 <= target <= 10^9`
- **Only one valid answer exists**

### Solution - Hash Table Approach

#### Walkthrough

Use a HashMap to store each element and its associated index as key-value pairs $<$nums[i], i$>$.

For each element `nums[i]`, calculate `diff = target - nums[i]` and check if `diff` exists in the HashMap:
- If yes: return the indices `[map.get(diff), i]`
- If no: store current element and index `map.put(nums[i], i)`

This allows us to find the complement in O(1) time.

#### Analysis

- **Time Complexity**: O(n) - Single pass through array, each lookup/insert is O(1)
- **Space Complexity**: O(n) - Hash map stores up to n elements

#### Algorithm

Hash Table \@ref(hash-table)

1. Initialize an empty `HashMap<Integer, Integer>` to store `<value, index>` pairs.
2. For each index `i` from `0` to `nums.length - 1`:
   1. Compute `diff = target - nums[i]`.
   2. If `diff` is already in the map, return `[map.get(diff), i]`.
   3. Otherwise, record the current value with `map.put(nums[i], i)`.
3. Return an empty array (the problem guarantees this line is unreachable).

#### Java Code

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();

    for (int i = 0; i < nums.length; i++) {
        int diff = target - nums[i];

        if (map.containsKey(diff)) {
            return new int[]{map.get(diff), i};
        }

        map.put(nums[i], i);
    }

    return null;
}
```

### Alternative Solution - Storing Difference

#### Walkthrough

Similar to the previous approach, but instead of storing the current number, store the **difference** (target - nums[i]) in the hash map.

#### Java Code

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();

    for (int i = 0; i < nums.length; i++) {
        int num = nums[i];

        if (map.containsKey(num)) {
            return new int[]{map.get(num), i};
        }

        int diff = target - nums[i];
        map.put(diff, i);
    }

    return null;
}
```

## Two Sum II - Input Array Is Sorted {#two-sum-ii-sorted}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 167
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/
- **Tags**: `Array`, `Two Pointers`, `Binary Search`
- **Techniques**: Two Pointers \@ref(two-pointers), Binary Search \@ref(binary-search)

### Description

Given a 0-indexed array `numbers` that is sorted in non-decreasing order, find **two** numbers such that they add up to a specific `target`. Return the **1-indexed** positions `[index1, index2]` where `0 <= index1 < index2 < numbers.length`. Exactly one valid answer exists, and each element may be used at most once.

### Examples

**Example 1**
```
Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: numbers[0] + numbers[1] = 9, so we return indices shifted by one.
```

### Constraints

- `2 <= numbers.length <= 3 * 10^4`
- `-1000 <= numbers[i] <= 1000`
- `-1000 <= target <= 1000`
- `numbers` is sorted in non-decreasing order
- Exactly one solution exists

### Solution - Two Pointers

#### Walkthrough

Use two indices, `left` at the start and `right` at the end of the array. Compare `numbers[left] + numbers[right]` with the target and shrink the window from the side that makes the sum move toward the target. Because the array is sorted, moving the pointers monotonically guarantees we visit each pair at most once.

#### Analysis

- **Time Complexity**: O(n) — each pointer moves at most `numbers.length` steps
- **Space Complexity**: O(1)

#### Algorithm

1. Initialize `left = 0`, `right = numbers.length - 1`.
2. While `left < right`:
   1. Let `current = numbers[left] + numbers[right]`.
   2. If `current == target`, return `[left + 1, right + 1]`.
   3. If `current < target`, increment `left` to increase the sum.
   4. Otherwise, decrement `right` to decrease the sum.
3. Return an empty array (the problem guarantees this branch is unreachable).

#### Java Code

```java
public int[] twoSum(int[] numbers, int target) {
    int left = 0;
    int right = numbers.length - 1;

    while (left < right) {
        int sum = numbers[left] + numbers[right];

        if (sum == target) {
            return new int[]{left + 1, right + 1};
        }

        if (sum < target) {
            left++;
        } else {
            right--;
        }
    }

    return new int[0];
}
```

### Solution - Binary Search

#### Walkthrough

Iterate through each index `i`, treat `numbers[i]` as the first addend, and binary-search for `target - numbers[i]` in the suffix `[i + 1, n)`. Sorting guarantees binary search is valid, and we avoid reusing the same element by only searching to the right.

#### Analysis

- **Time Complexity**: O(n log n) — one binary search per element
- **Space Complexity**: O(1)

#### Algorithm

1. Loop `i` from `0` to `numbers.length - 2`.
2. Set `complement = target - numbers[i]`.
3. Binary search for `complement` in `[i + 1, numbers.length)`.
4. If found at `j`, return `[i + 1, j + 1]`.

#### Java Code

```java
public int[] twoSumBinarySearch(int[] numbers, int target) {
    for (int i = 0; i < numbers.length - 1; i++) {
        int complement = target - numbers[i];
        int j = binarySearch(numbers, i + 1, numbers.length - 1, complement);

        if (j != -1) {
            return new int[]{i + 1, j + 1};
        }
    }

    return new int[0];
}

private int binarySearch(int[] numbers, int left, int right, int target) {
    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (numbers[mid] == target) {
            return mid;
        } else if (numbers[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;
}
```

## Two Sum II - Return True or False {#two-sum-ii-boolean}

### Problem Metadata

- **Platform**: Other
- **Problem ID**: N/A
- **Difficulty**: Easy
- **URL**: N/A
- **Tags**: `Array`, `Hash Table`
- **Techniques**: Hash Table \@ref(hash-table)

### Description

Given an integer array `nums` and an integer `k`, determine whether there exists a pair of distinct elements whose sum equals `k`. Return `true` if such a pair exists; otherwise, return `false`.

### Examples

**Example 1**
```
Input: nums = [1,3,7], k = 8
Output: true
Explanation: 1 + 7 = 8.
```

**Example 2**
```
Input: nums = [1,3,7], k = 6
Output: false
```

### Constraints

- `2 <= nums.length <= 10^5`
- `-10^9 <= nums[i], k <= 10^9`

### Solution - Hash Set

#### Walkthrough

Scan the array once while storing previously seen values in a `HashSet`. For each `num`, compute `diff = k - num`. If `diff` already exists in the set, we have found a valid pair; otherwise, add `num` to the set and keep scanning.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(n) — set of seen values

#### Algorithm

1. Create an empty `HashSet<Integer>`.
2. For each `num` in `nums`:
   1. Let `diff = k - num`.
   2. If `diff` exists in the set, return `true`.
   3. Otherwise, insert `num` into the set.
3. Return `false`.

#### Java Code

```java
public boolean sumsToTarget(int[] nums, int k) {
    Set<Integer> seen = new HashSet<>();

    for (int num : nums) {
        int diff = k - num;

        if (seen.contains(diff)) {
            return true;
        }

        seen.add(num);
    }

    return false;
}
```

## Two Sum IV - Input is a BST {#two-sum-iv-bst}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 653
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/two-sum-iv-input-is-a-bst/
- **Tags**: `Tree`, `Binary Search Tree`, `Hash Table`
- **Techniques**: Depth First Search \@ref(dfs), Hash Table \@ref(hash-table)

### Description

Given the root of a Binary Search Tree and an integer `k`, return `true` if there exist **two distinct nodes** whose values sum to `k`. Otherwise, return `false`.

### Examples

```{r, echo=FALSE, engine='tikz', out.width='90%', fig.ext=if (knitr:::is_latex_output()) 'pdf' else 'png', fig.cap='BST used in the example.', engine.opts = list(template = "latex/tikz2pdf.tex")}
\begin{tikzpicture}[
level 1/.style={sibling distance=10em},
level 2/.style={sibling distance=5em},
level 3/.style={sibling distance=5em},
level distance=2.5em,
]
\node {5}
    child { node {3}
        child {  node {2} }
        child {  node {4} }
    }
    child { node {6}
        child {  node {7} }
    }
;
\end{tikzpicture}
```
```
Input: root = [5,3,6,2,4,null,7], k = 9
Output: true
Explanation: 2 + 7 = 9.
```

### Constraints

- `1 <= nodes <= 10^4`
- `-10^4 <= Node.val <= 10^4`
- BST property holds for the entire tree

### Solution - DFS + HashSet

#### Walkthrough

Traverse the tree with DFS while maintaining a set of seen node values. For each node:

1. Compute `needed = k - node.val`.
2. If `needed` is already in the set, return `true`.
3. Otherwise, insert `node.val` and continue exploring the left and right subtrees.

Because every value is checked exactly once, the traversal stays linear.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(n) in the worst case due to the set + recursion stack

#### Algorithm

1. Initialize an empty `HashSet<Integer>`.
2. Perform DFS:
   1. If the node is `null`, return `false`.
   2. If `set` contains `k - node.val`, return `true`.
   3. Add `node.val` to the set.
   4. Recurse into left or right subtrees; return `true` if either side finds a match.
3. Return `false` if no pair exists.

#### Java Code

```java
public boolean findTarget(TreeNode root, int k) {
    return dfs(root, k, new HashSet<>());
}

private boolean dfs(TreeNode node, int target, Set<Integer> seen) {
    if (node == null) {
        return false;
    }

    int needed = target - node.val;
    if (seen.contains(needed)) {
        return true;
    }

    seen.add(node.val);
    return dfs(node.left, target, seen) || dfs(node.right, target, seen);
}
```

## Two Sum V - All Unique Pairs {#two-sum-v}

### Problem Metadata

- **Platform**: Other
- **Problem ID**: N/A
- **Difficulty**: Medium
- **URL**: N/A
- **Tags**: `Array`, `Two Pointers`, `Sorting`
- **Techniques**: Two Pointers \@ref(two-pointers)

### Description

Given a **sorted** integer array `nums` and an integer `target`, find **all unique pairs** `[a, b]` such that `a + b = target`. Each pair should list the smaller element first, and duplicate pairs must be removed.

### Examples

```
Input: nums = [-2,-1,-1,0,1,2], target = 0
Output: [[-2,2],[-1,1]]
```

### Constraints

- `2 <= nums.length <= 10^5`
- `-10^9 <= nums[i], target <= 10^9`
- `nums` is sorted in non-decreasing order

### Solution - Two Pointers

#### Walkthrough

Place `left` at the start and `right` at the end of the array. Compare `nums[left] + nums[right]` with `target` and move pointers inward. Whenever a valid pair is found, add it to the result and skip over duplicates on both sides to avoid repeated pairs.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(1) auxiliary (result list not counted)

#### Algorithm

1. Initialize `left = 0`, `right = nums.length - 1`, and an empty result list.
2. While `left < right`:
   1. Compute `sum = nums[left] + nums[right]`.
   2. If `sum == target`, record the pair and move both pointers past duplicate values.
   3. If `sum < target`, increment `left`.
   4. Otherwise, decrement `right`.
3. Return the collected list of pairs.

#### Java Code

```java
public List<List<Integer>> twoSumPairs(int[] nums, int target) {
    List<List<Integer>> result = new ArrayList<>();
    int left = 0;
    int right = nums.length - 1;

    while (left < right) {
        int sum = nums[left] + nums[right];

        if (sum == target) {
            result.add(Arrays.asList(nums[left], nums[right]));

            int currentLeft = nums[left];
            int currentRight = nums[right];
            while (left < right && nums[left] == currentLeft) {
                left++;
            }
            while (left < right && nums[right] == currentRight) {
                right--;
            }
        } else if (sum < target) {
            left++;
        } else {
            right--;
        }
    }

    return result;
}
```



## 3Sum {#three-sum}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 15
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/3sum/
- **Tags**: `Array`, `Sorting`, `Two Pointers`
- **Techniques**: Sorting, Two Pointers \@ref(two-pointers)

### Description

Given an integer array `nums`, return all unique triplets `[nums[i], nums[j], nums[k]]` such that `i < j < k` and `nums[i] + nums[j] + nums[k] = 0`. The solution set must not contain duplicate triplets.

### Examples

```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: Only these two triplets sum to zero without duplication.
```

### Constraints

- `3 <= nums.length <= 3000`
- `-10^5 <= nums[i] <= 10^5`

### Solution - Sort + Two Pointers

#### Walkthrough

1. Sort the array first so equal values appear together and two-pointer sweeps become possible.
2. Iterate `i` across the array. For each `nums[i]`, treat it as the first element of a triplet and search for a complementary two-sum (`-nums[i]`) using two pointers `left` and `right`.
3. Skip duplicate values for both `i` and the pointer adjustments to avoid emitting the same triplet multiple times.

#### Analysis

- **Time Complexity**: O(n²) — sorting is `O(n log n)` and the double-pointer sweep dominates
- **Space Complexity**: O(1) auxiliary (ignoring the output list)

#### Algorithm

Sorting, Two Pointers \@ref(two-pointers)

1. Sort `nums`.
2. For each index `i` from `0` to `n - 3`:
   1. If `i > 0` and `nums[i] == nums[i - 1]`, continue (skip duplicates).
   2. Set `left = i + 1` and `right = n - 1`.
   3. While `left < right`:
      - Let `sum = nums[i] + nums[left] + nums[right]`.
      - If `sum == 0`, record the triplet and move `left`/`right` past duplicates.
      - If `sum < 0`, increment `left`.
      - If `sum > 0`, decrement `right`.
3. Return the collected triplets.

#### Java Code

```java
public List<List<Integer>> threeSum(int[] nums) {
    Arrays.sort(nums);
    List<List<Integer>> result = new ArrayList<>();

    for (int i = 0; i < nums.length - 2; i++) {
        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }

        int left = i + 1;
        int right = nums.length - 1;

        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];

            if (sum == 0) {
                result.add(Arrays.asList(nums[i], nums[left], nums[right]));

                int leftVal = nums[left];
                int rightVal = nums[right];
                while (left < right && nums[left] == leftVal) {
                    left++;
                }
                while (left < right && nums[right] == rightVal) {
                    right--;
                }
            } else if (sum < 0) {
                left++;
            } else {
                right--;
            }
        }
    }

    return result;
}
```



## 3 Sum Closest {#three-sum-closest}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 16
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/3sum-closest/
- **Tags**: `Array`, `Sorting`, `Two Pointers`
- **Techniques**: Sorting, Two Pointers \@ref(two-pointers)

### Description

Given an integer array `nums` and an integer `target`, return the sum of three integers in `nums` such that the sum is closest to `target`. Each input has exactly one solution.

### Examples

```
Input: nums = [-1,2,1,-4], target = 1
Output: 2
Explanation: The triplet [-1,2,1] sums to 2, which is closest to target.
```

### Constraints

- `3 <= nums.length <= 1000`
- `-10^3 <= nums[i], target <= 10^3`

### Solution - Sort + Two Pointers

#### Walkthrough

1. Sort the array so pointer sweeps over the interior become possible.
2. Iterate `i` from `0` to `n - 3`. Treat `nums[i]` as the first term, then run `left`/`right` pointers to scan the remainder.
3. Track the closest sum seen so far and update it whenever a tighter candidate appears.

#### Analysis

- **Time Complexity**: O(n²)
- **Space Complexity**: O(1) auxiliary

#### Algorithm

Sorting, Two Pointers \@ref(two-pointers)

1. Sort `nums`.
2. Initialize `closest = nums[0] + nums[1] + nums[2]`.
3. For each `i` in `[0, n - 3]`:
   1. Set `left = i + 1`, `right = n - 1`.
   2. While `left < right`:
      - `sum = nums[i] + nums[left] + nums[right]`.
      - If `|target - sum| < |target - closest|`, update `closest`.
      - Move `left` or `right` inward depending on whether `sum` is less or greater than `target`.
4. Return `closest`.

#### Java Code

```java
public int threeSumClosest(int[] nums, int target) {
    Arrays.sort(nums);
    int closest = nums[0] + nums[1] + nums[2];

    for (int i = 0; i < nums.length - 2; i++) {
        int left = i + 1;
        int right = nums.length - 1;

        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];

            if (Math.abs(target - sum) < Math.abs(target - closest)) {
                closest = sum;
            }

            if (sum < target) {
                left++;
            } else if (sum > target) {
                right--;
            } else {
                return sum;
            }
        }
    }

    return closest;
}
```



## 4Sum {#four-sum}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 18
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/4sum/
- **Tags**: `Array`, `Sorting`, `Two Pointers`
- **Techniques**: Sorting, Two Pointers \@ref(two-pointers)

### Description

Given an integer array `nums` and an integer `target`, return all unique quadruplets `[a, b, c, d]` such that `a + b + c + d = target`. No duplicate quadruplets may appear in the answer.

### Examples

```
Input: nums = [1,0,-1,0,-2,2], target = 0
Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

### Constraints

- `4 <= nums.length <= 200`
- `-10^9 <= nums[i], target <= 10^9`

### Solution - Nested Two Pointers

#### Walkthrough

Sort the array, then fix two indices `i` and `j`. For each pair, run a two-pointer search on the remaining suffix to find the other two numbers. Skip duplicate values for every index to avoid repeating the same quadruplet.

#### Analysis

- **Time Complexity**: O(n^3)
- **Space Complexity**: O(1) auxiliary (excluding output)

#### Algorithm

Sorting, Two Pointers \@ref(two-pointers)

1. Sort `nums`.
2. For each `i` from `0` to `n - 4` (skipping duplicates):
   1. For each `j` from `i + 1` to `n - 3` (skipping duplicates):
      - Set `left = j + 1`, `right = n - 1`.
      - While `left < right`, evaluate `sum = nums[i] + nums[j] + nums[left] + nums[right]`.
      - If `sum == target`, record the quadruplet and move both pointers past duplicates.
      - Otherwise shift the pointer whose movement drives the sum toward `target`.
3. Return the list of quadruplets.

#### Java Code

```java
public List<List<Integer>> fourSum(int[] nums, int target) {
    Arrays.sort(nums);
    List<List<Integer>> result = new ArrayList<>();

    for (int i = 0; i < nums.length - 3; i++) {
        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }
        for (int j = i + 1; j < nums.length - 2; j++) {
            if (j > i + 1 && nums[j] == nums[j - 1]) {
                continue;
            }

            int left = j + 1;
            int right = nums.length - 1;

            while (left < right) {
                long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];

                if (sum == target) {
                    result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));

                    int leftVal = nums[left];
                    int rightVal = nums[right];
                    while (left < right && nums[left] == leftVal) {
                        left++;
                    }
                    while (left < right && nums[right] == rightVal) {
                        right--;
                    }
                } else if (sum < target) {
                    left++;
                } else {
                    right--;
                }
            }
        }
    }

    return result;
}
```

## 4Sum II {#four-sum-ii}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 454
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/4sum-ii/
- **Tags**: `Array`, `Hash Table`, `Counting`
- **Techniques**: Hash Table \@ref(hash-table)

### Description

Given four integer arrays `A`, `B`, `C`, and `D`, each of length `n`, return the number of tuples `(i, j, k, l)` such that `A[i] + B[j] + C[k] + D[l] = 0`.

### Examples

```
Input:
A = [1, 2]
B = [-2, -1]
C = [-1, 2]
D = [0, 2]

Output: 2
Explanation:
(i,j,k,l) = (0,0,0,1) and (1,1,0,0) satisfy the equation.
```

### Constraints

- `0 <= n <= 500`
- `-2^28 <= A[i], B[i], C[i], D[i] <= 2^28 - 1`
- Answer fits in a 32-bit signed integer

### Solution - Hash Map Pair Sums

#### Walkthrough

Rearrange the equation to `(A[i] + B[j]) = -(C[k] + D[l])`. Precompute all pair sums of `A` and `B` and store their frequencies in a hash map. Then iterate over all pairs in `C` and `D`, look up the negated sum in the map, and accumulate the counts.

#### Analysis

- **Time Complexity**: O(n²)
- **Space Complexity**: O(n²) for storing pair sums

#### Algorithm

Hash Table \@ref(hash-table)

1. Iterate over all pairs `(i, j)` of `A` and `B`:
   - Compute `sum = A[i] + B[j]`.
   - Increment `map[sum]`.
2. For every pair `(k, l)` of `C` and `D`:
   - Compute `sum = -(C[k] + D[l])`.
   - If `sum` exists in the map, add `map[sum]` to the answer.
3. Return the accumulated total.

#### Java Code

```java
public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {
    Map<Integer, Integer> countMap = new HashMap<>();

    for (int a : A) {
        for (int b : B) {
            int sum = a + b;
            countMap.put(sum, countMap.getOrDefault(sum, 0) + 1);
        }
    }

    int result = 0;
    for (int c : C) {
        for (int d : D) {
            int needed = -(c + d);
            result += countMap.getOrDefault(needed, 0);
        }
    }

    return result;
}
```


## Max Gain {#max-gain}

### Problem Metadata

- **Platform**: Firecode
- **Difficulty**: Easy
- **URL**: N/A
- **Tags**: `Array`, `Greedy`
- **Techniques**: Greedy \@ref(greedy)

### Description

Given an integer array, return the maximum gain, defined as the largest difference `a[j] - a[i]` such that `j > i`. If the array never increases, return 0.

### Examples

```
Input: [0,50,10,100,30]   Output: 100
Input: [100,40,20,10]     Output: 0
Input: [0,100,0,100,0,100] Output: 100
```

### Constraints

- `1 <= nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`

### Solution - One-Pass Greedy

#### Walkthrough

Track the minimum value seen so far while scanning the array. For each element, compute the gain relative to this minimum and update the answer. Update the running minimum whenever a smaller value is encountered.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(1)

#### Algorithm

Greedy \@ref(greedy)

1. Initialize `minValue = +8` and `maxGain = 0`.
2. For each element `x`:
   1. Update `minValue = min(minValue, x)`.
   2. Update `maxGain = max(maxGain, x - minValue)`.
3. Return `maxGain`.

#### Java Code

```java
public int maxGain(int[] nums) {
    int minValue = Integer.MAX_VALUE;
    int maxGain = 0;

    for (int num : nums) {
        minValue = Math.min(minValue, num);
        maxGain = Math.max(maxGain, num - minValue);
    }

    return maxGain;
}
```


## Pascal's Triangle {#pascals-triangle}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 118
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/pascals-triangle/
- **Tags**: `Array`, `Dynamic Programming`
- **Techniques**: Dynamic Programming \@ref(dp)

### Description

Given a non-negative integer `numRows`, generate the first `numRows` rows of Pascal's triangle. Each number is the sum of the two numbers directly above it.

### Examples

```
Input: numRows = 5
Output:
[
 [1],
 [1,1],
 [1,2,1],
 [1,3,3,1],
 [1,4,6,4,1]
]
```

### Constraints

- `0 <= numRows <= 30`

### Solution - Iterative Construction

#### Walkthrough

Start with the first row `[1]`, then iteratively build each subsequent row by inserting `1` at both ends and using the previous row to compute interior values (`row[j] = prevRow[j-1] + prevRow[j]`).

#### Analysis

- **Time Complexity**: O(n?)
- **Space Complexity**: O(n?) to store the triangle

#### Algorithm

Dynamic Programming \@ref(dp)

1. If `numRows == 0`, return an empty list.
2. Initialize the triangle with `[1]`.
3. For each new row index from `1` to `numRows - 1`:
   - Begin the row with `1`.
   - For each interior position `j`, append `prevRow[j-1] + prevRow[j]`.
   - End the row with `1` and append it to the triangle.
4. Return the triangle.

#### Java Code

```java
public List<List<Integer>> generate(int numRows) {
    List<List<Integer>> triangle = new ArrayList<>();

    if (numRows == 0) {
        return triangle;
    }

    triangle.add(Collections.singletonList(1));

    for (int row = 1; row < numRows; row++) {
        List<Integer> prevRow = triangle.get(row - 1);
        List<Integer> current = new ArrayList<>();
        current.add(1);

        for (int j = 1; j < row; j++) {
            current.add(prevRow.get(j - 1) + prevRow.get(j));
        }

        current.add(1);
        triangle.add(current);
    }

    return triangle;
}
``

## Search in Rotated Sorted Array {#search-rotated-array}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 33
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/search-in-rotated-sorted-array/
- **Tags**: `Array`, `Binary Search`
- **Techniques**: Divide and Conquer \@ref(dnc), Binary Search \@ref(binary-search)

### Description

Given an ascending-sorted array that has been rotated at an unknown pivot, search for a `target` value. If found, return its index; otherwise return `-1`. The array contains no duplicates, and the algorithm must run in `O(log n)`.

### Examples

```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

### Constraints

- `1 <= nums.length <= 10^4`
- `-10^4 <= nums[i], target <= 10^4`
- All elements are distinct

### Solution - Modified Binary Search

#### Walkthrough

At each step, a sorted half still exists. Compare `nums[mid]` with `nums[left]` to detect which side is sorted. If the target lies within that half, keep it; otherwise discard it and continue searching the other half.

#### Analysis

- **Time Complexity**: O(log n)
- **Space Complexity**: O(1)

#### Algorithm

Divide and Conquer \@ref(dnc), Binary Search \@ref(binary-search)

1. Set `left = 0`, `right = n - 1`.
2. While `left <= right`:
   1. `mid = left + (right - left) / 2`.
   2. If `nums[mid] == target`, return `mid`.
   3. If left half is sorted (`nums[left] <= nums[mid]`):
      - If `target` in `[nums[left], nums[mid])`, set `right = mid - 1` else `left = mid + 1`.
   4. Else the right half is sorted:
      - If `target` in `(nums[mid], nums[right]]`, set `left = mid + 1` else `right = mid - 1`.
3. Return `-1`.

#### Java Code

```java
public int search(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            return mid;
        }

        if (nums[left] <= nums[mid]) {
            if (target >= nums[left] && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            if (target > nums[mid] && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }

    return -1;
}
``

## Median of Two Sorted Arrays {#median-two-sorted}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 4
- **Difficulty**: Hard
- **URL**: https://leetcode.com/problems/median-of-two-sorted-arrays/
- **Tags**: `Array`, `Binary Search`, `Divide and Conquer`
- **Techniques**: Divide and Conquer \@ref(dnc), Recursion \@ref(recursion)

### Description

Given two sorted arrays `nums1` and `nums2` of lengths `m` and `n`, return the overall median. The runtime must be `O(log(m + n))`.

### Examples

```
Input: nums1 = [1,3], nums2 = [2]
Output: 2.0

Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.5
```

### Constraints

- `0 <= m, n <= 1000`
- `m + n >= 1`
- `-10^6 <= nums[i] <= 10^6`

### Solution - Recursive Kth Element

#### Walkthrough

The median can be expressed using the `k`-th smallest element where `k = (m + n + 1) / 2` (and `k + 1` when `m + n` is even). Use a helper `findKth` that discards `k/2` elements from one array at each recursion, always operating on the shorter array to keep indices valid.

#### Analysis

- **Time Complexity**: O(log(m + n))
- **Space Complexity**: O(1) excluding recursion stack

#### Algorithm

Divide and Conquer \@ref(dnc), Recursion \@ref(recursion)

1. Let `total = m + n`.
2. If `total` is odd, return `findKth(nums1, 0, len1 - 1, nums2, 0, len2 - 1, (total + 1) / 2)`.
3. Otherwise compute `left = findKth(..., total / 2)` and `right = findKth(..., total / 2 + 1)` and return `(left + right) / 2`.
4. In `findKth`, handle base cases when one array is exhausted or `k == 1`; otherwise compare the `k/2`-th elements and discard the smaller block.

#### Java Code
```java
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    int len1 = nums1.length;
    int len2 = nums2.length;
    int total = len1 + len2;

    if ((total & 1) != 0) {
        return findKth(nums1, 0, len1 - 1, nums2, 0, len2 - 1, (total + 1) / 2);
    }

    double left = findKth(nums1, 0, len1 - 1, nums2, 0, len2 - 1, total / 2);
    double right = findKth(nums1, 0, len1 - 1, nums2, 0, len2 - 1, total / 2 + 1);
    return (left + right) / 2.0;
}

private double findKth(int[] nums1, int start1, int end1,
                       int[] nums2, int start2, int end2, int k) {
    int len1 = end1 - start1 + 1;
    int len2 = end2 - start2 + 1;

    if (len1 == 0) {
        return nums2[start2 + k - 1];
    }

    if (len2 == 0) {
        return nums1[start1 + k - 1];
    }

    if (k == 1) {
        return Math.min(nums1[start1], nums2[start2]);
    }

    if (len1 > len2) {
        return findKth(nums2, start2, end2, nums1, start1, end1, k);
    }

    int i = start1 + Math.min(len1, k / 2) - 1;
    int j = start2 + Math.min(len2, k / 2) - 1;

    if (nums1[i] <= nums2[j]) {
        return findKth(nums1, i + 1, end1, nums2, start2, end2,
                       k - (i - start1 + 1));
    } else {
        return findKth(nums1, start1, end1, nums2, j + 1, end2,
                       k - (j - start2 + 1));
    }
}
``

## Retrieve Elements Appearing K Times {#kth-occurrence}

### Problem Metadata

- **Platform**: Other
- **Difficulty**: Easy
- **URL**: N/A
- **Tags**: `Array`, `Hash Table`
- **Techniques**: Hash Table \@ref(hash-table)

### Description

Given an integer array (possibly with duplicates) and an integer `k >= 1`, return the elements whose k-th occurrence appears, preserving the original order of those k-th occurrences.

### Examples

```
Input: nums = [1,2,3,4,2,1,1,3], k = 1
Output: [1,2,3,4]

Input: nums = [1,2,3,4,2,1,1,3], k = 2
Output: [2,1,3]
```

### Constraints

- `1 <= nums.length <= 10^5`
- `k >= 1`

### Solution - Hash Map Counting

#### Walkthrough

Use a hash map to track how many times each value has appeared. When an element's count becomes exactly `k`, append it to the result list to preserve insertion order.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(n)

#### Algorithm

Hash Table \@ref(hash-table)

1. Initialize an empty `HashMap<Integer, Integer>` and an empty result list.
2. For each element `x` in `nums`:
   1. Increment `count[x]`.
   2. If `count[x] == k`, append `x` to `result`.
3. Return `result`.

#### Java Code

```java
public List<Integer> kthOccurrences(int[] nums, int k) {
    List<Integer> result = new ArrayList<>();
    Map<Integer, Integer> counts = new HashMap<>();

    for (int num : nums) {
        int newCount = counts.getOrDefault(num, 0) + 1;
        counts.put(num, newCount);

        if (newCount == k) {
            result.add(num);
        }
    }

    return result;
}
```

## Permutations {#permutations}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 46
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/permutations/
- **Tags**: `Array`, `Backtracking`
- **Techniques**: Backtracking \@ref(backtrack)

### Description

Given an array of distinct integers, return all possible permutations.

### Examples

```
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

### Constraints

- `1 <= nums.length <= 8`
- All values are distinct

### Solution - Backtracking

#### Walkthrough

Build permutations by exploring each number once per path. Maintain a `visited` array so each value appears once per permutation. When the path length equals `nums.length`, add a copy to the results and backtrack.

#### Analysis

- **Time Complexity**: O(n ? n!)
- **Space Complexity**: O(n) recursion + visited state

#### Algorithm

Backtracking \@ref(backtrack)

1. Initialize `result` and `visited` array.
2. Define `backtrack(path)`:
   1. If `path.size() == nums.length`, append copy to `result`.
   2. Otherwise iterate indices:
      - Skip if visited.
      - Mark visited, append value, recurse, then undo.
3. Call `backtrack(new ArrayList<>())` and return `result`.

#### Java Code
```java
List<List<Integer>> result = new ArrayList<>();

public List<List<Integer>> permute(int[] nums) {
    boolean[] visited = new boolean[nums.length];
    backtrack(new ArrayList<>(), nums, visited);
    return result;
}

private void backtrack(List<Integer> path, int[] nums, boolean[] visited) {
    if (path.size() == nums.length) {
        result.add(new ArrayList<>(path));
        return;
    }

    for (int i = 0; i < nums.length; i++) {
        if (visited[i]) {
            continue;
        }
        visited[i] = true;
        path.add(nums[i]);
        backtrack(path, nums, visited);
        path.remove(path.size() - 1);
        visited[i] = false;
    }
}
```

## Permutations II {#permutations-ii}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 47
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/permutations-ii/
- **Tags**: `Array`, `Backtracking`
- **Techniques**: Backtracking \@ref(backtrack)

### Description

Given an array of integers that may contain duplicates, return all unique permutations.

### Examples

```
Input: nums = [1,1,2]
Output: [[1,1,2],[1,2,1],[2,1,1]]
```

### Constraints

- `1 <= nums.length <= 8`
- `-10 <= nums[i] <= 10`

### Solution - Backtracking with Duplicate Skipping

#### Walkthrough

Sort the input so duplicates are adjacent. During backtracking, skip an index `i` if it equals `nums[i-1]` and the previous instance has not been used in the current path. This ensures each value positions once per depth.

#### Analysis

- **Time Complexity**: O(n ? n!) in worst case
- **Space Complexity**: O(n)

#### Algorithm

Backtracking \@ref(backtrack)

1. Sort `nums`, initialize `visited` boolean array and result list.
2. `backtrack(path)`:
   1. If `path.size() == nums.length`, append copy.
   2. For each index `i`:
      - Skip if `visited[i]`.
      - Skip if `i > 0 && nums[i] == nums[i-1] && !visited[i-1]` (avoid duplicates).
      - Mark visited, append, recurse, then undo.
3. Return result.

#### Java Code
```java
List<List<Integer>> result = new ArrayList<>();

public List<List<Integer>> permuteUnique(int[] nums) {
    Arrays.sort(nums);
    boolean[] visited = new boolean[nums.length];
    backtrack(new ArrayList<>(), nums, visited);
    return result;
}

private void backtrack(List<Integer> path, int[] nums, boolean[] visited) {
    if (path.size() == nums.length) {
        result.add(new ArrayList<>(path));
        return;
    }

    for (int i = 0; i < nums.length; i++) {
        if (visited[i]) {
            continue;
        }
        if (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]) {
            continue;
        }
        visited[i] = true;
        path.add(nums[i]);
        backtrack(path, nums, visited);
        path.remove(path.size() - 1);
        visited[i] = false;
    }
}
```

## Subsets II {#subsets-ii}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 90
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/subsets-ii/
- **Tags**: `Array`, `Backtracking`
- **Techniques**: Backtracking \@ref(backtrack)

### Description

Given an integer array that may contain duplicates, return all possible subsets (the power set) without duplicates.

### Examples

```
Input: nums = [1,2,2]
Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]
```

### Constraints

- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`

### Solution - Backtracking with Skip Logic

#### Walkthrough

Sort `nums` so duplicates are adjacent. During recursion, start each depth from the current index and skip elements equal to the previous when at the same depth (`i > index && nums[i] == nums[i-1]`). Append the current path to the result at every node.

#### Analysis

- **Time Complexity**: O(2^n)
- **Space Complexity**: O(n) recursion stack

#### Algorithm

Backtracking \@ref(backtrack)

1. Sort `nums`, initialize result list.
2. Define `backtrack(start, path)`:
   1. Append copy of `path`.
   2. For `i` from `start` to `nums.length - 1`:
      - Skip if `i > start` and `nums[i] == nums[i - 1]`.
      - Append `nums[i]`, recurse with `i + 1`, then remove last element.
3. Return result.

#### Java Code
```java
List<List<Integer>> result = new ArrayList<>();

public List<List<Integer>> subsetsWithDup(int[] nums) {
    Arrays.sort(nums);
    backtrack(nums, 0, new ArrayList<>());
    return result;
}

private void backtrack(int[] nums, int start, List<Integer> path) {
    result.add(new ArrayList<>(path));

    for (int i = start; i < nums.length; i++) {
        if (i > start && nums[i] == nums[i - 1]) {
            continue;
        }
        path.add(nums[i]);
        backtrack(nums, i + 1, path);
        path.remove(path.size() - 1);
    }
}
```

## Sort Array By Parity {#sort-array-parity}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 905
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/sort-array-by-parity/
- **Tags**: `Array`, `Two Pointers`
- **Techniques**: Two Pointers \@ref(two-pointers)

### Description

Given an array `A` of non-negative integers, return any array consisting of all the even elements of `A` followed by all the odd elements.

### Examples

```
Input: [3,1,2,4]
Output: [2,4,3,1]
```

### Constraints

- `1 <= A.length <= 5000`
- `0 <= A[i] <= 5000`

### Solution - Two Pointers

#### Walkthrough

Use two pointers. Advance `left` until an odd number is found and decrement `right` until an even number is found; swap them and continue until the pointers cross.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(1)

#### Algorithm

Two Pointers \@ref(two-pointers)

1. Set `left = 0`, `right = A.length - 1`.
2. While `left < right`:
   1. Increment `left` while `A[left]` is even.
   2. Decrement `right` while `A[right]` is odd.
   3. If `left < right`, swap `A[left]` and `A[right]`.
3. Return `A`.

#### Java Code
```java
public int[] sortArrayByParity(int[] A) {
    int left = 0;
    int right = A.length - 1;

    while (left < right) {
        while (left < right && (A[left] & 1) == 0) {
            left++;
        }
        while (left < right && (A[right] & 1) == 1) {
            right--;
        }
        if (left < right) {
            int temp = A[left];
            A[left] = A[right];
            A[right] = temp;
        }
    }

    return A;
}
``

## Merge Intervals {#merge-intervals}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 56
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/merge-intervals/
- **Tags**: `Array`, `Sorting`
- **Techniques**: Sorting \@ref(sorting)

### Description

Given an array of intervals where `intervals[i] = [start_i, end_i]`, merge all overlapping intervals and return the result in ascending order of start time.

### Examples

```
Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
```

### Constraints

- `1 <= intervals.length <= 10^4`
- `intervals[i].length == 2`
- `0 <= start_i <= end_i <= 10^4`

### Solution - Sort then Merge

#### Walkthrough

Sort the intervals by starting point. Iterate through them, merging with the last interval in the output when an overlap occurs (`current.start <= last.end`), otherwise append the new interval.

#### Analysis

- **Time Complexity**: O(n log n)
- **Space Complexity**: O(n) for the output list

#### Algorithm

Sorting \@ref(sorting)

1. Sort intervals ascending by start.
2. Initialize an empty list `merged`.
3. For each interval:
   1. If `merged` is empty or `current.start > merged.last.end`, append interval.
   2. Else set `merged.last.end = max(merged.last.end, current.end)`.
4. Return `merged` as an array.

#### Java Code
```java
public int[][] merge(int[][] intervals) {
    if (intervals.length == 0) {
        return new int[0][0];
    }

    Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));
    List<int[]> merged = new ArrayList<>();
    merged.add(intervals[0].clone());

    for (int i = 1; i < intervals.length; i++) {
        int[] current = intervals[i];
        int[] last = merged.get(merged.size() - 1);

        if (current[0] <= last[1]) {
            last[1] = Math.max(last[1], current[1]);
        } else {
            merged.add(current.clone());
        }
    }

    return merged.toArray(new int[merged.size()][]);
}
``

## Non-overlapping Intervals {#non-overlapping-intervals}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 435
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/non-overlapping-intervals/
- **Tags**: `Array`, `Greedy`, `Sorting`
- **Techniques**: Sorting \@ref(sorting), Greedy \@ref(greedy)

### Description

Given a collection of intervals, find the minimum number of intervals to remove so the rest are non-overlapping.

### Examples

```
Input: [[1,2],[2,3],[3,4],[1,3]]
Output: 1
```

### Constraints

- `1 <= intervals.length <= 10^5`
- `intervals[i].length == 2`

### Solution - Greedy by End Time

#### Walkthrough

Sort intervals by end time; keep a running end boundary for the last accepted interval. When an interval starts after or at the stored end, include it and update the end. Otherwise it overlaps and must be removed. The number removed equals total minus selected count.

#### Analysis

- **Time Complexity**: O(n log n)
- **Space Complexity**: O(1) apart from sorting

#### Algorithm

Greedy \@ref(greedy)

1. Sort intervals ascending by end, breaking ties by start.
2. Initialize `count = 1`, `end = intervals[0][1]`.
3. For each remaining interval:
   - If `interval[0] >= end`, increment `count` and set `end = interval[1]`.
4. Return `n - count` removals.

#### Java Code
```java
public int eraseOverlapIntervals(int[][] intervals) {
    if (intervals.length == 0) {
        return 0;
    }

    Arrays.sort(intervals, (a, b) -> {
        if (a[1] != b[1]) {
            return a[1] - b[1];
        }
        return a[0] - b[0];
    });

    int count = 1;
    int end = intervals[0][1];

    for (int i = 1; i < intervals.length; i++) {
        if (intervals[i][0] >= end) {
            count++;
            end = intervals[i][1];
        }
    }

    return intervals.length - count;
}
``

## Interval List Intersections {#interval-list-intersections}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 986
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/interval-list-intersections/
- **Tags**: `Array`, `Two Pointers`
- **Techniques**: Two Pointers \@ref(two-pointers)

### Description

Given two lists of disjoint closed intervals sorted by start time, return their intersections.

### Examples

```
Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]
Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]
```

### Constraints

- `0 <= len(A), len(B) <= 1000`
- Intervals are pairwise disjoint within each list and sorted

### Solution - Two Pointers

#### Walkthrough

Traverse both lists with indices `i` and `j`. For each pair of intervals, compute the overlap as `start = max(A[i].start, B[j].start)` and `end = min(A[i].end, B[j].end)`. If `start <= end`, append it. Advance the pointer whose interval ends first.

#### Analysis

- **Time Complexity**: O(m + n)
- **Space Complexity**: O(1) excluding output

#### Algorithm

Two Pointers \@ref(two-pointers)

1. Initialize `i = j = 0`, result list.
2. While `i < len(A)` and `j < len(B)`:
   1. `start = max(A[i][0], B[j][0])`, `end = min(A[i][1], B[j][1])`.
   2. If `start <= end`, append `[start, end]`.
   3. Increment pointer whose interval ends first.
3. Return the result list as an array.

#### Java Code
```java
public int[][] intervalIntersection(int[][] A, int[][] B) {
    List<int[]> result = new ArrayList<>();
    int i = 0, j = 0;

    while (i < A.length && j < B.length) {
        int start = Math.max(A[i][0], B[j][0]);
        int end = Math.min(A[i][1], B[j][1]);

        if (start <= end) {
            result.add(new int[]{start, end});
        }

        if (A[i][1] < B[j][1]) {
            i++;
        } else {
            j++;
        }
    }

    return result.toArray(new int[result.size()][]);
}
``

## Insert Interval {#insert-interval}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 57
- **Difficulty**: Hard
- **URL**: https://leetcode.com/problems/insert-interval/
- **Tags**: `Array`
- **Techniques**: Sorting \@ref(sorting)

### Description

Given a set of non-overlapping intervals sorted by start time, insert a new interval and merge if necessary.

### Examples

```
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
```

### Constraints

- `0 <= intervals.length <= 10^4`
- Intervals are non-overlapping and sorted

### Solution - Linear Merge

#### Walkthrough

Iterate through intervals, appending those ending before the new interval. Merge overlapping intervals by expanding `newInterval`. Once the new interval ends before the current interval, append it and the rest.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(n) output list

#### Algorithm

1. Initialize result list and index `i = 0`.
2. Append all intervals whose end < newInterval.start.
3. While intervals overlap with newInterval, update start = min and end = max.
4. Append the merged new interval.
5. Append remaining intervals.

#### Java Code
```java
public int[][] insert(int[][] intervals, int[] newInterval) {
    List<int[]> result = new ArrayList<>();
    int i = 0;

    while (i < intervals.length && intervals[i][1] < newInterval[0]) {
        result.add(intervals[i++]);
    }

    while (i < intervals.length && intervals[i][0] <= newInterval[1]) {
        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);
        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);
        i++;
    }
    result.add(newInterval.clone());

    while (i < intervals.length) {
        result.add(intervals[i++]);
    }

    return result.toArray(new int[result.size()][]);
}
``

## Find Common Characters {#find-common-characters}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 1002
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/find-common-characters/
- **Tags**: `Array`, `Hash Table`
- **Techniques**: Hash Table \@ref(hash-table)

### Description

Given an array of lowercase strings, return a list of all characters that appear in every string (including duplicates). Order does not matter.

### Examples

```
Input: ["bella","label","roller"]
Output: ["e","l","l"]
```

### Constraints

- `1 <= A.length <= 100`
- `1 <= A[i].length <= 100`

### Solution - Frequency Intersection

#### Walkthrough

Track the frequency of each letter in the first string. For every next string, compute its frequency and take the element-wise minimum with the running counts. At the end, output each letter as many times as its remaining count.

#### Analysis

- **Time Complexity**: O(n * L) where `L` is average word length
- **Space Complexity**: O(1) for 26 counts

#### Algorithm

Hash Table \@ref(hash-table)

1. Initialize `minFreq` with counts from the first word.
2. For each subsequent word:
   1. Count characters into `temp`.
   2. Update `minFreq[i] = min(minFreq[i], temp[i])`.
3. Build the result by outputting each character `minFreq[i]` times.

#### Java Code
```java
public List<String> commonChars(String[] A) {
    int[] minFreq = new int[26];
    Arrays.fill(minFreq, Integer.MAX_VALUE);

    for (String word : A) {
        int[] freq = new int[26];
        for (char c : word.toCharArray()) {
            freq[c - 'a']++;
        }
        for (int i = 0; i < 26; i++) {
            minFreq[i] = Math.min(minFreq[i], freq[i]);
        }
    }

    List<String> result = new ArrayList<>();
    for (int i = 0; i < 26; i++) {
        for (int count = 0; count < minFreq[i]; count++) {
            result.add(String.valueOf((char) ('a' + i)));
        }
    }

    return result;
}
```

## Top K Frequent Elements {#top-k-frequent}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 347
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/top-k-frequent-elements/
- **Tags**: `Array`, `Hash Table`, `Heap`
- **Techniques**: Hash Table \@ref(hash-table)

### Description

Given a non-empty integer array, return the `k` most frequent elements. `k` is guaranteed to be valid.

### Examples

```
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
```

### Constraints

- `1 <= nums.length <= 10^5`
- `k <= number of unique values`

### Solution - Hash Map + Heap

#### Walkthrough

Count element frequencies with a map. Maintain a min-heap of size `k` keyed by frequency; push each entry and remove the smallest when the heap grows beyond `k`. The heap contents are the answer.

#### Analysis

- **Time Complexity**: O(n log k)
- **Space Complexity**: O(n)

#### Algorithm

Hash Table \@ref(hash-table)

1. Build `Map<Integer,Integer>` counts.
2. Create a min-heap storing `{frequency, value}` pairs.
3. For each entry in the map:
   - Push into heap.
   - If heap size > `k`, pop the smallest frequency.
4. Pop all heap entries to form the result.

#### Java Code
```java
public int[] topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> counts = new HashMap<>();
    for (int num : nums) {
        counts.put(num, counts.getOrDefault(num, 0) + 1);
    }

    PriorityQueue<int[]> heap = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));

    for (Map.Entry<Integer, Integer> entry : counts.entrySet()) {
        heap.offer(new int[]{entry.getValue(), entry.getKey()});
        if (heap.size() > k) {
            heap.poll();
        }
    }

    int[] result = new int[k];
    for (int i = k - 1; i >= 0; i--) {
        result[i] = heap.poll()[1];
    }
    return result;
}
```

## Count Iterations to Fill Ones {#fill-ones}

### Problem Metadata

- **Platform**: Other
- **Difficulty**: Medium
- **URL**: N/A
- **Tags**: `Array`, `Simulation`
- **Techniques**: Simulation

### Description

Given a binary array, repeatedly convert a zero to one if it has at least one adjacent one. Return the number of iterations needed until all entries equal one, or `-1` if impossible.

### Examples

```
Input: [0,1,0,1]
Output: 1
```

### Constraints

- `1 <= n <= 10^5`

### Solution - BFS-style Expansion

#### Walkthrough

Treat positions containing ones as the current frontier. For each iteration, flip neighboring zeros to ones and enqueue them for the next round. Track the number of zeros remaining.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(n)

### Algorithm

1. Enqueue indices containing ones and count zeros.
2. If no zeros, return 0.
3. While the queue is not empty:
   - Process one level (current queue size).
   - For each index, check neighbors; flip zeros to ones, enqueue, and decrement zero count.
   - Increment iteration counter when any flip occurs.
4. Return iterations if all zeros flipped, else -1.

### Java Code
```java
public int fillOnes(int[] arr) {
    Queue<Integer> queue = new ArrayDeque<>();
    int zeros = 0;

    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == 1) {
            queue.offer(i);
        } else {
            zeros++;
        }
    }

    if (zeros == 0) {
        return 0;
    }

    int iterations = 0;
    while (!queue.isEmpty()) {
        int size = queue.size();
        boolean flipped = false;

        for (int s = 0; s < size; s++) {
            int idx = queue.poll();
            for (int next : new int[]{idx - 1, idx + 1}) {
                if (next >= 0 && next < arr.length && arr[next] == 0) {
                    arr[next] = 1;
                    zeros--;
                    queue.offer(next);
                    flipped = true;
                }
            }
        }

        if (flipped) {
            iterations++;
        }
    }

    return zeros == 0 ? iterations : -1;
}
``

## Maximum Subarray {#maximum-subarray}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 53
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/maximum-subarray/
- **Tags**: `Array`, `Dynamic Programming`
- **Techniques**: Dynamic Programming \@ref(dp)

### Description

Given an integer array `nums`, find the contiguous subarray with the largest sum and return that sum.

### Examples

```
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```

### Constraints

- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`

### Solution - Kadane's Algorithm

#### Walkthrough

Maintain `current` sum for the best subarray ending at index `i`. For each number, extend the previous subarray if it improves the sum; otherwise start new from the current number. Track the global maximum.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(1)

#### Algorithm

Dynamic Programming \@ref(dp)

1. Initialize `current = maxSum = nums[0]`.
2. For each element from index 1 onward:
   - `current = max(nums[i], current + nums[i])`.
   - `maxSum = max(maxSum, current)`.
3. Return `maxSum`.

#### Java Code
```java
public int maxSubArray(int[] nums) {
    int current = nums[0];
    int maxSum = nums[0];

    for (int i = 1; i < nums.length; i++) {
        current = Math.max(nums[i], current + nums[i]);
        maxSum = Math.max(maxSum, current);
    }

    return maxSum;
}
``

## Maximum Product Subarray {#maximum-product}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 152
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/maximum-product-subarray/
- **Tags**: `Array`, `Dynamic Programming`
- **Techniques**: Dynamic Programming \@ref(dp)

### Description

Find the contiguous subarray within an array that has the largest product.

### Examples

```
Input: [2,3,-2,4]
Output: 6 (subarray [2,3])
```

### Constraints

- `1 <= nums.length <= 2 * 10^4`
- `-10 <= nums[i] <= 10`

### Solution - Track Max and Min Products

#### Walkthrough

Because negative values can flip the sign, keep both the maximum and minimum products ending at each index. For each number, compute candidates by multiplying with previous max/min and compare with the number itself. Update the global maximum accordingly.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(1)

#### Algorithm

Dynamic Programming \@ref(dp)

1. Initialize `maxSoFar = minSoFar = answer = nums[0]`.
2. For each `num` from index 1 onward:
   - If `num < 0`, swap `maxSoFar` and `minSoFar`.
   - `maxSoFar = max(num, maxSoFar * num)`.
   - `minSoFar = min(num, minSoFar * num)`.
   - `answer = max(answer, maxSoFar)`.
3. Return `answer`.

#### Java Code
```java
public int maxProduct(int[] nums) {
    int maxSoFar = nums[0];
    int minSoFar = nums[0];
    int answer = nums[0];

    for (int i = 1; i < nums.length; i++) {
        int num = nums[i];
        if (num < 0) {
            int temp = maxSoFar;
            maxSoFar = minSoFar;
            minSoFar = temp;
        }
        maxSoFar = Math.max(num, maxSoFar * num);
        minSoFar = Math.min(num, minSoFar * num);
        answer = Math.max(answer, maxSoFar);
    }

    return answer;
}
``

## Eliminate Maximum Number of Monsters {#eliminate-max-monsters}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 1921
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/eliminate-maximum-number-of-monsters/
- **Tags**: `Array`, `Greedy`, `Sorting`
- **Techniques**: Sorting, Greedy Algorithm

### Description

You are playing a video game where you are defending your city from a group of n monsters. You are given a 0-indexed integer array dist of size n, where dist[i] is the initial distance in kilometers of the ith monster from the city.

The monsters walk toward the city at a constant speed. The speed of each monster is given to you in an integer array speed of size n, where speed[i] is the speed of the ith monster in kilometers per minute.

You have a weapon that, once fully charged, can eliminate a single monster. However, the weapon takes one minute to charge. The weapon is fully charged at the very start.

You lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a loss, and the game ends before you can use your weapon.

Return the maximum number of monsters that you can eliminate before you lose, or n if you can eliminate all the monsters before they reach the city.

### Examples

**Example 1:**
```
Input: dist = [1,3,4], speed = [1,1,1]
Output: 3
Explanation:
In the beginning, the distances of the monsters are [1,3,4]. You eliminate the first monster.
After a minute, the distances of the monsters are [X,2,3]. You eliminate the second monster.
After a minute, the distances of the monsters are [X,X,2]. You eliminate the third monster.
All 3 monsters can be eliminated.
```

**Example 2:**
```
Input: dist = [1,1,2,3], speed = [1,1,1,1]
Output: 1
Explanation:
In the beginning, the distances of the monsters are [1,1,2,3]. You eliminate the first monster.
After a minute, the distances of the monsters are [X,0,1,2], so you lose.
You can only eliminate 1 monster.
```

**Example 3:**
```
Input: dist = [3,2,4], speed = [5,3,2]
Output: 1
Explanation:
In the beginning, the distances of the monsters are [3,2,4]. You eliminate the first monster.
After a minute, the distances of the monsters are [X,0,2], so you lose.
You can only eliminate 1 monster
```

**Example 4:**
```
Input: dist = [3,2,4], speed = [5,3,2]
Output: 1
Explanation:
In the beginning, the distances of the monsters are [3,2,4]. You eliminate the first monster.
After a minute, the distances of the monsters are [X,0,2], so you lose.
You can only eliminate 1 monster
```

### Constraints

- `n == dist.length == speed.length`
- `1 <= n <= 10^5`
- `1 <= dist[i], speed[i] <= 10^5`

### Solution 1

#### Walkthrough

The key insight is that we should eliminate monsters in order of their **arrival time**, not their current distance. This greedy approach ensures we always eliminate the most urgent threat first.

**Step-by-step approach:**

1. **Calculate arrival time**: For each monster at distance `dist[i]` moving at `speed[i]`, it will reach the city at time `?dist[i] / speed[i]?` minutes. We use ceiling because if a monster arrives at time 1.5, it effectively arrives at minute 2.

2. **Sort by arrival time**: Sort monsters by when they'll arrive. This tells us the optimal elimination order - always eliminate the monster that will arrive soonest.

3. **Simulate elimination**: Starting at time 0 with a charged weapon:
   - At each minute `t`, check if the monster scheduled to arrive at `arrival[t]` has already reached or will reach the city before we can eliminate it
   - If `arrival[t] <= t`, the monster has arrived and we lose
   - Otherwise, eliminate the monster and move to the next minute

4. **Key observation**: Since we eliminate one monster per minute starting at minute 0, **the time elapsed `t` is always equal to the count of monsters eliminated**. This means:
   - At minute 0: we've eliminated 0 monsters (about to eliminate the 1st)
   - At minute 1: we've eliminated 1 monster (about to eliminate the 2nd)
   - At minute `t`: we've eliminated `t` monsters (about to eliminate the `(t+1)`th)

   This allows us to use a single loop variable `t` instead of tracking both `timeElapsed` and `count` separately!

#### Analysis

- **Time Complexity**: O(n log n) - Dominated by sorting the arrival times array
- **Space Complexity**: O(n) - For storing the arrival times array

#### Algorithm

\@ref(greedy), \@ref(sorting)

1. Calculate arrival time for each monster: `?dist[i] / speed[i]?`
2. Sort monsters by arrival time (ascending order)
3. Iterate through sorted arrival times:
   - At minute `t`, check if `arrival[t] <= t` (monster has arrived)
   - If yes, return `t` (number of monsters eliminated)
   - If no, continue to next minute
4. If all monsters eliminated, return `n`

#### Java Code

```java
class Solution {
    public int eliminateMaximum(int[] dist, int[] speed) {
        int n = dist.length;

        // Calculate arrival time for each monster
        int[] arrival = new int[n];
        for (int i = 0; i < n; i++) {
            arrival[i] = (int) Math.ceil((double) dist[i] / speed[i]);
        }

        // Sort by arrival time - eliminate monsters in order of urgency
        Arrays.sort(arrival);

        // Simulate elimination: at minute t, check if monster t has arrived
        for (int t = 0; t < n; t++) {
            if (arrival[t] <= t) {
                // Monster has arrived before we could eliminate it
                return t;
            }
        }

        // All monsters eliminated
        return n;
    }
}
```

### Notes

- **Pattern**: Greedy + Sorting
- **Key Insight**: The optimal strategy is to always eliminate the monster with the **earliest arrival time**, regardless of their current distance or speed. Sorting by arrival time naturally gives us this order.
- **Why Greedy Works**: Since we can only eliminate one monster per minute, we must prioritize by urgency (arrival time). Any other ordering would allow an earlier-arriving monster to reach the city.
- **Edge Case**: When `arrival[t] == t`, the monster reaches the city at the exact moment the weapon charges, which counts as a loss per the problem statement.
- **Optimization**: The time elapsed `t` is implicitly equal to the count of monsters eliminated, so we don't need a separate counter variable.
- **Common Mistakes**:
  - Sorting by distance instead of arrival time - this fails when a far-away fast monster arrives before a close slow monster
  - Forgetting to use ceiling division - fractional arrival times must be rounded up
  - Off-by-one errors with the condition `arrival[t] <= t` vs `arrival[t] < t`


## Longest Valid Parentheses {#longest-valid-parentheses}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 32
- **Difficulty**: Hard
- **URL**: https://leetcode.com/problems/longest-valid-parentheses/
- **Tags**: `Stack`, `Dynamic Programming`
- **Techniques**: Stack, Dynamic Programming \@ref(dp)

### Description

Given a string containing only `'('` and `')'`, return the length of the longest well-formed parentheses substring.

### Examples

```
Input: s = " )()() "
Output: 4
```

### Constraints

- `0 <= s.length <= 3 * 10^4`

### Solution - Stack

#### Walkthrough

Maintain a stack of indices. Push `-1` as a sentinel. For each character:
- When `'('`, push its index.
- When `')'`, pop the stack. If it becomes empty, push the current index (new base). Otherwise update the answer with `i - stack.peek()`.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(n)

#### Algorithm

1. Initialize stack with `-1` and `maxLen = 0`.
2. For each index `i`:
   - If `s[i] == '('`, push `i`.
   - Else pop; if stack empty push `i`, else `maxLen = max(maxLen, i - stack.peek())`.
3. Return `maxLen`.

#### Java Code
```java
public int longestValidParentheses(String s) {
    Deque<Integer> stack = new ArrayDeque<>();
    stack.push(-1);
    int longest = 0;

    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '(') {
            stack.push(i);
        } else {
            stack.pop();
            if (stack.isEmpty()) {
                stack.push(i);
            } else {
                longest = Math.max(longest, i - stack.peek());
            }
        }
    }

    return longest;
}

## Longest Increasing Subsequence {#lis}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 300
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/longest-increasing-subsequence/
- **Tags**: `Array`, `Binary Search`
- **Techniques**: Dynamic Programming \@ref(dp), Binary Search \@ref(binary-search)

### Description

Given an integer array, find the length of the longest strictly increasing subsequence.

### Examples

```
Input: [10,9,2,5,3,7,101,18]
Output: 4  (the LIS is [2,3,7,101])
```

### Constraints

- `1 <= nums.length <= 2500`
- `-10^4 <= nums[i] <= 10^4`

### Solution - Patience Sorting

#### Walkthrough

Maintain an array `tails` where `tails[len]` holds the smallest possible tail for an increasing subsequence of length `len+1`. For each number, binary search the first tail greater or equal to it and replace it; if none, append to extend the LIS.

#### Analysis

- **Time Complexity**: O(n log n)
- **Space Complexity**: O(n)

#### Algorithm

1. Initialize empty list `tails`.
2. For each number `x`:
   - Binary search `tails` to find the leftmost index `i` with `tails[i] >= x`.
   - If such index exists set `tails[i] = x`, else append `x`.
3. Return `tails.size()`.

#### Java Code
```java
public int lengthOfLIS(int[] nums) {
    int[] tails = new int[nums.length];
    int size = 0;

    for (int num : nums) {
        int left = 0;
        int right = size;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (tails[mid] < num) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        tails[left] = num;
        if (left == size) {
            size++;
        }
    }

    return size;
}

## Paint House {#paint-house}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 256
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/paint-house/
- **Tags**: `Array`, `Dynamic Programming`
- **Techniques**: Dynamic Programming \@ref(dp)

### Description

You are given an `n x 3` matrix `costs` where `costs[i][j]` denotes the cost of painting house `i` with color `j`. Adjacent houses must not share a color. Return the minimum total cost to paint all houses.

### Examples

```
Input: costs = [[17,2,17],[16,16,5],[14,3,19]]
Output: 10
```

### Constraints

- `1 <= n <= 100`
- `0 <= costs[i][j] <= 10^4`

### Solution - Rolling DP

#### Walkthrough

Keep three running totals for the cost of painting up to the current house when the current house ends in red, green, or blue. For house `i`, the red cost equals `costs[i][0] + min(previousGreen, previousBlue)`, and similarly for the other colors. Update the running totals and take the minimum at the end.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(1)

#### Algorithm

Dynamic Programming \@ref(dp)

1. Initialize `red = green = blue = 0`.
2. For each house:
   1. Compute new totals for each color by adding its cost to the minimum of the other two previous totals.
   2. Update `red`, `green`, `blue` to these new totals.
3. Return `min(red, green, blue)`.

#### Java Code
```java
public int minCost(int[][] costs) {
    int red = 0, green = 0, blue = 0;

    for (int[] cost : costs) {
        int newRed = cost[0] + Math.min(green, blue);
        int newGreen = cost[1] + Math.min(red, blue);
        int newBlue = cost[2] + Math.min(red, green);
        red = newRed;
        green = newGreen;
        blue = newBlue;
    }

    return Math.min(red, Math.min(green, blue));
}


## Climbing Stairs {#climbing-stairs}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 70
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/climbing-stairs/
- **Tags**: `Dynamic Programming`
- **Techniques**: Dynamic Programming \@ref(dp)

### Description

You are climbing a staircase with `n` steps. Each time you may climb 1 or 2 steps. Return the number of distinct ways to reach the top.

### Examples

```
Input: n = 3
Output: 3
Explanation: (1+1+1), (1+2), (2+1)
```

### Constraints

- `1 <= n <= 45`

### Solution - Fibonacci DP

#### Walkthrough

Let `dp[i]` be the number of ways to reach step `i`. You can arrive at `i` from `i-1` (taking a single step) or from `i-2` (taking two steps). Thus `dp[i] = dp[i-1] + dp[i-2]`. Initialize `dp[0] = 1`, `dp[1] = 1` and iterate upward.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(1) using rolling variables

#### Algorithm

Dynamic Programming \@ref(dp)

1. Handle base cases `n <= 2`.
2. Maintain two variables for `dp[i-1]` and `dp[i-2]`.
3. Iterate from 3 to `n`, computing the sum and shifting the variables.
4. Return the last computed value.

#### Java Code
```java
public int climbStairs(int n) {
    if (n <= 2) {
        return n;
    }

    int prev2 = 1; // ways to reach step i-2
    int prev1 = 2; // ways to reach step i-1

    for (int i = 3; i <= n; i++) {
        int current = prev1 + prev2;
        prev2 = prev1;
        prev1 = current;
    }

    return prev1;
}


## Maximum Number of Repetitions {#max-repetitions}

### Problem Metadata

- **Platform**: Firecode
- **Difficulty**: Medium
- **URL**: N/A
- **Tags**: `Array`, `Counting`
- **Techniques**: Counting

### Description

Given an array of integers where each value lies in `[0, n-1]`, return the integer that appears most frequently. The algorithm must run in O(n) time and O(1) extra space.

### Examples

```
Input: [3,1,2,2,3,4,4,4]
Output: 4
```

### Constraints

- `1 <= n <= 10^5`
- Values are in `[0, n-1]`

### Solution - In-place Counting

#### Walkthrough

Exploit the bounded value range by using the input array itself as a hash table. For each value `a[i]`, increment `a[a[i] % n]` by `n`. After one pass, the count of value `v` equals `a[v] / n`. Track the index with the maximum total.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(1)

#### Algorithm

1. Let `k = n` (or any value = n).
2. For each index `i`, add `k` to `arr[arr[i] % n]`.
3. Scan the array to find the index with the largest value; that index is the answer.

#### Java Code
```java
public int getMaxRepetition(int[] nums) {
    int n = nums.length;
    int k = n;

    for (int i = 0; i < n; i++) {
        nums[nums[i] % n] += k;
    }

    int maxIdx = 0;
    for (int i = 1; i < n; i++) {
        if (nums[i] > nums[maxIdx]) {
            maxIdx = i;
        }
    }

    return maxIdx;
}


## House Robber {#house-robber}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 198
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/house-robber/
- **Tags**: `Array`, `Dynamic Programming`
- **Techniques**: Dynamic Programming \@ref(dp)

### Description

Given a list of non-negative integers representing the amount of money in each house along a street, determine the maximum amount you can rob without robbing two adjacent houses.

### Examples

```
Input: [1,2,3,1]
Output: 4
```

### Constraints

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

### Solution - Linear DP

#### Walkthrough

Let `dp[i]` be the best we can do up to house `i`. For each house, we either rob it plus `dp[i-2]` or skip it and take `dp[i-1]`. Initialize the first two values and iterate.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(1) using rolling variables

#### Algorithm

Dynamic Programming \@ref(dp)

1. Handle `n == 1`.
2. Maintain `prev2` (dp[i-2]) and `prev1` (dp[i-1]).
3. For each house value `num`, compute `current = Math.max(prev1, prev2 + num)`.
4. Shift `prev2 = prev1`, `prev1 = current`.
5. Return `prev1`.

#### Java Code
```java
public int rob(int[] nums) {
    if (nums.length == 1) {
        return nums[0];
    }

    int prev2 = 0;
    int prev1 = 0;

    for (int value : nums) {
        int current = Math.max(prev1, prev2 + value);
        prev2 = prev1;
        prev1 = current;
    }

    return prev1;
}


## Best Time to Buy and Sell Stock {#stock-121}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 121
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
- **Tags**: `Array`, `Greedy`
- **Techniques**: Greedy

### Description

Given prices where `prices[i]` is the stock price on day `i`, find the maximum profit from a single buy and sell transaction.

### Examples

```
Input: [7,1,5,3,6,4]
Output: 5
```

### Constraints

- `1 <= prices.length <= 10^5`
- `0 <= prices[i] <= 10^4`

### Solution - Track Min Price

#### Walkthrough

Scan prices once while tracking the minimum price seen so far. For each day, compute the profit if we sold today (`price - minPrice`) and update the answer. Also update `minPrice` whenever we see a smaller value.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(1)

#### Algorithm

1. Initialize `minPrice = Integer.MAX_VALUE`, `maxProfit = 0`.
2. For each price `p`:
   - `maxProfit = max(maxProfit, p - minPrice)`.
   - `minPrice = min(minPrice, p)`.
3. Return `maxProfit`.

#### Java Code
```java
public int maxProfit(int[] prices) {
    int minPrice = Integer.MAX_VALUE;
    int maxProfit = 0;

    for (int price : prices) {
        if (price < minPrice) {
            minPrice = price;
        }
        maxProfit = Math.max(maxProfit, price - minPrice);
    }

    return maxProfit;
}


## Best Time to Buy and Sell Stock II {#stock-122}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 122
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/
- **Tags**: `Array`, `Greedy`
- **Techniques**: Greedy

### Description

You may complete as many stock transactions as you like (buy before sell, no overlapping transactions). Return the maximum profit.

### Examples

```
Input: [7,1,5,3,6,4]
Output: 7
Explanation: Buy at 1, sell at 5; buy at 3, sell at 6.
```

### Constraints

- `1 <= prices.length <= 10^5`

### Solution - Sum Positive Differences

#### Walkthrough

Whenever the price increases from day `i-1` to `i`, capture that profit by adding `prices[i] - prices[i-1]`. This mimics buying before each rise and selling at the peak.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(1)

#### Algorithm

1. Initialize `profit = 0`.
2. For each day `i > 0`, if `prices[i] > prices[i-1]`, add the difference to `profit`.
3. Return `profit`.

#### Java Code
```java
public int maxProfit(int[] prices) {
    int profit = 0;
    for (int i = 1; i < prices.length; i++) {
        if (prices[i] > prices[i - 1]) {
            profit += prices[i] - prices[i - 1];
        }
    }
    return profit;
}


## Best Time to Buy and Sell Stock with Cooldown {#stock-cooldown}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 309
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/
- **Tags**: `Array`, `Dynamic Programming`
- **Techniques**: Dynamic Programming \@ref(dp)

### Description

You may complete multiple transactions, but after selling a stock you must wait one day (cooldown) before buying again. Return the maximum profit.

### Examples

```
Input: [1,2,3,0,2]
Output: 3
```

### Constraints

- `1 <= prices.length <= 5000`

### Solution - State Machine DP

#### Walkthrough

Maintain three states per day:
- `hold`: profit when holding a stock
- `sold`: profit after selling today
- `rest`: profit when in cooldown or idle

Transition using previous day values: `hold = max(hold, rest - price)`, `sold = hold + price`, `rest = max(rest, sold_previous)`.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(1)

#### Algorithm

1. Initialize `hold = -prices[0]`, `sold = 0`, `rest = 0`.
2. For each subsequent price:
   - `int prevSold = sold;`
   - `sold = hold + price;`
   - `hold = Math.max(hold, rest - price);`
   - `rest = Math.max(rest, prevSold);`
3. Return `Math.max(sold, rest)`.

#### Java Code
```java
public int maxProfit(int[] prices) {
    int hold = -prices[0];
    int sold = 0;
    int rest = 0;

    for (int i = 1; i < prices.length; i++) {
        int prevSold = sold;
        sold = hold + prices[i];
        hold = Math.max(hold, rest - prices[i]);
        rest = Math.max(rest, prevSold);
    }

    return Math.max(sold, rest);
}


## Minimum Swaps to Make Sequences Increasing {#min-swaps-increasing}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 801
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/minimum-swaps-to-make-sequences-increasing/
- **Tags**: `Array`, `Dynamic Programming`
- **Techniques**: Dynamic Programming \@ref(dp)

### Description

Given two equal-length arrays `A` and `B` that are strictly increasing individually, you may swap elements at the same index. Return the minimum swaps needed to make both arrays strictly increasing.

### Examples

```
Input: A = [1,3,5,4], B = [1,2,3,7]
Output: 1
```

### Constraints

- `1 <= n <= 10^5`
- `0 <= A[i], B[i] <= 2 * 10^5`

### Solution - DP with Keep/Swap States

#### Walkthrough

Let `keep[i]` be the minimum swaps to keep index `i` un-swapped, and `swap[i]` when we swap at `i`. Initialize `keep[0] = 0`, `swap[0] = 1`. For each `i > 0`, consider whether the sequences remain increasing without swap, with swap, or both, and update the states accordingly.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(1)

#### Algorithm

1. Initialize `keep = 0`, `swap = 1`.
2. For each index `i` from 1 to `n-1`:
   - Set `nextKeep = nextSwap = Integer.MAX_VALUE`.
   - If `A[i] > A[i-1] && B[i] > B[i-1]`, update `nextKeep = min(nextKeep, keep)` and `nextSwap = min(nextSwap, swap + 1)`.
   - If `A[i] > B[i-1] && B[i] > A[i-1]`, update `nextKeep = min(nextKeep, swap)` and `nextSwap = min(nextSwap, keep + 1)`.
   - Assign `keep = nextKeep`, `swap = nextSwap`.
3. Return `min(keep, swap)`.

#### Java Code
```java
public int minSwap(int[] A, int[] B) {
    int keep = 0;
    int swap = 1;

    for (int i = 1; i < A.length; i++) {
        int nextKeep = Integer.MAX_VALUE;
        int nextSwap = Integer.MAX_VALUE;

        boolean noSwapNeeded = A[i] > A[i - 1] && B[i] > B[i - 1];
        boolean crossSwap = A[i] > B[i - 1] && B[i] > A[i - 1];

        if (noSwapNeeded) {
            nextKeep = Math.min(nextKeep, keep);
            nextSwap = Math.min(nextSwap, swap + 1);
        }
        if (crossSwap) {
            nextKeep = Math.min(nextKeep, swap);
            nextSwap = Math.min(nextSwap, keep + 1);
        }

        keep = nextKeep;
        swap = nextSwap;
    }

    return Math.min(keep, swap);
}


## Retrieve an Optimal Computation from an Array {#optimal-computation}

### Problem Metadata

- **Platform**: Firecode
- **Difficulty**: Medium
- **URL**: N/A
- **Tags**: `Array`, `Dynamic Programming`
- **Techniques**: Recursion \@ref(recursion), Memoization \@ref(memo)

### Description

You are given an array `taste` where each entry represents how tasty a chocolate bar is if eaten on day 1. Eating a bar on day `d` multiplies its taste by `d`. Each day you may eat exactly one bar from either end of the array. Compute the maximum total taste.

### Examples

```
Input: taste = [1,2,3,4]
Output: 30
Explanation: Eat 1,2,3,4 from left to right for 1*1 + 2*2 + 3*3 + 4*4.
```

### Constraints

- `1 <= taste.length <= 200`
- `1 <= taste[i] <= 10^3`

### Solution - Memoized Recursion

#### Walkthrough

When only the subarray `taste[i..j]` remains, the current day is `day = n - (j - i)` (since `n - (remaining length - 1)`). We may take either the left or right value. The optimal result is therefore:

```
max(day * taste[i] + solve(i+1, j, day+1),
    day * taste[j] + solve(i, j-1, day+1))
```

Caching the `(i, j)` results avoids recomputation and yields O(n?) states.

#### Analysis

- **Time Complexity**: O(n?)
- **Space Complexity**: O(n?) for memoization

#### Algorithm

1. Define `dfs(i, j)` returning the best score for subarray `[i, j]`.
2. The current day equals `n - (j - i)`.
3. Recursively compute both choices (left/right), memoize the maximum, and return it.
4. Start with `dfs(0, n-1)`.

#### Java Code
```java
public int maxTaste(int[] taste) {
    int n = taste.length;
    Integer[][] memo = new Integer[n][n];
    return dfs(taste, 0, n - 1, memo);
}

private int dfs(int[] taste, int left, int right, Integer[][] memo) {
    if (memo[left][right] != null) {
        return memo[left][right];
    }

    int day = taste.length - (right - left);
    if (left == right) {
        return day * taste[left];
    }

    int pickLeft = day * taste[left] + dfs(taste, left + 1, right, memo);
    int pickRight = day * taste[right] + dfs(taste, left, right - 1, memo);
    return memo[left][right] = Math.max(pickLeft, pickRight);
}


## Shortest Word Distance {#shortest-word-distance}

### Problem Metadata

- **Platform**: LeetCode
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/shortest-word-distance/
- **Tags**: `Array`, `Two Pointers`
- **Techniques**: Two Pointers \@ref(two-pointers)

### Description

Given a list of words and two target words `word1` and `word2`, return the minimum index distance between any occurrence of `word1` and `word2` in the list.

### Examples

```
Input: words = ["practice","makes","perfect","coding","makes"], word1 = "coding", word2 = "practice"
Output: 3
```

### Constraints

- `2 <= words.length <= 10^5`

### Solution - Single Pass

#### Walkthrough

Scan the array while recording the latest indices of `word1` and `word2`. Whenever both have been seen, compute their distance and track the minimum. This avoids storing full index lists.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(1)

#### Algorithm

1. Initialize `idx1 = idx2 = -1`, `answer = n`.
2. For each index `i`:
   - If `words[i] == word1`, set `idx1 = i`.
   - Else if `words[i] == word2`, set `idx2 = i`.
   - If both indices are valid, update `answer = min(answer, |idx1 - idx2|)`.
3. Return `answer`.

#### Java Code
```java
public int shortestDistance(String[] words, String word1, String word2) {
    int idx1 = -1;
    int idx2 = -1;
    int best = words.length;

    for (int i = 0; i < words.length; i++) {
        if (words[i].equals(word1)) {
            idx1 = i;
        } else if (words[i].equals(word2)) {
            idx2 = i;
        }

        if (idx1 != -1 && idx2 != -1) {
            best = Math.min(best, Math.abs(idx1 - idx2));
        }
    }

    return best;
}


## Minimum Operations to Make Binary Array Elements Equal to One I {#min-ops-binary-array}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 3191
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/minimum-operations-to-make-binary-array-elements-equal-to-one-i/
- **Tags**: `Array`, `Greedy`, `Simulation`
- **Techniques**: Sequential Traversal, Bit Manipulation

### Description

You are given a binary array `nums`. You can do the following operation on the array any number of times (possibly zero):

- Choose any 3 consecutive elements from the array and flip all of them.

Flipping an element means changing its value from 0 to 1, and from 1 to 0.

Return the minimum number of operations required to make all elements in `nums` equal to 1. If it is impossible, return -1.

### Examples

**Example 1:**
```
Input: nums = [0,1,1,1,0,0]
Output: 3
Explanation: We can do the following operations:
- Choose the elements at indices 0, 1 and 2. The resulting array is nums = [1,0,0,1,0,0].
- Choose the elements at indices 1, 2 and 3. The resulting array is nums = [1,1,1,0,0,0].
- Choose the elements at indices 3, 4 and 5. The resulting array is nums = [1,1,1,1,1,1].
```

**Example 2:**
```
Input: nums = [0,1,1,1]
Output: -1
Explanation: It is impossible to make all elements equal to 1.
```

### Constraints

- `3 <= nums.length <= 10^5`
- `0 <= nums[i] <= 1`

### Solution - Greedy Sequential Traversal

#### Walkthrough

The solution uses a **greedy left-to-right approach** based on a key observation: any 0 encountered in the array must be flipped to become 1, and the optimal time to flip it is as soon as we encounter it.

The algorithm works as follows:

1. **Traverse left to right** (indices 0 to `len-3`): For each position `i`, if `nums[i] == 0`, we must flip the window `[i, i+1, i+2]`. We can safely iterate only up to `len-3` because we need at least 3 elements to perform a flip operation.

2. **Use XOR for efficient flipping**: Instead of using `1 - nums[i]` to flip, the solution uses the XOR operator (`^= 1`) which is slightly more efficient and elegant for bit flipping.

3. **Verify the last two elements**: After processing all positions up to `len-3`, we check if the last two elements are both 1. If either is 0, it's impossible to fix them (no 3-element window remaining), so we return -1.

**Why this greedy approach is optimal:**
- Any 0 must eventually be flipped
- Flipping a 0 as soon as we encounter it (leftmost first) ensures we process the array in one pass
- Later flips may change earlier elements, but we've already ensured all earlier positions are 1
- The last two positions are "locked" after index `len-3`, so they determine if a solution exists

#### Analysis

- **Time Complexity**: O(n) - Single pass through the array with constant-time operations per element
- **Space Complexity**: O(1) - Only using constant extra space (count variable). The input array is modified in-place, which is acceptable for this problem.

**Optimization Notes:**
- Using XOR (`^= 1`) is more efficient than `1 - nums[i]` for bit flipping
- The loop stops at `len-2` (excluding last 2 positions) to avoid redundant checks
- Early continue when `nums[i] == 1` avoids unnecessary operations

#### Algorithm

\@ref(greedy)

1. Initialize `count = 0` to track number of flip operations
2. For each index `i` from 0 to `len-3`:
   - If `nums[i] == 1`, continue to next iteration
   - If `nums[i] == 0`:
     - Set `nums[i] = 1` (no need to XOR since we know it's 0)
     - Flip `nums[i+1]` using XOR: `nums[i+1] ^= 1`
     - Flip `nums[i+2]` using XOR: `nums[i+2] ^= 1`
     - Increment `count`
3. After loop, check final state:
   - If `nums[len-1] == 0` OR `nums[len-2] == 0`, return -1
   - Otherwise, return `count`

#### Java Code

```java
class Solution {
    public int minOperations(int[] nums) {
        int count = 0;
        int len = nums.length;

        for(int i = 0; i < len - 2; i++) {
            if(nums[i] == 1)
                continue;

            // Use XOR(^) to flip
            nums[i] = 1;
            nums[i+1] ^= 1;
            nums[i+2] ^= 1;

            count++;
        }

        // check if the last two bits are 1, nums[len-3] is already 1
        if(nums[len-1] == 0 || nums[len-2] == 0) {
            return -1;
        }

        return count;
    }
}
```



















































