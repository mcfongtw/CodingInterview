# Advanced Data Structure

## Design LRU Cache {#lru-cache}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 146
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/lru-cache/
- **Tags**: `Hash Table`, `Linked List`, `Design`
- **Techniques**: \@ref(hash-table), \@ref(linked-list)

### Description

Implement a Least Recently Used (LRU) cache that supports constant-time `get(key)` and `put(key, value)` operations. When the cache reaches capacity it must evict the least recently used entry before inserting a new one.

### Examples

```
LRUCache cache = new LRUCache(2);
cache.put(1, 1);
cache.put(2, 2);
cache.get(1); // 1
cache.put(3, 3); // evicts key 2
cache.get(2); // -1
cache.put(4, 4); // evicts key 1
cache.get(1); // -1
cache.get(3); // 3
cache.get(4); // 4
```

### Constraints

- `1 <= capacity <= 3000`
- `-10^4 <= key, value <= 10^4`
- At most `10^5` operations

### Solution 1 - Hash Map + Doubly Linked List

#### Walkthrough

Store key-to-node mappings in a hash map, while nodes form a doubly linked list ordered by recency. The head is most recent, tail is least recent. `get` moves the node to the head. `put` updates existing keys similarly or inserts a new node at the head and, if over capacity, removes the tail node and deletes it from the map. Sentinel head/tail nodes simplify pointer updates.

#### Analysis

- **Time Complexity**: O(1) per operation
- **Space Complexity**: O(capacity)

#### Algorithm

\@ref(hash-table), \@ref(linked-list)

1. Maintain `Map<Integer, Node> cache` and sentinel `head`, `tail`.
2. `get(key)`:
   - If key missing return `-1`.
   - Move node to head and return value.
3. `put(key, value)`:
   - If key exists, update value and move node to head.
   - Otherwise create new node at head and insert into map.
   - If size exceeds capacity remove tail predecessor and delete from map.

#### Java Code

```java
class LRUCache {
    private static class Node {
        int key, value;
        Node prev, next;
        Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }

    private final Map<Integer, Node> cache = new HashMap<>();
    private final Node head = new Node(0, 0);
    private final Node tail = new Node(0, 0);
    private final int capacity;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) {
            return -1;
        }
        moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        Node node = cache.get(key);
        if (node != null) {
            node.value = value;
            moveToHead(node);
            return;
        }
        Node fresh = new Node(key, value);
        cache.put(key, fresh);
        addAfterHead(fresh);
        if (cache.size() > capacity) {
            Node lru = tail.prev;
            remove(lru);
            cache.remove(lru.key);
        }
    }

    private void moveToHead(Node node) {
        remove(node);
        addAfterHead(node);
    }

    private void addAfterHead(Node node) {
        node.next = head.next;
        node.prev = head;
        head.next.prev = node;
        head.next = node;
    }

    private void remove(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
}
```

### Solution 2 - LinkedHashMap

#### Walkthrough

Javaâ€™s `LinkedHashMap` already maintains access order. Extend it and override `removeEldestEntry` to delete the oldest entry when size exceeds capacity. Calls to `get` and `put` become thin wrappers around the standard map operations.

#### Analysis

- **Time Complexity**: O(1) expected per operation
- **Space Complexity**: O(capacity)

#### Algorithm

\@ref(hash-table)

1. Extend `LinkedHashMap<Integer, Integer>` with accessOrder flag set to true.
2. Define `removeEldestEntry` to compare size with capacity.
3. Delegate `get`/`put` to underlying map.

#### Java Code

```java
class LRUCacheLinkedHashMap {
    private final LinkedHashMap<Integer, Integer> map;
    private final int capacity;

    public LRUCacheLinkedHashMap(int capacity) {
        this.capacity = capacity;
        this.map = new LinkedHashMap<>(capacity, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
                return size() > LRUCacheLinkedHashMap.this.capacity;
            }
        };
    }

    public int get(int key) {
        return map.getOrDefault(key, -1);
    }

    public void put(int key, int value) {
        map.put(key, value);
    }
}
```

## Implement Stack Using Queues {#design-stack}

### Problem Metadata

- **Platform**: Interview Prep
- **Problem ID**: Stack via Queue
- **Difficulty**: Easy
- **URL**: N/A
- **Tags**: `Queue`, `Stack`, `Design`
- **Techniques**: \@ref(queue)

### Description

Design a stack that supports `push`, `pop`, `top`, and `empty` using only standard queue operations.

### Examples

```
MyStack stack = new MyStack();
stack.push(1);
stack.push(2);
stack.top(); // 2
stack.pop(); // 2
stack.empty(); // false
```

### Constraints

- Use only queue operations: enqueue, dequeue, size, isEmpty

### Solution - Single Queue Rotation

#### Walkthrough

Maintain a single queue. For `push(x)` enqueue `x`, then rotate the previous elements to the back by dequeuing and enqueuing `size - 1` times, so that `x` becomes the front. `pop` and `top` are queue front operations.

#### Analysis

- **Time Complexity**: `push` O(n), others O(1)
- **Space Complexity**: O(n)

#### Algorithm

\@ref(queue)

1. `push(x)`: enqueue `x`, then loop `size-1` times moving front to back.
2. `pop()`: dequeue front.
3. `top()`: peek front.
4. `empty()`: check queue emptiness.

#### Java Code

```java
class MyStack {
    private final Queue<Integer> queue = new LinkedList<>();

    public void push(int x) {
        queue.offer(x);
        for (int i = 0; i < queue.size() - 1; i++) {
            queue.offer(queue.poll());
        }
    }

    public int pop() {
        return queue.poll();
    }

    public int top() {
        return queue.peek();
    }

    public boolean empty() {
        return queue.isEmpty();
    }
}
```

## Implement Queue {#design-queue}

### Problem Metadata

- **Platform**: Interview Prep
- **Problem ID**: Queue Design
- **Difficulty**: Easy
- **URL**: N/A
- **Tags**: `Array`, `Linked List`, `Stack`
- **Techniques**: \@ref(array), \@ref(linked-list), \@ref(stack)

### Description

Implement a queue with operations `enqueue`, `dequeue`, `peek`, and `isEmpty`. Explore multiple representations.

### Examples

```
MyQueue queue = new MyQueue(3);
queue.enqueue(1);
queue.enqueue(2);
queue.dequeue(); // 1
queue.enqueue(3);
queue.peek(); // 2
```

### Constraints

- Assume integers, bounded or unbounded based on implementation

### Solution 1 - Circular Array

#### Walkthrough

Use a fixed-size array with `head`, `tail`, and `count`. Enqueue writes at `tail` then wraps around; dequeue reads from `head`. This avoids shifting elements.

#### Analysis

- **Time Complexity**: O(1)
- **Space Complexity**: O(capacity)

#### Algorithm

\@ref(array)

1. Initialize `head = 0`, `tail = 0`, `count = 0`.
2. `enqueue(x)`: if count == capacity throw overflow; assign `data[tail] = x`, `tail = (tail + 1) % capacity`, increment count.
3. `dequeue()`: if empty throw, read `data[head]`, advance head, decrement count.
4. `peek()` returns `data[head]`.

#### Java Code

```java
class ArrayQueue {
    private final int[] data;
    private int head = 0;
    private int tail = 0;
    private int count = 0;

    public ArrayQueue(int capacity) {
        this.data = new int[capacity];
    }

    public void enqueue(int x) {
        if (count == data.length) {
            throw new IllegalStateException("Queue full");
        }
        data[tail] = x;
        tail = (tail + 1) % data.length;
        count++;
    }

    public int dequeue() {
        if (count == 0) {
            throw new NoSuchElementException();
        }
        int value = data[head];
        head = (head + 1) % data.length;
        count--;
        return value;
    }

    public int peek() {
        if (count == 0) {
            throw new NoSuchElementException();
        }
        return data[head];
    }

    public boolean isEmpty() {
        return count == 0;
    }
}
```

### Solution 2 - Linked List

#### Walkthrough

Maintain `front` and `rear` pointers of a singly linked list. Enqueue appends at the tail; dequeue removes from the head.

#### Analysis

- **Time Complexity**: O(1)
- **Space Complexity**: O(n)

#### Algorithm

\@ref(linked-list)

1. Each node holds value plus `next`.
2. `enqueue(x)`: create node, append at `rear`, update pointers.
3. `dequeue()`: remove `front`, adjusting `rear` when queue becomes empty.

#### Java Code

```java
class LinkedQueue {
    private static class Node {
        int val;
        Node next;
        Node(int val) { this.val = val; }
    }
    private Node front;
    private Node rear;

    public void enqueue(int x) {
        Node node = new Node(x);
        if (rear == null) {
            front = rear = node;
        } else {
            rear.next = node;
            rear = node;
        }
    }

    public int dequeue() {
        if (front == null) {
            throw new NoSuchElementException();
        }
        int value = front.val;
        front = front.next;
        if (front == null) {
            rear = null;
        }
        return value;
    }

    public int peek() {
        if (front == null) throw new NoSuchElementException();
        return front.val;
    }

    public boolean isEmpty() {
        return front == null;
    }
}
```

### Solution 3 - Two Stacks

#### Walkthrough

Use two stacks `in` and `out`. Enqueue pushes onto `in`. Dequeue/peek pop from `out`, reloading it from `in` when empty by moving all elements to reverse order.

#### Analysis

- **Time Complexity**: Amortized O(1)
- **Space Complexity**: O(n)

#### Algorithm

\@ref(stack)

1. `enqueue(x)`: push onto `in`.
2. `dequeue()` / `peek()`: if `out` empty, move all elements from `in` to `out`, then pop/peek.
3. `isEmpty()`: true when `in` and `out` are empty.

#### Java Code

```java
class QueueWithStacks {
    private final Deque<Integer> in = new ArrayDeque<>();
    private final Deque<Integer> out = new ArrayDeque<>();

    public void enqueue(int x) {
        in.push(x);
    }

    public int dequeue() {
        shift();
        return out.pop();
    }

    public int peek() {
        shift();
        return out.peek();
    }

    public boolean isEmpty() {
        return in.isEmpty() && out.isEmpty();
    }

    private void shift() {
        if (out.isEmpty()) {
            while (!in.isEmpty()) {
                out.push(in.pop());
            }
        }
    }
}
```

## Design HashSet {#design-hashset}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 705
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/design-hashset/
- **Tags**: `Hash Table`, `Design`
- **Techniques**: \@ref(hash-table)

### Description

Create a HashSet supporting `add(key)`, `contains(key)`, and `remove(key)` without using built-in hash table libraries.

### Examples

```
MyHashSet set = new MyHashSet();
set.add(1);
set.add(2);
set.contains(1); // true
set.contains(3); // false
set.add(2);
set.contains(2); // true
set.remove(2);
set.contains(2); // false
```

### Constraints

- `0 <= key <= 10^6`
- At most `10^4` operations

### Solution - Separate Chaining Buckets

#### Walkthrough

Create an array of buckets; each bucket holds a linked list of stored keys. The hash function is `key % capacity`. `add` inserts if absent, `remove` deletes from the chain, `contains` scans the list.

#### Analysis

- **Time Complexity**: Average O(1); worst-case O(n) if all keys collide
- **Space Complexity**: O(n)

#### Algorithm

\@ref(hash-table)

1. Choose bucket count (e.g., 1000) and allocate arrays of lists.
2. Map keys to bucket index via modulo.
3. Implement linked-list helpers to search, insert, remove within each bucket.

#### Java Code

```java
class MyHashSet {
    private static class Node {
        int key;
        Node next;
        Node(int key) { this.key = key; }
    }

    private final Node[] buckets;
    private final int size = 1000;

    public MyHashSet() {
        buckets = new Node[size];
    }

    public void add(int key) {
        int idx = key % size;
        Node head = buckets[idx];
        Node curr = head;
        while (curr != null) {
            if (curr.key == key) {
                return;
            }
            curr = curr.next;
        }
        Node node = new Node(key);
        node.next = head;
        buckets[idx] = node;
    }

    public void remove(int key) {
        int idx = key % size;
        Node dummy = new Node(-1);
        dummy.next = buckets[idx];
        Node prev = dummy;
        Node curr = dummy.next;
        while (curr != null) {
            if (curr.key == key) {
                prev.next = curr.next;
                break;
            }
            prev = curr;
            curr = curr.next;
        }
        buckets[idx] = dummy.next;
    }

    public boolean contains(int key) {
        int idx = key % size;
        Node curr = buckets[idx];
        while (curr != null) {
            if (curr.key == key) {
                return true;
            }
            curr = curr.next;
        }
        return false;
    }
}
```

## Design HashMap {#design-hashmap}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 706
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/design-hashmap/
- **Tags**: `Hash Table`, `Design`
- **Techniques**: \@ref(hash-table)

### Description

Implement a hash map supporting `put(key, value)`, `get(key)`, and `remove(key)` using separate chaining.

### Examples

```
MyHashMap map = new MyHashMap();
map.put(1, 1);
map.put(2, 2);
map.get(1); // 1
map.get(3); // -1
map.put(2, 1); // update
map.get(2); // 1
map.remove(2);
map.get(2); // -1
```

### Constraints

- `0 <= key, value <= 10^6`
- At most `10^4` operations

### Solution - Linked List Buckets

#### Walkthrough

Reuse the separate chaining idea but store key/value pairs in nodes. When inserting, update if the key already exists; otherwise add a new node at the bucket head. `remove` rewires the linked list as needed.

#### Analysis

- **Time Complexity**: Average O(1), worst-case O(n)
- **Space Complexity**: O(n)

#### Algorithm

\@ref(hash-table)

1. Buckets array sized at 10,000 to balance collisions.
2. Hash function `key % size`.
3. `put`: search for key; if found update value; else add new node.
4. `get`: search bucket; return value or `-1`.
5. `remove`: delete node from bucket list.

#### Java Code

```java
class MyHashMap {
    private static class Node {
        int key, value;
        Node next;
        Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }

    private final Node[] buckets;
    private final int size = 10000;

    public MyHashMap() {
        buckets = new Node[size];
    }

    public void put(int key, int value) {
        int idx = key % size;
        Node head = buckets[idx];
        Node curr = head;
        while (curr != null) {
            if (curr.key == key) {
                curr.value = value;
                return;
            }
            curr = curr.next;
        }
        Node node = new Node(key, value);
        node.next = head;
        buckets[idx] = node;
    }

    public int get(int key) {
        Node node = findNode(key);
        return node == null ? -1 : node.value;
    }

    public void remove(int key) {
        int idx = key % size;
        Node dummy = new Node(-1, -1);
        dummy.next = buckets[idx];
        Node prev = dummy;
        Node curr = dummy.next;
        while (curr != null) {
            if (curr.key == key) {
                prev.next = curr.next;
                break;
            }
            prev = curr;
            curr = curr.next;
        }
        buckets[idx] = dummy.next;
    }

    private Node findNode(int key) {
        int idx = key % size;
        Node curr = buckets[idx];
        while (curr != null) {
            if (curr.key == key) {
                return curr;
            }
            curr = curr.next;
        }
        return null;
    }
}
```

