\newglossaryentry{computer}
{
  name=computer,
  description={is a programmable machine that receives input,
               stores and manipulates data, and provides
               output in a useful format}
}

\newglossaryentry{dfs}{
    name={Depth First Traversal},
    description={is an algorithm for traversing or searching tree or graph data structures. The algorithm starts
at the root node and explores as far as possible along each branch \gls{recursive}ly. }
}

\newglossaryentry{bfs}{
    name={Breadth First Traversal},
    description={is an algorithm for traversing or searching tree or graph data structures. It starts at the tree
root, and explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next
depth level.}
}

\newglossaryentry{topological}{
    name={Topological Sorting},
    description={}
}

\newglossaryentry{minimax}{
    name={Minimax},
    description={(sometimes MinMax) is an algorithm for minimizing the possible loss for a worst case
    (maximum loss) scenario.}
}

\newglossaryentry{recursive}{
    name={Recursive},
    description={is a method of solving a problem where the solution depends on solutions to smaller
instances of the same problem}
}

\newglossaryentry{backtrack}{
%    parent={recursive},
    name={Backtrack},
    description={ is a method trying to construct a solution to a computational problem incrementally,
one small piece at a time. Whenever the algorithm needs to decide between multiple alternatives to the next
component of the solution, it \gls{recursive}ly evaluates \textbf{every} alternative and then chooses the best one.}
}

\newglossaryentry{dp}{
%    parent={recursive},
    name={Dynamic Programming},
    description={a method to  to simplify a complicated problem by breaking it down into simpler sub-problems in a
recursive manner. You have a main problem (the root of your tree of subproblems), and subproblems (subtrees). The
subproblems typically repeat and overlap. Common approach is implemented \gls{recursive}ly or iteratively table-filling. }
}

\newglossaryentry{memo} {
    name={Memoization},
    description={
an optimization technique used to speed up programs by storing the results of expensive function calls and returning the
cached result when the same inputs occur again. The implementation can be of form recursive call (or some iterative equivalent)}
}

\newglossaryentry{table} {
    name={Tabulation},
    description={is an approach where you solve a dynamic programming problem by first filling up a table, and then
compute the solution to the original problem based on the results in this table.}
}

\newglossaryentry{dnc}{
%    parent={recursive},
    name={Divide and Conquer},
    description={an algorithm to \gls{recursive}ly breaking down a problem into two or more sub-problems of the same or
related type, until these become simple enough to be solved directly. The solutions to the sub-problems are then
combined to give a solution to the original problem.}
}

\newglossaryentry{bst}{
    name={Binary Search Tree},
    description={a binary tree where nodes are ordered, where the keys in the left subtree are less then the key in its
parent node, and the keys in the right subtree are greater the key in its parent node.}
}

\newglossary*{sorting}{Sorting}

\newglossaryentry{ms}{
    type={sorting},
    name={Merge sort},
    description={a Divide and Conquer algorithm. It divides input array in two halves, calls itself for
the two halves and then merges the two sorted halves.}
}

\newglossaryentry{bs}{
    type={sorting},
    name={Bubble sort},
    description={a sorting algorithm that compares adjacent pairs and swaps them if necessary, causing the items to
"bubble" up toward their proper position. }
}

\newglossaryentry{qs} {
    type={sorting},
    name={Quick Sort},
    description={a Divide and Conquer algorithm. It picks an element as pivot and partitions the given array around the
    picked pivot.}
}

\newglossaryentry{heap} {
    name={Minimum Heap},
    description={a complete binary tree in which the value in each internal node is smaller than or equal
to the values in the children of that node. Thus, the root node is the smallest element in the tree.}
}
