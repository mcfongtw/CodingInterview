# String Manipulation

## Binary Representation {#binary-representation}

### Problem Metadata

- **Platform**: Firecode.io
- **Problem ID**: Binary Representation
- **Difficulty**: Level 2
- **URL**: https://www.firecode.io/
- **Tags**: `Math`, `String`
- **Techniques**: \@ref(dnc)

### Description

Given a positive integer `n`, return its binary representation as a string consisting of only `'0'` and `'1'`.

### Examples

```
Input: n = 6
Output: "110"

Input: n = 5
Output: "101"
```

### Constraints

- `0 <= n <= 2^31 - 1`

### Solution - Iterative Division

#### Walkthrough

Repeatedly divide by two and track remainders. Appending each remainder to the front of the result (or using a `StringBuilder` and reversing) yields the binary digits from most significant to least significant.

#### Analysis

- **Time Complexity**: O(log n) divisions
- **Space Complexity**: O(log n) to store the output

#### Algorithm

\@ref(dnc)

1. Handle `n == 0` by returning `"0"`.
2. While `n > 0`, compute `bit = n % 2` and prepend it to the answer.
3. Update `n /= 2`.

#### Java Code

```java
public String computeBinary(int n) {
    if (n == 0) {
        return "0";
    }

    StringBuilder sb = new StringBuilder();
    while (n > 0) {
        sb.append(n % 2);
        n /= 2;
    }

    return sb.reverse().toString();
}
```

## Insert Stars {#insert-stars}

### Problem Metadata

- **Platform**: Firecode.io
- **Problem ID**: Insert Stars
- **Difficulty**: Level 2
- **URL**: https://www.firecode.io/
- **Tags**: `Recursion`, `String`
- **Techniques**: \@ref(recursion)

### Description

Given a string `s`, recursively build a new string where any pair of identical adjacent characters is separated by a `'*'`.

### Examples

```
Input: "cc"
Output: "c*c"

Input: "cac"
Output: "cac"
```

### Constraints

- `1 <= s.length <= 10^4`
- Characters are ASCII

### Solution - Recursive Pair Expansion

#### Walkthrough

Base case is a single character. For longer strings, compare the first two characters. If equal, return `first + "*" + recurse(s[1:])`; otherwise, return `first + recurse(s[1:])`.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(n) recursion depth

#### Algorithm

\@ref(recursion)

1. If `s.length() <= 1`, return `s`.
2. Recursively compute the transformed suffix `rest = insertPairStar(s.substring(1))`.
3. If `s.charAt(0) == s.charAt(1)`, return `s[0] + "*" + rest`; else return `s[0] + rest`.

#### Java Code

```java
public String insertPairStar(String s) {
    if (s == null || s.length() <= 1) {
        return s;
    }
    String rest = insertPairStar(s.substring(1));
    if (s.charAt(0) == s.charAt(1)) {
        return s.charAt(0) + "*" + rest;
    }
    return s.charAt(0) + rest;
}
```

## Word Ladder {#word-ladder}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 127
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/word-ladder/
- **Tags**: `Breadth-First Search`, `Hash Table`
- **Techniques**: \@ref(bfs)

### Description

Given a begin word, end word, and a dictionary, return the length of the shortest transformation sequence from begin to end such that only one letter changes per step and every intermediate word exists in the dictionary. Return `0` if no sequence exists.

### Examples

```
Input: beginWord = "hit", endWord = "cog",
       wordList = ["hot","dot","dog","lot","log","cog"]
Output: 5
Explanation: "hit" -> "hot" -> "dot" -> "dog" -> "cog"
```

### Constraints

- All words have the same length
- Words consist of lowercase English letters
- `wordList` contains no duplicates

### Solution - BFS Over Word Mutations

#### Walkthrough

Perform BFS from `beginWord`. Each step generates all words formed by replacing one letter with `'a'..'z'`. Newly discovered dictionary entries are enqueued with distance `level + 1`. The first time `endWord` is dequeued we have the shortest length.

#### Analysis

- **Time Complexity**: O(26 * L * N) where `L` is word length and `N` is dictionary size
- **Space Complexity**: O(N)

#### Algorithm

\@ref(bfs)

1. Insert dictionary into a `Set` for O(1) lookups.
2. Initialize BFS queue with `beginWord` and level `1`.
3. For each dequeued word, mutate every position with every letter.
4. If mutation equals `endWord`, return `level + 1`.
5. If mutation existed in the dictionary, remove it and enqueue with incremented level.
6. Return `0` when the queue empties without finding `endWord`.

#### Java Code

```java
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    Set<String> dict = new HashSet<>(wordList);
    if (!dict.contains(endWord)) {
        return 0;
    }
    Queue<String> queue = new LinkedList<>();
    queue.offer(beginWord);
    int level = 1;

    while (!queue.isEmpty()) {
        for (int i = queue.size(); i > 0; i--) {
            String word = queue.poll();
            if (word.equals(endWord)) {
                return level;
            }
            char[] chars = word.toCharArray();
            for (int pos = 0; pos < chars.length; pos++) {
                char original = chars[pos];
                for (char c = 'a'; c <= 'z'; c++) {
                    if (c == original) continue;
                    chars[pos] = c;
                    String next = new String(chars);
                    if (dict.remove(next)) {
                        queue.offer(next);
                    }
                }
                chars[pos] = original;
            }
        }
        level++;
    }
    return 0;
}
```

## Longest Common Prefix {#longest-common-prefix}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 14
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/longest-common-prefix/
- **Tags**: `String`
- **Techniques**: \@ref(two-pointers)

### Description

Given an array of strings, return the longest common prefix string among them. If none exists, return `""`.

### Examples

```
Input: ["flower","flow","flight"]
Output: "fl"

Input: ["dog","racecar","car"]
Output: ""
```

### Constraints

- `0 <= strs.length <= 200`
- `0 <= strs[i].length <= 200`

### Solution - Column Scan

#### Walkthrough

Use the first string as a baseline. For each character index, ensure all other strings have the same character. Stop once a mismatch or end of string occurs.

#### Analysis

- **Time Complexity**: O(n * m), `n` strings and `m` average length
- **Space Complexity**: O(1)

#### Algorithm

\@ref(two-pointers)

1. Handle empty input.
2. Iterate index `i` across the first string.
3. For each `i`, compare `strs[j].charAt(i)` with `strs[0].charAt(i)`; return `strs[0].substring(0, i)` on mismatch.
4. If no mismatch, return the entire first string.

#### Java Code

```java
public String longestCommonPrefix(String[] strs) {
    if (strs == null || strs.length == 0) {
        return "";
    }
    for (int i = 0; i < strs[0].length(); i++) {
        char c = strs[0].charAt(i);
        for (int j = 1; j < strs.length; j++) {
            if (i == strs[j].length() || strs[j].charAt(i) != c) {
                return strs[0].substring(0, i);
            }
        }
    }
    return strs[0];
}
```

## Longest Common Substring {#longest-common-substring}

### Problem Metadata

- **Platform**: Interview Prep
- **Problem ID**: LCS Substring
- **Difficulty**: Medium
- **URL**: N/A
- **Tags**: `Dynamic Programming`, `String`
- **Techniques**: \@ref(dp)

### Description

Given two strings `s1` and `s2`, return the length of their longest common substring (contiguous sequence).

### Examples

```
Input: s1 = "abcdxyz", s2 = "xyzabcd"
Output: 4  // "abcd"
```

### Constraints

- `1 <= len(s1), len(s2) <= 10^3`
- Strings contain lowercase letters

### Solution - 2D DP Table

#### Walkthrough

Let `dp[i][j]` represent the length of the longest common substring ending at `s1[i]` and `s2[j]`. Initialize first row/column by comparing individual characters. For each match extend from `dp[i-1][j-1] + 1`; otherwise reset to zero. Track the maximum length seen.

#### Analysis

- **Time Complexity**: O(n * m)
- **Space Complexity**: O(n * m)

#### Algorithm

\@ref(dp)

1. Create `dp[len1][len2]`, initialize first row/column.
2. For each `i > 0` and `j > 0`, if `s1[i] == s2[j]` set `dp[i][j] = dp[i-1][j-1] + 1`, else `0`.
3. Maintain `maxLen`.
4. Return `maxLen`.

#### Java Code

```java
public int longestCommonSubstring(String s1, String s2) {
    int n = s1.length();
    int m = s2.length();
    int[][] dp = new int[n][m];
    int max = 0;

    for (int i = 0; i < n; i++) {
        dp[i][0] = (s1.charAt(i) == s2.charAt(0)) ? 1 : 0;
        max = Math.max(max, dp[i][0]);
    }
    for (int j = 0; j < m; j++) {
        dp[0][j] = (s1.charAt(0) == s2.charAt(j)) ? 1 : 0;
        max = Math.max(max, dp[0][j]);
    }
    for (int i = 1; i < n; i++) {
        for (int j = 1; j < m; j++) {
            if (s1.charAt(i) == s2.charAt(j)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
                max = Math.max(max, dp[i][j]);
            } else {
                dp[i][j] = 0;
            }
        }
    }
    return max;
}
```

## Longest Palindromic Substring {#longest-palindromic-substring}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 5
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/longest-palindromic-substring/
- **Tags**: `String`, `Dynamic Programming`
- **Techniques**: \@ref(dp)

### Description

Return the longest palindromic substring contained in `s`.

### Examples

```
Input: "babad"
Output: "bab"   // "aba" also valid

Input: "cbbd"
Output: "bb"
```

### Constraints

- `1 <= s.length <= 1000`
- `s` consists of digits and English letters

### Solution - DP via Reversed String

#### Walkthrough

Compute the longest common substring between `s` and its reverse. Matches correspond to palindromic substrings only when their indices line up (i.e., the substring reads the same forward and backward). Track the candidate with the greatest length that satisfies the index alignment rule.

#### Analysis

- **Time Complexity**: O(n^2)
- **Space Complexity**: O(n^2)

#### Algorithm

\@ref(dp)

1. Let `rev = reverse(s)`; create `dp[n][n]`.
2. For each pair `(i, j)` update `dp[i][j]` similar to LCS-substring.
3. When `dp[i][j] > currentMax`, ensure the substring indices align (`n - 1 - j + dp[i][j] - 1 == i`).
4. Update best boundaries accordingly.

#### Java Code

```java
public String longestPalindrome(String s) {
    int n = s.length();
    String rev = new StringBuilder(s).reverse().toString();
    int[][] dp = new int[n][n];
    int maxLen = 0;
    int end = 0;

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (s.charAt(i) == rev.charAt(j)) {
                if (i == 0 || j == 0) {
                    dp[i][j] = 1;
                } else {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                int beforeRev = n - 1 - j;
                if (dp[i][j] > maxLen && beforeRev + dp[i][j] - 1 == i) {
                    maxLen = dp[i][j];
                    end = i;
                }
            } else {
                dp[i][j] = 0;
            }
        }
    }

    return s.substring(end - maxLen + 1, end + 1);
}
```

## Word Break {#word-break}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 139
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/word-break/
- **Tags**: `Dynamic Programming`, `Trie`, `Recursion`
- **Techniques**: \@ref(recursion), \@ref(dp), \@ref(trie)

### Description

Given a string `s` and a dictionary `wordDict`, determine whether `s` can be segmented into a space-separated sequence of dictionary words.

### Examples

```
Input: s = "leetcode", wordDict = ["leet","code"]
Output: true

Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
Output: false
```

### Constraints

- `1 <= s.length <= 300`
- `1 <= wordDict.length <= 1000`
- Words consist of lowercase letters

### Solution 1 - Recursive Prefix Search

#### Walkthrough

Try every prefix; if it exists in the dictionary, recursively solve the remaining suffix. Use memoization to prune repeated states.

#### Analysis

- **Time Complexity**: Exponential without memoization; with memo, O(n^2) substring checks
- **Space Complexity**: O(n) recursion depth

#### Algorithm

\@ref(recursion)

1. Define `dfs(start)` returning `true` if substring from `start` can be segmented.
2. Iterate `end` from `start+1` to `n`, check whether `s[start:end]` is in the dictionary and `dfs(end)` is true.
3. Memoize failed indices to avoid recomputation.

#### Java Code

```java
public boolean wordBreakRecursive(String s, List<String> wordDict) {
    Set<String> dict = new HashSet<>(wordDict);
    Boolean[] memo = new Boolean[s.length()];
    return dfs(s, 0, dict, memo);
}

private boolean dfs(String s, int start, Set<String> dict, Boolean[] memo) {
    if (start == s.length()) {
        return true;
    }
    if (memo[start] != null) {
        return memo[start];
    }
    for (int end = start + 1; end <= s.length(); end++) {
        if (dict.contains(s.substring(start, end)) && dfs(s, end, dict, memo)) {
            return memo[start] = true;
        }
    }
    return memo[start] = false;
}
```

### Solution 2 - Bottom-Up Dynamic Programming

#### Walkthrough

Let `dp[i]` denote whether prefix `s[0:i)` can be segmented. For each ending index `i`, check dictionary words that could end at `i` and see if the preceding prefix was valid.

#### Analysis

- **Time Complexity**: O(n * m), where `m` is dictionary size
- **Space Complexity**: O(n)

#### Algorithm

\@ref(dp)

1. Initialize `dp[0] = true`.
2. For `end` from `1` to `n`, iterate dictionary words.
3. If `word` fits at the end and `dp[end - word.length()]` is true, set `dp[end] = true`.
4. Return `dp[n]`.

#### Java Code

```java
public boolean wordBreakDP(String s, List<String> wordDict) {
    boolean[] dp = new boolean[s.length() + 1];
    dp[0] = true;

    for (int end = 1; end <= s.length(); end++) {
        for (String word : wordDict) {
            int len = word.length();
            if (len <= end && dp[end - len] && s.substring(end - len, end).equals(word)) {
                dp[end] = true;
                break;
            }
        }
    }
    return dp[s.length()];
}
```

### Solution 3 - Trie-Assisted DP

#### Walkthrough

Insert dictionary words into a trie. While scanning the string, whenever `dp[i]` is true, walk the trie starting at `i` to mark reachable `dp[j]`. This prunes dictionary iterations when many words share prefixes.

#### Analysis

- **Time Complexity**: O(n * L) where `L` is average word length encountered
- **Space Complexity**: O(total dictionary characters)

#### Algorithm

\@ref(dp), \@ref(trie)

1. Build a trie with `isEnd` flags.
2. Initialize `dp[0] = true`.
3. For each index `i`, if `dp[i]` is true, traverse trie edges following `s[i...]`.
4. Whenever a trie node is terminal at index `j`, set `dp[j] = true`.

#### Java Code

```java
class TrieNode {
    boolean isEnd;
    TrieNode[] next = new TrieNode[26];
}

class Trie {
    TrieNode root = new TrieNode();

    void insert(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            int idx = c - 'a';
            if (node.next[idx] == null) {
                node.next[idx] = new TrieNode();
            }
            node = node.next[idx];
        }
        node.isEnd = true;
    }

    void advance(String s, int start, boolean[] dp) {
        TrieNode node = root;
        for (int i = start; i < s.length(); i++) {
            int idx = s.charAt(i) - 'a';
            if (node.next[idx] == null) {
                return;
            }
            node = node.next[idx];
            if (node.isEnd) {
                dp[i + 1] = true;
            }
        }
    }
}

public boolean wordBreakTrie(String s, List<String> wordDict) {
    Trie trie = new Trie();
    for (String word : wordDict) {
        trie.insert(word);
    }
    boolean[] dp = new boolean[s.length() + 1];
    dp[0] = true;
    for (int i = 0; i < s.length(); i++) {
        if (dp[i]) {
            trie.advance(s, i, dp);
        }
    }
    return dp[s.length()];
}
```

## Verifying an Alien Dictionary {#alien-dictionary}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 953
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/verifying-an-alien-dictionary/
- **Tags**: `Hash Table`, `String`
- **Techniques**: \@ref(hash-table)

### Description

Given the order of an alien alphabet and a list of words, determine if the words appear in lexicographically increasing order according to that alien alphabet.

### Examples

```
Input: words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"
Output: true

Input: words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"
Output: false
```

### Constraints

- `1 <= words.length <= 100`
- `1 <= words[i].length <= 20`
- `order` is a permutation of lowercase letters

### Solution - Pairwise Comparison with Rank Map

#### Walkthrough

Precompute the order rank for each letter. Compare consecutive words character by character. The first differing letter determines ordering; if it violates the rank order, return false. Handle prefix cases by ensuring the longer word does not precede its prefix.

#### Analysis

- **Time Complexity**: O(total letters)
- **Space Complexity**: O(1)

#### Algorithm

\@ref(hash-table)

1. Build `rank[26]` where `rank[c]` gives order.
2. For each adjacent pair `(w1, w2)`:
   1. Scan up to `min(len1, len2)`.
   2. If chars differ, compare via `rank` and stop.
   3. If all equal but `len1 > len2`, return false.
3. Return true if no violations occur.

#### Java Code

```java
public boolean isAlienSorted(String[] words, String order) {
    int[] rank = new int[26];
    for (int i = 0; i < order.length(); i++) {
        rank[order.charAt(i) - 'a'] = i;
    }

    for (int i = 0; i < words.length - 1; i++) {
        if (!inOrder(words[i], words[i + 1], rank)) {
            return false;
        }
    }
    return true;
}

private boolean inOrder(String w1, String w2, int[] rank) {
    int len = Math.min(w1.length(), w2.length());
    for (int i = 0; i < len; i++) {
        char c1 = w1.charAt(i);
        char c2 = w2.charAt(i);
        if (c1 != c2) {
            return rank[c1 - 'a'] < rank[c2 - 'a'];
        }
    }
    return w1.length() <= w2.length();
}
```

## First Non-Repeated Character {#first-non-repeated}

### Problem Metadata

- **Platform**: Interview Prep
- **Problem ID**: First Unique Character
- **Difficulty**: Easy
- **URL**: N/A
- **Tags**: `Hash Table`, `String`
- **Techniques**: \@ref(hash-table)

### Description

Given a string `s`, return the index of the first non-repeating character. If every character repeats, return `-1`.

### Examples

```
Input: "GeeksforGeeks"
Output: 5   // 'f'

Input: "GeeksQuiz"
Output: 0   // 'G'
```

### Constraints

- `1 <= s.length <= 10^5`
- String may contain uppercase and lowercase letters

### Solution - Frequency Counting

#### Walkthrough

Count occurrences of every character using an array keyed by ASCII value. A second pass over the string returns the first index with frequency `1`.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(1) (size of character set)

#### Algorithm

\@ref(hash-table)

1. Initialize `int[] freq = new int[256]`.
2. For each character, increment its count.
3. Iterate the string again; return the first index where `freq[c] == 1`.
4. Return `-1` if none.

#### Java Code

```java
public int firstUniqChar(String s) {
    int[] freq = new int[256];
    for (char c : s.toCharArray()) {
        freq[c]++;
    }
    for (int i = 0; i < s.length(); i++) {
        if (freq[s.charAt(i)] == 1) {
            return i;
        }
    }
    return -1;
}
```

