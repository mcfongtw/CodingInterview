# Math

## Power of Two {#power-of-two}

### Problem Metadata

- **Platform**: Firecode.io
- **Problem ID**: Power of Two
- **Difficulty**: Level 2
- **URL**: https://www.firecode.io/
- **Tags**: `Math`, `Bit Manipulation`, `Recursion`
- **Techniques**: \@ref(recursion)

### Description

Determine whether a positive integer `n` is a power of two.

### Examples

```
Input: 5
Output: false

Input: 8
Output: true
```

### Constraints

- `0 <= n <= 2^31 - 1`

### Solution 1 - Recursive Halving

#### Walkthrough

Repeatedly divide `n` by `2` as long as it is even. If we reach `1`, `n` is a power of two; if we encounter an odd number (other than `1`) or zero, it is not.

#### Analysis

- **Time Complexity**: O(log n)
- **Space Complexity**: O(log n) recursion depth

#### Algorithm

\@ref(recursion)

1. Handle `n <= 0` as `false`.
2. Base case `n == 1` is `true`.
3. If `n` is odd, return `false`.
4. Recurse on `n / 2`.

#### Java Code

```java
public boolean isPowerOfTwoRecursive(int n) {
    if (n <= 0) {
        return false;
    }
    if (n == 1) {
        return true;
    }
    if ((n & 1) == 1) {
        return false;
    }
    return isPowerOfTwoRecursive(n / 2);
}
```

### Solution 2 - Bitwise Trick

#### Walkthrough

Power of two numbers have a single bit set. Checking `n & (n - 1)` clears the lowest set bit; for powers of two, the result is zero.

#### Analysis

- **Time Complexity**: O(1)
- **Space Complexity**: O(1)

#### Java Code

```java
public boolean isPowerOfTwo(int n) {
    return n > 0 && (n & (n - 1)) == 0;
}
```

## Pow(x, n) {#pow-x-n}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 50
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/powx-n/
- **Tags**: `Math`, `Divide and Conquer`
- **Techniques**: \@ref(dnc), \@ref(recursion)

### Description

Implement `pow(x, n)` which computes `x` raised to the power `n` (`x^n`) for integer `n`.

### Examples

```
Input: x = 2.0, n = 10
Output: 1024.0

Input: x = 2.0, n = -2
Output: 0.25
```

### Constraints

- `-100 <= x <= 100`
- `-2^31 <= n <= 2^31 - 1`

### Solution - Fast Exponentiation

#### Walkthrough

Use exponentiation by squaring: `x^n = (x^{n/2})^2 * x^{n%2}`. Handle negative exponents by inverting `x` and negating `n`. Base cases are `n == 0 -> 1`, `n == 1 -> x`.

#### Analysis

- **Time Complexity**: O(log |n|)
- **Space Complexity**: O(log |n|) recursion stack

#### Algorithm

\@ref(dnc), \@ref(recursion)

1. If `n == 0`, return `1`.
2. If `n < 0`, invert `x` and negate `n`.
3. Recursively compute `half = pow(x, n / 2)`.
4. Combine as `half * half * (n % 2 == 0 ? 1 : x)`.

#### Java Code

```java
public double myPow(double x, int n) {
    long exp = n;
    if (exp < 0) {
        x = 1 / x;
        exp = -exp;
    }
    return fastPow(x, exp);
}

private double fastPow(double x, long n) {
    if (n == 0) {
        return 1.0;
    }
    double half = fastPow(x, n / 2);
    if (n % 2 == 0) {
        return half * half;
    }
    return half * half * x;
}
```

## Count Primes {#count-primes}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 204
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/count-primes/
- **Tags**: `Math`, `Sieve`
- **Techniques**: \@ref(dp)

### Description

Return the number of prime numbers strictly less than `n`.

### Examples

```
Input: n = 10
Output: 4   // 2,3,5,7
```

### Constraints

- `0 <= n <= 5 * 10^6`

### Solution - Sieve of Eratosthenes

#### Walkthrough

Maintain a boolean array marking composite numbers. Starting from `2`, whenever a number is unmarked (prime), mark all multiples starting at `i * i` as composite. Count the primes that remain unmarked below `n`.

#### Analysis

- **Time Complexity**: O(n log log n)
- **Space Complexity**: O(n)

#### Algorithm

\@ref(dp)

1. If `n < 2`, return `0`.
2. Create boolean `isComposite[n]`.
3. For each `i` up to `sqrt(n)`, if not composite, mark multiples `i * i, i * i + i, ...`.
4. Count indexes with value `false` (primes).

#### Java Code

```java
public int countPrimes(int n) {
    if (n < 2) {
        return 0;
    }
    boolean[] composite = new boolean[n];
    for (int i = 2; i * i < n; i++) {
        if (!composite[i]) {
            for (int j = i * i; j < n; j += i) {
                composite[j] = true;
            }
        }
    }
    int count = 0;
    for (int i = 2; i < n; i++) {
        if (!composite[i]) {
            count++;
        }
    }
    return count;
}
```

## Sum of Two Integers {#sum-two-integers}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 371
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/sum-of-two-integers/
- **Tags**: `Bit Manipulation`
- **Techniques**: \@ref(bitwise)

### Description

Calculate the sum of two integers `a` and `b` without using the `+` or `-` operators.

### Examples

```
Input: a = 1, b = 2
Output: 3
```

### Constraints

- `-1000 <= a, b <= 1000`

### Solution - Bitwise Addition

#### Walkthrough

Sum without carry is `a ^ b`; carry bits are `(a & b) << 1`. Iteratively propagate carry until it is zero.

#### Analysis

- **Time Complexity**: O(1) for fixed-width integers
- **Space Complexity**: O(1)

#### Algorithm

\@ref(bitwise)

1. While `b != 0`, compute `carry = (a & b) << 1` and `a = a ^ b`.
2. Set `b = carry`.
3. `a` becomes the final sum.

#### Java Code

```java
public int getSum(int a, int b) {
    while (b != 0) {
        int carry = (a & b) << 1;
        a = a ^ b;
        b = carry;
    }
    return a;
}
```

## Fibonacci Sequence {#fibonacci}

### Problem Metadata

- **Platform**: Firecode.io / Classic
- **Problem ID**: Fibonacci
- **Difficulty**: Level 2
- **URL**: https://www.firecode.io/
- **Tags**: `Dynamic Programming`, `Recursion`
- **Techniques**: \@ref(recursion), \@ref(dp), \@ref(memo)

### Description

Compute the `n`-th Fibonacci number where `F(0) = 0`, `F(1) = 1`, and `F(n) = F(n-1) + F(n-2)`.

### Examples

```
Input: n = 5
Output: 5
```

### Constraints

- `0 <= n <= 45`

### Solution 1 - Top-Down Recursion (NaÃ¯ve)

#### Walkthrough

Directly apply the recurrence `F(n) = F(n-1) + F(n-2)` with base cases `0` and `1`.

#### Analysis

- **Time Complexity**: O(2^n)
- **Space Complexity**: O(n) recursion depth

#### Java Code

```java
public int fibRecursive(int n) {
    if (n <= 1) {
        return n;
    }
    return fibRecursive(n - 1) + fibRecursive(n - 2);
}
```

### Solution 2 - Tail Recursion

#### Walkthrough

Carry two consecutive Fibonacci values forward so each call decrements `n` until reaching zero. Although still recursive, it avoids repeated subproblems.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(n) recursion depth (unless optimized by compiler)

#### Java Code

```java
public int fibTail(int n) {
    return fibTailHelper(n, 0, 1);
}

private int fibTailHelper(int n, int a, int b) {
    if (n == 0) {
        return a;
    }
    if (n == 1) {
        return b;
    }
    return fibTailHelper(n - 1, b, a + b);
}
```

### Solution 3 - Bottom-Up DP

#### Walkthrough

Iteratively build Fibonacci numbers from `0` to `n`, maintaining two running values.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(1)

#### Java Code

```java
public int fibIterative(int n) {
    if (n <= 1) {
        return n;
    }
    int prev = 0;
    int curr = 1;
    for (int i = 2; i <= n; i++) {
        int next = prev + curr;
        prev = curr;
        curr = next;
    }
    return curr;
}
```

### Solution 4 - Memoized Recursion

#### Walkthrough

Use a memo array to cache computed Fibonacci numbers, preventing redundant recursion.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(n)

#### Java Code

```java
public int fibMemo(int n) {
    int[] memo = new int[n + 1];
    Arrays.fill(memo, -1);
    return fibMemoHelper(n, memo);
}

private int fibMemoHelper(int n, int[] memo) {
    if (n <= 1) {
        return n;
    }
    if (memo[n] != -1) {
        return memo[n];
    }
    memo[n] = fibMemoHelper(n - 1, memo) + fibMemoHelper(n - 2, memo);
    return memo[n];
}
```

## Minimum Operations to Reduce to One {#min-ops-to-one}

### Problem Metadata

- **Platform**: Interview Prep
- **Problem ID**: Reduce to One
- **Difficulty**: Medium
- **URL**: N/A
- **Tags**: `Dynamic Programming`, `Recursion`
- **Techniques**: \@ref(recursion), \@ref(dp)

### Description

Given an integer `n`, you may perform operations: `n = n - 1`, `n = n / 2` (if even), or `n = n / 3` (if divisible by 3). Return the minimum number of operations needed to reduce `n` to 1.

### Examples

```
Input: 9
Output: 2  // 9 -> 3 -> 1

Input: 8
Output: 3  // 8 -> 4 -> 2 -> 1
```

### Constraints

- `1 <= n <= 10^6`

### Solution - Memoized Recursion

#### Walkthrough

Define `dp[n]` as the minimal operations to reach `1`. Recursively compute each option and cache results to avoid recomputation.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(n) for memoization

#### Algorithm

\@ref(recursion), \@ref(dp)

1. Base case: `dp[1] = 0`.
2. For other `n`, evaluate `1 + dp[n-1]`.
3. If divisible by `2` or `3`, also consider `1 + dp[n/2]`, `1 + dp[n/3]`.
4. Store the minimum in memo.

#### Java Code

```java
public int minStepsToOne(int n) {
    int[] memo = new int[n + 1];
    Arrays.fill(memo, -1);
    return dfs(n, memo);
}

private int dfs(int n, int[] memo) {
    if (n == 1) {
        return 0;
    }
    if (memo[n] != -1) {
        return memo[n];
    }
    int best = 1 + dfs(n - 1, memo);
    if (n % 2 == 0) {
        best = Math.min(best, 1 + dfs(n / 2, memo));
    }
    if (n % 3 == 0) {
        best = Math.min(best, 1 + dfs(n / 3, memo));
    }
    return memo[n] = best;
}
```

