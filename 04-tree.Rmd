# Tree

### Breadth First Traversal
The algorithm starts at the tree root, and explores all of the neighbor nodes at the present depth prior to moving
on to the nodes at the next depth level.

#### Algorithm
bfs \@ref(bfs)

#### Typical Implementation - Java
```java
public boolean breadthFirstTraversal(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList();

    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();

        if (node.left != null) {
            queue.offer(node.left);
        }

        if (node.right != null) {
            queue.offer(node.right);
        }
    }

    return false;
}
```

#### Complexity Analysis

* Time Complexity: Breadth-first search visits every vertex once and checks every edge in the graph once.
Therefore, the runtime complexity is $O(|V| + |E|)$. In simplicity, O(n) since $|V| = n$
* Auxiliary Space: In Breadth First traversal, visited node in different level is stored in a queue one by one.
Extra Space required is O(w) where w is maximum width of a level in binary tree.

### Depth First Traversal
The algorithm starts at the root node and explores as far as possible along each branch.

#### Algorithm
dfs \@ref(dfs)

#### Type of Depth First Traversal

* Depth First InOrder Traversal
* Depth First PreOrder Traversal
* Depth First PostOrder Traversal

#### Complexity Analysis

* Time Complexity: Depth-first search visits every vertex once and checks every edge in the graph once.
Therefore, the runtime complexity is $O(|V| + |E|)$. In simplicity, O(n) since $|V| = n$
* Auxiliary Space: In Depth First Traversals, stack (or function call stack) stores all ancestors of a node. Extra Space required is O(h) where h is maximum height of binary tree.

### Selection Strategy

- Extra Space can be one factor
- Depth First Traversals are typically recursive and recursive code requires function call overheads.
- The most important points is, BFS starts visiting nodes from root while DFS starts visiting nodes from leaves. So if our problem is to search something that is more likely to closer to root, we would prefer BFS. And if the target node is close to a leaf, we would prefer DFS
- Maximum Width of a Binary Tree at depth (or height) h can be 2h where h starts from 0. So the maximum number of nodes can be at the last level. And worst case occurs when Binary Tree is a perfect Binary Tree with numbers of node
- It is evident from above points that extra space required for Level order traversal is likely to be more when tree is more balanced and extra space for Depth First Traversal is likely to be more when tree is less balanced.

### Binary Search Tree
```{r, echo=FALSE, engine='tikz', out.width='90%', fig.ext=if (knitr:::is_latex_output()) 'pdf' else 'png', fig.cap='Some caption.', engine.opts = list(template = "latex/tikz2pdf.tex")}
\begin{tikzpicture}[
level 1/.style={sibling distance=10em},
level 2/.style={sibling distance=5em},
level 3/.style={sibling distance=5em},
level distance=2.5em,
]
\node {4}
child { node {2}
child {  node {1}}
child {  node {3}}
}
child { node {7}
child {  node {6}}
child {  node {9}}
}
;
\end{tikzpicture}
```

A BST is a binary tree where nodes are ordered in the following way:

- each node contains one key (also known as data)
- the keys in the left subtree are less then the key in its parent node
- the keys in the right subtree are greater the key in its parent node
- duplicate keys are not allowed.

#### Algorithm
bst \@ref(bst)

#### Complexity Analysis
The particular kind of binary tree is optimized in a way that only a PARTIAL nodes along a path will be visited during
search, the general time complexity is reduced to O(h) where h = log(n).

Since a binary search tree with n nodes has a minimum of O(log(n)) levels, it takes at least O(log(n)) comparisons to
find a particular node. However, in the edge cases  where tree is in a list form, the worst time complexity is O(n)



## Balanced Binary Tree {#balanced-binary-tree}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 110
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/balanced-binary-tree/
- **Tags**: `Tree`, `Binary Tree`, `DFS`
- **Techniques**: Depth First Search \@ref(dfs), Recursion \@ref(recursion)

### Description

Given a binary tree, determine if it is **height-balanced**.

For this problem, a height-balanced binary tree is defined as:

> A binary tree in which the depth of the two subtrees of **every** node never differ by more than 1.

### Examples

**Example 1:**
```{r, echo=FALSE, engine='tikz', out.width='90%', fig.ext=if (knitr:::is_latex_output()) 'pdf' else 'png', fig.cap='Balanced tree example', engine.opts = list(template = "latex/tikz2pdf.tex")}
\begin{tikzpicture}[
level 1/.style={sibling distance=10em},
level 2/.style={sibling distance=5em},
level 3/.style={sibling distance=5em},
level distance=2.5em,
]
\node {3}
    child { node {9}}
    child { node {20}
        child { node {15} }
        child { node {7} }
    }
;
\end{tikzpicture}
```
```
Input: root = [3,9,20,null,null,15,7]
Output: true
Explanation: Height of left subtree = 1, height of right subtree = 2, difference = 1 (balanced)
```

**Example 2:**
```{r, echo=FALSE, engine='tikz', out.width='90%', fig.ext=if (knitr:::is_latex_output()) 'pdf' else 'png', fig.cap='Unbalanced tree example', engine.opts = list(template = "latex/tikz2pdf.tex")}
\begin{tikzpicture}[
    level 1/.style={sibling distance=10em},
    level 2/.style={sibling distance=5em},
    level 3/.style={sibling distance=5em},
    level distance=2.5em,
    ]
\node {1}
    child { node {2}
        child {  node {3}
            child {  node {4}}
            child {  node {4}}
        }
        child {  node {3}}
    }
    child { node {2}}
;
\end{tikzpicture}
```
```
Input: root = [1,2,2,3,3,null,null,4,4]
Output: false
Explanation: Left subtree has much greater depth than right subtree
```

**Example 3:**
```
Input: root = []
Output: true
```

### Constraints

- The number of nodes in the tree is in the range `[0, 5000]`
- `-10^4 <= Node.val <= 10^4`

### Solution - Recursive DFS

#### Walkthrough

Use a recursive depth-first search to compute the height of each subtree.

For each node:
1. Recursively compute the height of the left subtree
2. Recursively compute the height of the right subtree
3. Check if the absolute difference between heights is greater than 1
4. If unbalanced at any node, propagate `-1` upward to indicate imbalance
5. Otherwise, return the maximum height + 1

The key insight is to combine height calculation with balance checking in a single pass.

#### Analysis

- **Time Complexity**: O(n) - Each node is visited exactly once
- **Space Complexity**: O(h) - Recursion call stack depth equals tree height h, where h can be log(n) for balanced trees or n for skewed trees

#### Algorithm

Depth First Search \@ref(dfs), Recursion \@ref(recursion)

1. If root is null, return 0 (base case)
2. Recursively get height of left subtree: `lHeight = getHeight(root.left)`
3. Recursively get height of right subtree: `rHeight = getHeight(root.right)`
4. If either subtree returned -1 (unbalanced), propagate -1 upward
5. If `|lHeight - rHeight| > 1`, return -1 (unbalanced)
6. Otherwise, return `max(lHeight, rHeight) + 1`

#### Java Code

```java
public boolean isBalanced(TreeNode root) {
    return getHeight(root) != -1;
}

private int getHeight(TreeNode root) {
    if (root == null) {
        return 0;
    }

    int lHeight = getHeight(root.left);
    int rHeight = getHeight(root.right);

    // If left or right subtree is unbalanced, propagate -1
    if (lHeight == -1 || rHeight == -1) {
        return -1;
    }

    // If current node is unbalanced, return -1
    if (Math.abs(lHeight - rHeight) > 1) {
        return -1;
    }

    // Return height of current subtree
    return Math.max(lHeight, rHeight) + 1;
}
```











### Solution - BFS with One Loops
#### Walkthrough
Create a queue and push node of the same level in a two dimensional array list while traversing the tree with
BFS algorithm.

#### Analysis
Breadth first traversal has time complexity of O(n), as every node is visited and thus  the space
complexity is also O(n).

#### Algorithm
 bfs \@ref(bfs)

#### Java Code - BFS with One Loop
```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> levels = new ArrayList<>();
    if (root == null) {
        return levels;
    }
    Queue<TreeNode> currentLevelQueue = new LinkedList<TreeNode>();
    Queue<TreeNode> nextLevelQueue = new LinkedList<TreeNode>();

    currentLevelQueue.offer(root);
    //init level to null
    List<Integer> level = null;

    while(!currentLevelQueue.isEmpty()) {
        TreeNode node = currentLevelQueue.poll();

        //starting a new level
        if (level == null) {
            level = new LinkedList<Integer>();
            levels.add(level);
        }
        level.add(node.val);

        //push children to next level queue
        if (node.left != null) {
            nextLevelQueue.offer(node.left);
        }
        if (node.right != null) {
            nextLevelQueue.offer(node.right);
        }

        //swap queue and next, where next collects all nodes for next level
        if (currentLevelQueue.isEmpty()) {
            Queue<TreeNode> temp = currentLevelQueue;
            currentLevelQueue = nextLevelQueue;
            nextLevelQueue = temp;
            //init level to null
            level = null;
        }
    }
    return levels;
}
```

### Solution - DFS
#### Walkthrough
We could traverse the tree recursively with \textbf{PreOrder} strategy, and additionally pass current level
into recursive method.

#### Analysis
DFS has time complexity of O(n) as every node is visited and thus Auxiliary Space is also O(n).

#### Algorithm
 dfs \@ref(dfs)

#### Java Code - DFS
```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> ans = new ArrayList<>();
    traverse(root, 0, ans);

    return ans;
}

private void traverse(TreeNode root, int level, List<List<Integer>> ans) {
    if(root == null){
        return;
    }

    if(ans.size()<=level){
        ans.add(new ArrayList<>());
    }

    ans.get(level).add(root.val);

    traverse(root.left, level + 1, ans);
    traverse(root.right, level + 1, ans);
}
```



## Binary Tree Level Order Traversal II {#level-order-bottom}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 107
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/binary-tree-level-order-traversal-ii/
- **Tags**: `Tree`, `BFS`
- **Techniques**: Breadth First Search \@ref(bfs)

### Description

Return the level order traversal of a binary tree from the bottom level up to the root.

### Examples

```
Input: [3,9,20,null,null,15,7]
Output: [[15,7],[9,20],[3]]
```

### Constraints

- `0 <= nodes <= 2000`

### Solution - Reverse BFS

#### Walkthrough

Perform BFS collecting nodes level by level. Instead of appending to the end, insert each level at the front of a linked list (or append and reverse at the end).

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(n)

#### Algorithm

1. Run BFS using a queue.
2. For each level size, dequeue nodes, record values, enqueue children.
3. Insert level list at the start of the result.

#### Java Code
```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    LinkedList<List<Integer>> result = new LinkedList<>();
    if (root == null) {
        return result;
    }

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> level = new ArrayList<>(size);

        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            level.add(node.val);
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }

        result.addFirst(level);
    }

    return result;
}
```## Binary Tree Zigzag Level Order Traversal {#zigzag-level-order}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 103
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/
- **Tags**: `Tree`, `BFS`
- **Techniques**: Breadth First Search \@ref(bfs)

### Description

Return the zigzag level order traversal of a binary tree (left-to-right, then right-to-left, alternating each level).

### Examples

```
Input: [3,9,20,null,null,15,7]
Output: [[3],[20,9],[15,7]]
```

### Constraints

- `0 <= nodes <= 2000`

### Solution - BFS with Direction Flag

#### Walkthrough

Perform level-order traversal. Track a boolean indicating whether to append values normally or reversed. For every level, either append values or insert at the front, and flip the flag.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(n)

#### Algorithm

1. Initialize queue with root and a boolean `leftToRight = true`.
2. For each level, collect values in a list.
3. If `leftToRight`, append; otherwise insert at front or use reverse list.
4. Toggle `leftToRight` each level.

#### Java Code
```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    boolean leftToRight = true;

    while (!queue.isEmpty()) {
        int size = queue.size();
        LinkedList<Integer> level = new LinkedList<>();

        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            if (leftToRight) {
                level.addLast(node.val);
            } else {
                level.addFirst(node.val);
            }

            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }

        result.add(level);
        leftToRight = !leftToRight;
    }

    return result;
}
```## Count Complete Tree Nodes / Leet Code 222 / Medium

### Description
Given a complete binary tree, count the number of nodes.  In a complete binary tree every level, except possibly
the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between
1 and 2h nodes inclusive at the last level h. In a full binary tree, it is completely filled at the last level,
leaving the total node number of $2^{height} - 1$

### Example
```{r, echo=FALSE, engine='tikz', out.width='90%', fig.ext=if (knitr:::is_latex_output()) 'pdf' else 'png', fig.cap='Some caption.', engine.opts = list(template = "latex/tikz2pdf.tex")}
\begin{tikzpicture}[
level 1/.style={sibling distance=10em},
level 2/.style={sibling distance=5em},
level 3/.style={sibling distance=5em},
level distance=2.5em,
]
\node {1}
child { node {2}
    child { node {4}}
    child {  node {5}}
}
child {  node {3}
    child {  node {6}}
}
;
\end{tikzpicture}
```
output 6

### Solution
#### Walkthrough
Recursively call at each node, and determine if it is a full binary tree or complete binary tree. if it is full
binary tree (left height == right height), return $(2^{h} - 1)$, else return 1 + rec(node.left) + rec(node.right)

#### Analysis
Time complexity is O(n) as every node is visited once.

#### Algorithm
 dfs \@ref(dfs)

#### Java Code
```java
public int countNodes(TreeNode root) {
    if(root == null) {
        return 0;
    }
    int lHeight = 0, rHeight = 0;

    for (TreeNode node = root; node != null; node = node.left, lHeight++);
    for (TreeNode node = root; node != null; node = node.right, rHeight++);

    if (lHeight == rHeight) {
        /*
        * full binary tree
        * 2^leftNum - 1
        */
        return (1 << lHeight) - 1;
    } else {
        return 1 + countNodes(root.left) + countNodes(root.right);
    }
}
```



### Solution
#### Walkthrough
Have a global variable of ArrayList to remember the path. Create a helper function to recursively traverse the tree.
If the target does not lie either in the left or right subtree of the current node.Thus, remove current node's value
from trace list.

#### Analysis
Time complexity is O(n) as every node is visited once.

#### Algorithm
 backtrack \@ref(backtrack), dfs \@ref(dfs)

#### Java Code
```java
List<TreeNode> trace = new ArrayList<>();

int pathLengthFromRoot(TreeNode root, int target) {
    path.clear();

    boolean result = backtrack(root, target);

    if(result) {
        return trace.size();
    } else {
        return 0;
    }
}

boolean backtrack(TreeNode root, int target) {
    trace.add(root);

    if(root == null) {
        return false;
    }
    if(root.data == target) {
        //found the node
        return true;
    }

    if(backtrack(root.left, target) || backtrack(root.right, target) ) {
        return true;
    }

    //not in current path, backtrack
    trace.remove(path.size() - 1);
    return false;
}
```


## Path Sum {#path-sum}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 112
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/path-sum/
- **Tags**: `Tree`, `DFS`
- **Techniques**: Depth First Search \@ref(dfs)

### Description

Determine if a binary tree has a root-to-leaf path whose node values sum to a target.

### Examples

```
Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], target = 22
Output: true
```

### Constraints

- `0 <= nodes <= 5000`

### Solution - DFS with Running Sum

#### Walkthrough

Traverse the tree, accumulating the current sum along the path. When a leaf is reached, check if the sum equals the target. Short-circuit as soon as a valid path is found.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(h)

#### Java Code
```
public boolean hasPathSum(TreeNode root, int targetSum) {
    if (root == null) {
        return false;
    }
    if (root.left == null && root.right == null) {
        return targetSum == root.val;
    }
    int remaining = targetSum - root.val;
    return hasPathSum(root.left, remaining) || hasPathSum(root.right, remaining);
}
```## Path Sum II {#path-sum-ii}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 113
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/path-sum-ii/
- **Tags**: `Tree`, `Backtracking`
- **Techniques**: Backtracking \@ref(backtrack)

### Description

Find all root-to-leaf paths where the sum of node values equals a target.

### Solution - Backtracking

#### Walkthrough

Traverse the tree, maintaining the current path list and remaining sum. When a leaf reaches zero remaining sum, append a copy of the path to the answer. Backtrack after exploring each branch.

#### Analysis

- **Time Complexity**: O(n * h)
- **Space Complexity**: O(h)

#### Java Code
```
public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
    List<List<Integer>> result = new ArrayList<>();
    backtrack(root, targetSum, new ArrayList<>(), result);
    return result;
}

private void backtrack(TreeNode node, int remain, List<Integer> path, List<List<Integer>> result) {
    if (node == null) {
        return;
    }

    path.add(node.val);
    remain -= node.val;

    if (node.left == null && node.right == null && remain == 0) {
        result.add(new ArrayList<>(path));
    } else {
        backtrack(node.left, remain, path, result);
        backtrack(node.right, remain, path, result);
    }

    path.remove(path.size() - 1);
}
```## Path Sum III {#path-sum-iii}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 437
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/path-sum-iii/
- **Tags**: `Tree`, `Prefix Sum`
- **Techniques**: Depth First Search \@ref(dfs)

### Description

Count the number of paths in a binary tree that sum to a target. Paths may start and end anywhere but must go downward.

### Solution - Prefix Sum DFS

#### Walkthrough

Use DFS while tracking a running prefix sum and a hash map of prefix counts. For each node, check how many previous prefix sums equal `currentSum - target`. Update the map while exploring children and backtrack counts afterward.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(h)

#### Java Code
```
public int pathSum(TreeNode root, int targetSum) {
    Map<Integer, Integer> prefix = new HashMap<>();
    prefix.put(0, 1);
    return dfs(root, 0, targetSum, prefix);
}

private int dfs(TreeNode node, int current, int target, Map<Integer, Integer> prefix) {
    if (node == null) {
        return 0;
    }

    current += node.val;
    int count = prefix.getOrDefault(current - target, 0);
    prefix.put(current, prefix.getOrDefault(current, 0) + 1);

    count += dfs(node.left, current, target, prefix);
    count += dfs(node.right, current, target, prefix);

    prefix.put(current, prefix.get(current) - 1);
    return count;
}
```## Binary Tree Preorder Traversal {#preorder-traversal}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 144
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/binary-tree-preorder-traversal/
- **Tags**: `Tree`, `DFS`
- **Techniques**: Depth First Search \@ref(dfs)

### Description

Return the preorder traversal (root-left-right) of a binary tree.

### Solution - Iterative Stack

#### Walkthrough

Push root to a stack. Pop, record value, then push right and left children (right first so left is processed next). Repeat until stack empty.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(n)

#### Java Code
```
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) {
        return result;
    }

    Deque<TreeNode> stack = new ArrayDeque<>();
    stack.push(root);

    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        result.add(node.val);
        if (node.right != null) {
            stack.push(node.right);
        }
        if (node.left != null) {
            stack.push(node.left);
        }
    }
    return result;
}
```

### Solution - Recursive

```
public List<Integer> preorderTraversalRecursive(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    dfs(root, result);
    return result;
}

private void dfs(TreeNode node, List<Integer> list) {
    if (node == null) {
        return;
    }
    list.add(node.val);
    dfs(node.left, list);
    dfs(node.right, list);
}
```## Binary Tree Inorder Traversal {#inorder-traversal}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 94
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/binary-tree-inorder-traversal/
- **Tags**: `Tree`, `DFS`
- **Techniques**: Depth First Search \@ref(dfs)

### Description

Return the inorder traversal (left-root-right) of a binary tree.

### Solution - Iterative Stack

```
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    Deque<TreeNode> stack = new ArrayDeque<>();
    TreeNode current = root;

    while (current != null || !stack.isEmpty()) {
        while (current != null) {
            stack.push(current);
            current = current.left;
        }
        current = stack.pop();
        result.add(current.val);
        current = current.right;
    }
    return result;
}
```

### Solution - Recursive

```
public List<Integer> inorderTraversalRecursive(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    dfs(root, result);
    return result;
}

private void dfs(TreeNode node, List<Integer> list) {
    if (node == null) {
        return;
    }
    dfs(node.left, list);
    list.add(node.val);
    dfs(node.right, list);
}
```## Binary Tree Postorder Traversal {#postorder-traversal}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 145
- **Difficulty**: Hard
- **URL**: https://leetcode.com/problems/binary-tree-postorder-traversal/
- **Tags**: `Tree`, `DFS`
- **Techniques**: Depth First Search \@ref(dfs)

### Description

Return the postorder traversal (left-right-root) of a binary tree.

### Solution - Iterative Stack

```
public List<Integer> postorderTraversal(TreeNode root) {
    LinkedList<Integer> result = new LinkedList<>();
    if (root == null) {
        return result;
    }

    Deque<TreeNode> stack = new ArrayDeque<>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        result.addFirst(node.val);
        if (node.left != null) {
            stack.push(node.left);
        }
        if (node.right != null) {
            stack.push(node.right);
        }
    }
    return result;
}
```

### Solution - Recursive

```
private void dfs(TreeNode node, List<Integer> list) {
    if (node == null) {
        return;
    }
    dfs(node.left, list);
    dfs(node.right, list);
    list.add(node.val);
}
```## Maximum Depth of Binary Tree {#max-depth}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 104
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/maximum-depth-of-binary-tree/
- **Tags**: `Tree`
- **Techniques**: DFS \@ref(dfs)

### Description

Return the maximum depth (number of nodes along the longest path from root down to a leaf).

### Solution - DFS

```
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}
```## Minimum Depth of Binary Tree {#min-depth}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 111
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/minimum-depth-of-binary-tree/
- **Tags**: `Tree`
- **Techniques**: DFS \@ref(dfs)

### Description

Return the minimum depth from root to the nearest leaf.

### Solution - DFS

```
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    if (root.left == null) {
        return 1 + minDepth(root.right);
    }
    if (root.right == null) {
        return 1 + minDepth(root.left);
    }
    return 1 + Math.min(minDepth(root.left), minDepth(root.right));
}
```## Count Univalue Subtrees {#count-univalue}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 250
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/count-univalue-subtrees/
- **Tags**: `Tree`, `DFS`

### Description

Count subtrees where every node has the same value.

### Solution - DFS

Traverse bottom-up. A node is univalue if both children are univalue and match the current value.

```
public int countUnivalSubtrees(TreeNode root) {
    int[] count = new int[1];
    dfs(root, count);
    return count[0];
}

private boolean dfs(TreeNode node, int[] count) {
    if (node == null) {
        return true;
    }
    boolean left = dfs(node.left, count);
    boolean right = dfs(node.right, count);
    if (!left || !right) {
        return false;
    }
    if (node.left != null && node.left.val != node.val) {
        return false;
    }
    if (node.right != null && node.right.val != node.val) {
        return false;
    }
    count[0]++;
    return true;
}
```## Validate Binary Search Tree {#validate-bst}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 98
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/validate-binary-search-tree/
- **Tags**: `Tree`, `DFS`

### Description

Check whether a binary tree is a valid BST.

### Solution - Inorder Bounds

Use DFS while carrying min/max bounds.

```
public boolean isValidBST(TreeNode root) {
    return validate(root, null, null);
}

private boolean validate(TreeNode node, Integer low, Integer high) {
    if (node == null) {
        return true;
    }
    if ((low != null && node.val <= low) || (high != null && node.val >= high)) {
        return false;
    }
    return validate(node.left, low, node.val) && validate(node.right, node.val, high);
}
```## Binary Tree Upside Down {#upside-down}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 156
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/binary-tree-upside-down/
- **Tags**: `Tree`

### Description

Flip the tree so that every right child becomes a left sibling.

### Solution - Recursive Rotation

```
public TreeNode upsideDownBinaryTree(TreeNode root) {
    if (root == null || root.left == null) {
        return root;
    }
    TreeNode newRoot = upsideDownBinaryTree(root.left);
    root.left.left = root.right;
    root.left.right = root;
    root.left = null;
    root.right = null;
    return newRoot;
}
```## Inorder Successor in BST {#inorder-successor}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 285
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/inorder-successor-in-bst/
- **Tags**: `Tree`

### Description

Find the inorder successor of a given node in a BST.

### Solution - BST Properties

```
public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
    TreeNode succ = null;
    while (root != null) {
        if (p.val < root.val) {
            succ = root;
            root = root.left;
        } else {
            root = root.right;
        }
    }
    return succ;
}
```## Binary Tree Longest Consecutive Sequence {#longest-consecutive}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 298
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/binary-tree-longest-consecutive-sequence/
- **Tags**: `Tree`

### Description

Find the length of the longest path where consecutive nodes differ by +1.

### Solution - DFS Tracking

```
public int longestConsecutive(TreeNode root) {
    return dfs(root, null, 0);
}

private int dfs(TreeNode node, TreeNode parent, int length) {
    if (node == null) {
        return length;
    }
    if (parent != null && node.val == parent.val + 1) {
        length++;
    } else {
        length = 1;
    }
    int left = dfs(node.left, node, length);
    int right = dfs(node.right, node, length);
    return Math.max(length, Math.max(left, right));
}
```## Find Leaves of Binary Tree {#find-leaves}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 366
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/find-leaves-of-binary-tree/
- **Tags**: `Tree`

### Description

Collect nodes layer by layer from leaves upward.

### Solution - Height DFS

Compute the height of each node (distance from leaf). Use height as index to append values to the result list.

```
public List<List<Integer>> findLeaves(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    height(root, result);
    return result;
}

private int height(TreeNode node, List<List<Integer>> result) {
    if (node == null) {
        return -1;
    }
    int h = Math.max(height(node.left, result), height(node.right, result)) + 1;
    if (result.size() == h) {
        result.add(new ArrayList<>());
    }
    result.get(h).add(node.val);
    return h;
}
```## Diameter of Binary Tree {#diameter}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 543
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/diameter-of-binary-tree/
- **Tags**: `Tree`

### Description

Return the length of the longest path between any two nodes.

### Solution - Depth Helper

Use DFS to compute depth of each subtree and track the maximum `leftDepth + rightDepth`.

```
public int diameterOfBinaryTree(TreeNode root) {
    int[] diameter = new int[1];
    depth(root, diameter);
    return diameter[0];
}

private int depth(TreeNode node, int[] diameter) {
    if (node == null) {
        return 0;
    }
    int left = depth(node.left, diameter);
    int right = depth(node.right, diameter);
    diameter[0] = Math.max(diameter[0], left + right);
    return Math.max(left, right) + 1;
}
```## Binary Tree Serialization {#tree-serialization}

### Problem Metadata

- **Platform**: Firecode/LeetCode 297
- **Difficulty**: Medium
- **Tags**: `Tree`

### Description

Serialize a binary tree to string and deserialize back.

### Solution - Preorder with Null Markers

```
private static final String SEP = ",";
private static final String NULL = "#";

public String serialize(TreeNode root) {
    StringBuilder sb = new StringBuilder();
    serialize(root, sb);
    return sb.toString();
}

private void serialize(TreeNode node, StringBuilder sb) {
    if (node == null) {
        sb.append(NULL).append(SEP);
        return;
    }
    sb.append(node.val).append(SEP);
    serialize(node.left, sb);
    serialize(node.right, sb);
}

public TreeNode deserialize(String data) {
    Queue<String> queue = new LinkedList<>(Arrays.asList(data.split(SEP)));
    return deserialize(queue);
}

private TreeNode deserialize(Queue<String> queue) {
    String val = queue.poll();
    if (val.equals(NULL)) {
        return null;
    }
    TreeNode node = new TreeNode(Integer.parseInt(val));
    node.left = deserialize(queue);
    node.right = deserialize(queue);
    return node;
}
```## Fill in the Ancestors of the Node {#fill-ancestors}

### Description

Given a node, print ancestors from root to parent.

### Solution

Do DFS and build path; when target found, print path.

```
public boolean printAncestors(TreeNode root, int key, List<Integer> ancestors) {
    if (root == null) {
        return false;
    }
    if (root.val == key) {
        return true;
    }
    if (printAncestors(root.left, key, ancestors) || printAncestors(root.right, key, ancestors)) {
        ancestors.add(root.val);
        return true;
    }
    return false;
}
```## Find the k-th Largest Node in a BST {#kth-largest}

### Description

Return the k-th largest node value in a BST.

### Solution - Reverse Inorder

```
public int kthLargest(TreeNode root, int k) {
    Stack<TreeNode> stack = new Stack<>();
    TreeNode current = root;
    while (current != null || !stack.isEmpty()) {
        while (current != null) {
            stack.push(current);
            current = current.right;
        }
        current = stack.pop();
        if (--k == 0) {
            return current.val;
        }
        current = current.left;
    }
    return -1;
}
```## Convert Sorted Array to BST {#sorted-array-bst}

### Description

Convert a sorted array to a height-balanced BST.

### Solution - Divide and Conquer

```
public TreeNode sortedArrayToBST(int[] nums) {
    return build(nums, 0, nums.length - 1);
}

private TreeNode build(int[] nums, int left, int right) {
    if (left > right) {
        return null;
    }
    int mid = left + (right - left) / 2;
    TreeNode node = new TreeNode(nums[mid]);
    node.left = build(nums, left, mid - 1);
    node.right = build(nums, mid + 1, right);
    return node;
}
```## Populating Next Right Pointers in Each Node {#connect-next}

### Description

Connect each node's `next` pointer to its right neighbor on the same level in a perfect binary tree.

### Solution - O(1) Level Traversal

```
public Node connect(Node root) {
    if (root == null) {
        return null;
    }
    Node leftmost = root;
    while (leftmost.left != null) {
        Node head = leftmost;
        while (head != null) {
            head.left.next = head.right;
            if (head.next != null) {
                head.right.next = head.next.left;
            }
            head = head.next;
        }
        leftmost = leftmost.left;
    }
    return root;
}
```## Construct Binary Tree from Preorder and Inorder Traversal {#build-tree}

### Description

Build a binary tree from preorder and inorder traversals.

### Solution - Hash Map Recursion

```
public TreeNode buildTree(int[] preorder, int[] inorder) {
    Map<Integer, Integer> indexMap = new HashMap<>();
    for (int i = 0; i < inorder.length; i++) {
        indexMap.put(inorder[i], i);
    }
    return build(preorder, 0, preorder.length - 1, 0, inorder.length - 1, indexMap);
}

private TreeNode build(int[] preorder, int preL, int preR, int inL, int inR, Map<Integer, Integer> indexMap) {
    if (preL > preR) {
        return null;
    }
    int rootVal = preorder[preL];
    TreeNode root = new TreeNode(rootVal);
    int inorderRootIndex = indexMap.get(rootVal);
    int leftSize = inorderRootIndex - inL;
    root.left = build(preorder, preL + 1, preL + leftSize, inL, inorderRootIndex - 1, indexMap);
    root.right = build(preorder, preL + leftSize + 1, preR, inorderRootIndex + 1, inR, indexMap);
    return root;
}
```
