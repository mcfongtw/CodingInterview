# Searching and Sorting

## Sort List {#sort-list}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 148
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/sort-list/
- **Tags**: `Linked List`, `Divide and Conquer`
- **Techniques**: \@ref(dnc), \@ref(ms), \@ref(recursion)

### Description

Given the head of a singly linked list, sort the list in ascending order using constant auxiliary space and return the head of the sorted list.

### Examples

```
Input: head = [4,2,1,3]
Output: [1,2,3,4]

Input: head = [-1,5,3,4,0]
Output: [-1,0,3,4,5]
```

### Constraints

- `0 <= n <= 5 * 10^4`, where `n` is the number of nodes
- `-10^5 <= Node.val <= 10^5`

### Solution - Merge Sort on Linked List

#### Walkthrough

Merge sort divides the list at its midpoint, recursively sorts each half, and merges both sorted halves. Two pointers (`slow`, `fast`) locate the middle while `midPrev` severs the list into two halves. The `merge` helper takes two sorted lists and stitches them together in ascending order.

#### Analysis

- **Time Complexity**: O(n log n), merge sort across the list
- **Space Complexity**: O(1) auxiliary (recursion stack ignored per problem statement) plus O(log n) call stack

#### Algorithm

\@ref(dnc), \@ref(ms), \@ref(recursion)

1. If the list has zero or one node, return it.
2. Use slow/fast pointers to find the midpoint; disconnect the first half.
3. Recursively sort both halves.
4. Merge the sorted halves with a linear scan and return the merged head.

#### Java Code

```java
public class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode midPrev = null;
        ListNode slow = head;
        ListNode fast = head;

        while (fast != null && fast.next != null) {
            midPrev = slow;
            slow = slow.next;
            fast = fast.next.next;
        }

        midPrev.next = null; // split the list
        ListNode left = sortList(head);
        ListNode right = sortList(slow);
        return merge(left, right);
    }

    private ListNode merge(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode tail = dummy;
        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                tail.next = l1;
                l1 = l1.next;
            } else {
                tail.next = l2;
                l2 = l2.next;
            }
            tail = tail.next;
        }
        tail.next = (l1 != null) ? l1 : l2;
        return dummy.next;
    }
}
```

## Insertion Sort List {#insertion-sort-list}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 147
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/insertion-sort-list/
- **Tags**: `Linked List`, `Sorting`
- **Techniques**: \@ref(sorting)

### Description

Sort a singly linked list using the insertion sort algorithm and return the head of the sorted list.

### Examples

```
Input: head = [4,2,1,3]
Output: [1,2,3,4]

Input: head = [-1,5,3,4,0]
Output: [-1,0,3,4,5]
```

### Constraints

- `0 <= n <= 5 * 10^4`
- `-10^5 <= Node.val <= 10^5`

### Solution - Dummy Head Insertion

#### Walkthrough

Traverse the list and insert each node into the correct position of a growing sorted prefix. A dummy head simplifies insertion at the front. For each node removed from the original list, linearly search the sorted portion to place it where `prev.val <= node.val < prev.next.val`.

#### Analysis

- **Time Complexity**: O(n^2) due to repeated linear scans for each insertion
- **Space Complexity**: O(1) extra space

#### Algorithm

\@ref(sorting)

1. Create `dummy` pointing to `null`; `curr` traverses the original list.
2. For each `curr`, remove it from the list and find its insert location starting from `dummy`.
3. Splice `curr` between `prev` and `prev.next`.
4. Continue until all nodes are inserted; return `dummy.next`.

#### Java Code

```java
public class Solution {
    public ListNode insertionSortList(ListNode head) {
        ListNode dummy = new ListNode(Integer.MIN_VALUE);
        ListNode curr = head;

        while (curr != null) {
            ListNode next = curr.next;
            ListNode prev = dummy;
            while (prev.next != null && prev.next.val < curr.val) {
                prev = prev.next;
            }
            curr.next = prev.next;
            prev.next = curr;
            curr = next;
        }

        return dummy.next;
    }
}
```

## Selection Sort Array {#selection-sort-array}

### Problem Metadata

- **Platform**: Firecode.io
- **Problem ID**: Selection Sort Array
- **Difficulty**: Level 2
- **URL**: https://www.firecode.io/courses
- **Tags**: `Array`, `Sorting`
- **Techniques**: \@ref(sorting)

### Description

Given an integer array, sort it in ascending order using the selection sort algorithm.

### Examples

```
Input: [3,5,1,4,2]
Output: [1,2,3,4,5]
```

### Constraints

- `1 <= n <= 10^4`
- Elements fit in 32-bit signed integers

### Solution - Iterative Selection

#### Walkthrough

Selection sort repeatedly selects the smallest remaining element and swaps it into the next output position. For each index `i`, scan the suffix `[i, n)` to find the minimum value and swap it with `arr[i]`.

#### Analysis

- **Time Complexity**: O(n^2) due to nested loops
- **Space Complexity**: O(1)

#### Algorithm

\@ref(sorting)

1. For `i` from `0` to `n - 1`, set `minIndex = i`.
2. For `j` from `i + 1` to `n - 1`, update `minIndex` when `arr[j] < arr[minIndex]`.
3. Swap `arr[i]` with `arr[minIndex]`.
4. Return the sorted array.

#### Java Code

```java
public int[] selectionSort(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
        int minIndex = i;
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        int temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
}
```

## Quick Sort Array {#quick-sort-array}

### Problem Metadata

- **Platform**: Interview Prep
- **Problem ID**: Quick Sort
- **Difficulty**: Medium
- **URL**: N/A
- **Tags**: `Array`, `Divide and Conquer`, `Sorting`
- **Techniques**: \@ref(dnc), \@ref(qs)

### Description

Sort an integer array in ascending order using the quick sort algorithm.

### Examples

```
Input: [10,7,8,9,1,5]
Output: [1,5,7,8,9,10]
```

### Constraints

- `1 <= n <= 10^5`
- Elements fit in 32-bit signed integers

### Solution - Lomuto Partitioning

#### Walkthrough

Quick sort picks a pivot (last element), partitions the array so values smaller than the pivot appear to its left, and recurses on both subarrays. The Lomuto partition scheme swaps each value less than the pivot into the correct region and finally places the pivot at its final index.

#### Analysis

- **Time Complexity**: Average O(n log n); worst-case O(n^2) when pivot choices are poor
- **Space Complexity**: O(log n) recursion stack

#### Algorithm

\@ref(dnc), \@ref(qs)

1. Recursively sort the subarray `[lo, hi]`.
2. Choose `arr[hi]` as the pivot, partition so `pivotIndex` is the final pivot position.
3. Recursively quick sort `[lo, pivotIndex - 1]` and `[pivotIndex + 1, hi]`.
4. Base case when `lo >= hi`.

#### Java Code

```java
public void quickSort(int[] arr) {
    quickSort(arr, 0, arr.length - 1);
}

private void quickSort(int[] arr, int lo, int hi) {
    if (lo >= hi) {
        return;
    }
    int pivotIndex = partition(arr, lo, hi);
    quickSort(arr, lo, pivotIndex - 1);
    quickSort(arr, pivotIndex + 1, hi);
}

private int partition(int[] arr, int lo, int hi) {
    int pivot = arr[hi];
    int i = lo;
    for (int j = lo; j < hi; j++) {
        if (arr[j] <= pivot) {
            swap(arr, i, j);
            i++;
        }
    }
    swap(arr, i, hi);
    return i;
}

private void swap(int[] arr, int i, int j) {
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}
```

## Top K Elements {#top-k-elements}

### Problem Metadata

- **Platform**: Interview Prep
- **Problem ID**: Top K Elements
- **Difficulty**: Medium
- **URL**: N/A
- **Tags**: `Array`, `Sorting`, `Heap`
- **Techniques**: \@ref(sorting), \@ref(heap), \@ref(bs)

### Description

Given an unsorted array `nums` and an integer `k`, return the `k` largest elements. The order of the result can be either sorted descending or unspecified depending on the approach.

### Examples

```
Input: nums = [3,2,1,5,6,4], k = 2
Output: [6,5]
```

### Constraints

- `1 <= k <= n <= 10^5`
- `-10^4 <= nums[i] <= 10^4`

### Solution 1 - Sort Then Slice

#### Walkthrough

Sort the entire array in ascending order and copy the last `k` values, reversing if descending order is required. This is simple but costs O(n log n).

#### Analysis

- **Time Complexity**: O(n log n)
- **Space Complexity**: O(1) auxiliary (in-place sort)

#### Algorithm

\@ref(sorting)

1. Sort `nums` ascending.
2. Copy elements from `n - k` to `n - 1` into the answer array (optionally reverse).

#### Java Code

```java
public int[] topKBySorting(int[] nums, int k) {
    Arrays.sort(nums);
    int[] result = new int[k];
    for (int i = 0; i < k; i++) {
        result[i] = nums[nums.length - 1 - i];
    }
    return result;
}
```

### Solution 2 - Partial Bubble (k Passes)

#### Walkthrough

Bubble sort guarantees that after one full pass the largest element bubbles to the end. Running only `k` passes yields the `k` largest elements at the array tail without fully sorting the remainder.

#### Analysis

- **Time Complexity**: O(n * k)
- **Space Complexity**: O(1)

#### Algorithm

\@ref(bs)

1. Repeat `k` times:
   1. Sweep the array bubbling the largest remaining element to the end.
2. Read off the last `k` positions as the answer.

#### Java Code

```java
public int[] topKByPartialBubble(int[] nums, int k) {
    for (int pass = 0; pass < k; pass++) {
        for (int j = 0; j < nums.length - pass - 1; j++) {
            if (nums[j] > nums[j + 1]) {
                int tmp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = tmp;
            }
        }
    }
    int[] result = new int[k];
    for (int i = 0; i < k; i++) {
        result[i] = nums[nums.length - 1 - i];
    }
    return result;
}
```

### Solution 3 - Min Heap of Size k

#### Walkthrough

Maintain a min heap that stores the current `k` largest numbers. Push each number and pop whenever the heap size exceeds `k`. After processing all numbers the heap contains exactly the answer set, and polling yields increasing order.

#### Analysis

- **Time Complexity**: O(n log k)
- **Space Complexity**: O(k)

#### Algorithm

\@ref(heap)

1. Initialize an empty min heap.
2. For each `num` in `nums`, push it; if heap size exceeds `k`, pop the smallest.
3. Extract remaining heap elements into the answer array (reverse if descending needed).

#### Java Code

```java
public int[] topKByMinHeap(int[] nums, int k) {
    PriorityQueue<Integer> heap = new PriorityQueue<>();
    for (int num : nums) {
        heap.offer(num);
        if (heap.size() > k) {
            heap.poll();
        }
    }
    int[] result = new int[k];
    for (int i = k - 1; i >= 0; i--) {
        result[i] = heap.poll();
    }
    return result;
}
```

