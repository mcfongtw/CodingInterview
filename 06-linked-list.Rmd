# Linked List

## Add Two Numbers {#add-two-numbers}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 2
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/add-two-numbers/
- **Tags**: `Linked List`
- **Techniques**: Simulation

### Description

Given two non-empty linked lists representing non-negative integers in reverse order, add the numbers and return the sum as a linked list.

### Examples

```
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
```

### Constraints

- `1 <= len(l1), len(l2) <= 100`
- Digits stored in reverse order; each node contains a single digit

### Solution - Iterative Carry Addition

#### Walkthrough

Use two pointers traversing the lists simultaneously. Maintain a `carry`. At each step sum the corresponding digits and carry, append a node with `sum % 10`, and update carry to `sum / 10`. Continue until both lists and the carry are exhausted.

#### Analysis

- **Time Complexity**: O(max(m, n))
- **Space Complexity**: O(max(m, n)) for the output list

#### Algorithm

1. Initialize dummy head, `tail`, and `carry = 0`.
2. While `l1` or `l2` is non-null or `carry > 0`, compute `sum = carry + l1.val + l2.val`.
3. Append new node with `sum % 10`, set `carry = sum / 10`, advance pointers.
4. Return `dummy.next`.

#### Java Code

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0);
    ListNode tail = dummy;
    int carry = 0;

    while (l1 != null || l2 != null || carry != 0) {
        int sum = carry;
        if (l1 != null) {
            sum += l1.val;
            l1 = l1.next;
        }
        if (l2 != null) {
            sum += l2.val;
            l2 = l2.next;
        }
        carry = sum / 10;
        tail.next = new ListNode(sum % 10);
        tail = tail.next;
    }

    return dummy.next;
}
```

## Reverse Linked List {#reverse-linked-list}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 206
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/reverse-linked-list/
- **Tags**: `Linked List`
- **Techniques**: Two Pointers, Recursion

### Description

Reverse a singly linked list.

### Solution - Iterative Two Pointers

#### Walkthrough

Maintain `prev`, `curr`, and `next`. Iteratively reverse the `next` pointer of each node until the list is reversed.

#### Analysis

- **Time Complexity**: O(n)
- **Space Complexity**: O(1)

#### Java Code

```java
public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode curr = head;
    while (curr != null) {
        ListNode next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}
```

### Solution - Recursive

```java
public ListNode reverseListRecursive(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode newHead = reverseListRecursive(head.next);
    head.next.next = head;
    head.next = null;
    return newHead;
}
```

## Reverse Linked List II {#reverse-linked-list-ii}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 92
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/reverse-linked-list-ii/
- **Tags**: `Linked List`
- **Techniques**: In-place reversal

### Description

Reverse the nodes between positions `left` and `right` (1-indexed) in a linked list.

### Solution - Head Insertion

```java
public ListNode reverseBetween(ListNode head, int left, int right) {
    if (head == null || left == right) {
        return head;
    }

    ListNode dummy = new ListNode(0, head);
    ListNode prev = dummy;
    for (int i = 1; i < left; i++) {
        prev = prev.next;
    }

    ListNode curr = prev.next;
    for (int i = 0; i < right - left; i++) {
        ListNode next = curr.next;
        curr.next = next.next;
        next.next = prev.next;
        prev.next = next;
    }

    return dummy.next;
}
```

## Reverse Nodes in k-Group {#reverse-k-group}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 25
- **Difficulty**: Hard
- **URL**: https://leetcode.com/problems/reverse-nodes-in-k-group/
- **Tags**: `Linked List`

### Description

Reverse the list in groups of size `k`. Remaining nodes (< k) stay as-is.

### Solution - Iterative Group Reversal

```java
public ListNode reverseKGroup(ListNode head, int k) {
    if (head == null || k <= 1) {
        return head;
    }
    ListNode dummy = new ListNode(0, head);
    ListNode groupPrev = dummy;

    while (true) {
        ListNode kth = getKth(groupPrev, k);
        if (kth == null) {
            break;
        }
        ListNode groupNext = kth.next;
        ListNode prev = groupNext;
        ListNode curr = groupPrev.next;
        while (curr != groupNext) {
            ListNode next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        ListNode tmp = groupPrev.next;
        groupPrev.next = kth;
        groupPrev = tmp;
    }

    return dummy.next;
}

private ListNode getKth(ListNode start, int k) {
    while (start != null && k > 0) {
        start = start.next;
        k--;
    }
    return start;
}
```

## Linked List Cycle {#linked-list-cycle}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 141
- **Difficulty**: Easy
- **URL**: https://leetcode.com/problems/linked-list-cycle/
- **Tags**: `Linked List`, `Two Pointers`

### Description

Detect whether a linked list has a cycle.

### Solution - Floydâ€™s Algorithm

```java
public boolean hasCycle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast) {
            return true;
        }
    }
    return false;
}
```

## Linked List Cycle II {#linked-list-cycle-ii}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 142
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/linked-list-cycle-ii/
- **Tags**: `Linked List`, `Two Pointers`

### Description

Return the node where the cycle begins, or null if none.

```java
public ListNode detectCycle(ListNode head) {
    ListNode slow = head, fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast) {
            ListNode ptr = head;
            while (ptr != slow) {
                ptr = ptr.next;
                slow = slow.next;
            }
            return ptr;
        }
    }
    return null;
}
```

## Odd Even Linked List {#odd-even-list}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 328
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/odd-even-linked-list/

### Description

Group odd-position nodes followed by even-position nodes.

```java
public ListNode oddEvenList(ListNode head) {
    if (head == null) return null;
    ListNode odd = head;
    ListNode even = head.next;
    ListNode evenHead = even;
    while (even != null && even.next != null) {
        odd.next = even.next;
        odd = odd.next;
        even.next = odd.next;
        even = even.next;
    }
    odd.next = evenHead;
    return head;
}
```

## Merge Two Sorted Lists {#merge-two-sorted}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 21
- **Difficulty**: Easy

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0);
    ListNode tail = dummy;
    while (l1 != null && l2 != null) {
        if (l1.val <= l2.val) {
            tail.next = l1;
            l1 = l1.next;
        } else {
            tail.next = l2;
            l2 = l2.next;
        }
        tail = tail.next;
    }
    tail.next = (l1 != null) ? l1 : l2;
    return dummy.next;
}
```

## Merge k Sorted Lists {#merge-k-sorted}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 23
- **Difficulty**: Hard

```java
public ListNode mergeKLists(ListNode[] lists) {
    PriorityQueue<ListNode> pq = new PriorityQueue<>(Comparator.comparingInt(n -> n.val));
    for (ListNode node : lists) {
        if (node != null) {
            pq.offer(node);
        }
    }
    ListNode dummy = new ListNode(0);
    ListNode tail = dummy;
    while (!pq.isEmpty()) {
        ListNode node = pq.poll();
        tail.next = node;
        tail = tail.next;
        if (node.next != null) {
            pq.offer(node.next);
        }
    }
    return dummy.next;
}
```

## Palindrome Linked List {#palindrome-list}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 234
- **Difficulty**: Easy

```java
public boolean isPalindrome(ListNode head) {
    if (head == null || head.next == null) return true;
    ListNode slow = head, fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    ListNode second = reverse(slow);
    ListNode first = head;
    ListNode copy = second;
    boolean result = true;
    while (result && second != null) {
        if (first.val != second.val) result = false;
        first = first.next;
        second = second.next;
    }
    reverse(copy);
    return result;
}
```

## Intersection of Two Linked Lists {#intersection-linked-lists}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 160
- **Difficulty**: Easy

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    if (headA == null || headB == null) return null;
    ListNode a = headA, b = headB;
    while (a != b) {
        a = (a == null) ? headB : a.next;
        b = (b == null) ? headA : b.next;
    }
    return a;
}
```

## Remove Nth Node From End of List {#remove-nth-node}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 19
- **Difficulty**: Medium

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummy = new ListNode(0, head);
    ListNode first = dummy, second = dummy;
    for (int i = 0; i <= n; i++) {
        first = first.next;
    }
    while (first != null) {
        first = first.next;
        second = second.next;
    }
    second.next = second.next.next;
    return dummy.next;
}
```

## Insert Node at Position in Doubly Linked List {#insert-dll}

### Description

Insert a value at position `pos` (1-indexed) in a doubly linked list.

```java
public DLLNode insertAt(DLLNode head, int pos, int val) {
    DLLNode node = new DLLNode(val);
    if (pos == 1) {
        node.next = head;
        if (head != null) head.prev = node;
        return node;
    }
    DLLNode curr = head;
    for (int i = 1; curr != null && i < pos - 1; i++) {
        curr = curr.next;
    }
    if (curr == null) return head;
    node.next = curr.next;
    if (curr.next != null) curr.next.prev = node;
    curr.next = node;
    node.prev = curr;
    return head;
}
```

## Reorder List {#reorder-list}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 143
- **Difficulty**: Medium

```java
public void reorderList(ListNode head) {
    if (head == null || head.next == null) return;
    ListNode slow = head, fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    ListNode second = reverse(slow.next);
    slow.next = null;
    ListNode first = head;
    while (second != null) {
        ListNode tmp1 = first.next;
        ListNode tmp2 = second.next;
        first.next = second;
        second.next = tmp1;
        first = tmp1;
        second = tmp2;
    }
}
```

## Remove Duplicates from Sorted List {#remove-duplicates}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 83
- **Difficulty**: Easy

```java
public ListNode deleteDuplicates(ListNode head) {
    ListNode curr = head;
    while (curr != null && curr.next != null) {
        if (curr.val == curr.next.val) {
            curr.next = curr.next.next;
        } else {
            curr = curr.next;
        }
    }
    return head;
}
```

## Copy List with Random Pointer {#copy-random-list}

### Problem Metadata

- **Platform**: LeetCode
- **Problem ID**: 138
- **Difficulty**: Medium
- **URL**: https://leetcode.com/problems/copy-list-with-random-pointer/

### Description

Deep copy a linked list where each node has `next` and `random` pointers.

```java
public Node copyRandomList(Node head) {
    if (head == null) return null;
    for (Node curr = head; curr != null; curr = curr.next.next) {
        Node copy = new Node(curr.val);
        copy.next = curr.next;
        curr.next = copy;
    }
    for (Node curr = head; curr != null; curr = curr.next.next) {
        if (curr.random != null) {
            curr.next.random = curr.random.next;
        }
    }
    Node pseudoHead = new Node(0);
    Node copyCurr = pseudoHead;
    Node curr = head;
    while (curr != null) {
        copyCurr.next = curr.next;
        curr.next = curr.next.next;
        curr = curr.next;
        copyCurr = copyCurr.next;
    }
    return pseudoHead.next;
}
```
